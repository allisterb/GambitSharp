// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace gambit
{
    namespace Gambit
    {
        namespace MixedStrategyProfile
        {
            [StructLayout(LayoutKind.Sequential, Size = 48)]
            public unsafe partial struct __Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational
            {
                internal __IntPtr vfptr_MixedStrategyProfile;
                internal __IntPtr m_rep;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep___N_Gambit_S_Rational___N_std_S_less__S3____N_std_S_allocator____N_std_S_pair__1S3__S5____N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_ map_strategy_payoffs;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_Gambit_S_Rational___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_ map_profile_payoffs;
            }

            [StructLayout(LayoutKind.Sequential, Size = 48)]
            public unsafe partial struct __Internalc__N_Gambit_S_MixedStrategyProfile__d
            {
                internal __IntPtr vfptr_MixedStrategyProfile;
                internal __IntPtr m_rep;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep_d___N_std_S_less__S3____N_std_S_allocator____N_std_S_pair__1S3__d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_ map_strategy_payoffs;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep_d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__d map_profile_payoffs;
            }
        }

        /// <summary>A probability distribution over strategies in a game</summary>
        /// <remarks>
        /// <para>A probability distribution over strategies, such that each player</para>
        /// <para>independently chooses from among his strategies with specified</para>
        /// <para>probabilities.</para>
        /// </remarks>
        public unsafe partial class MixedStrategyProfile<T> : IDisposable
        {
            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.MixedStrategyProfile<T>> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.MixedStrategyProfile<T>>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.MixedStrategyProfile<T> managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.MixedStrategyProfile<T> managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static MixedStrategyProfile<T> __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new MixedStrategyProfile<T>(native.ToPointer(), skipVTables);
            }

            internal static MixedStrategyProfile<T> __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (MixedStrategyProfile<T>)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static MixedStrategyProfile<T> __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (MixedStrategyProfile<T>)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static MixedStrategyProfile<T> __CreateInstance(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational native, bool skipVTables = false)
            {
                return new MixedStrategyProfile<T>(native, skipVTables);
            }

            private static void* __CopyValue(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational));
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) ret = native;
                return ret.ToPointer();
            }

            private MixedStrategyProfile(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal static MixedStrategyProfile<T> __CreateInstance(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d native, bool skipVTables = false)
            {
                return new MixedStrategyProfile<T>(native, skipVTables);
            }

            private static void* __CopyValue(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d));
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) ret = native;
                return ret.ToPointer();
            }

            private MixedStrategyProfile(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected MixedStrategyProfile(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            public MixedStrategyProfile(global::gambit.Gambit.MixedStrategyProfileRep<T> p_rep)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method MixedStrategyProfile_T_ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method MixedStrategyProfile_T_ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Convert a behavior strategy profile to a mixed strategy profile</summary>
            public MixedStrategyProfile(global::gambit.Gambit.MixedBehaviorProfile<T> _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method MixedStrategyProfile_T_ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method MixedStrategyProfile_T_ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Make a copy of the mixed strategy profile</summary>
            public MixedStrategyProfile(global::gambit.Gambit.MixedStrategyProfile<T> _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method MixedStrategyProfile_T_ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method MixedStrategyProfile_T_ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Check underlying game has not changed; raise exception if it has</summary>
            public void CheckVersion()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method CheckVersion ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method CheckVersion ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Test for the equality of two profiles</summary>
            public static bool operator ==(global::gambit.Gambit.MixedStrategyProfile<T> __op, global::gambit.Gambit.MixedStrategyProfile<T> p_profile)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::gambit.Gambit.MixedStrategyProfile<T>;
            }

            public override int GetHashCode()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) __Instance).GetHashCode();
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Test for the inequality of two profiles</summary>
            public static bool operator !=(global::gambit.Gambit.MixedStrategyProfile<T> __op, global::gambit.Gambit.MixedStrategyProfile<T> p_profile)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public static implicit operator global::gambit.Gambit.Vector<T>(global::gambit.Gambit.MixedStrategyProfile<T> __op)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator_const_Vector_type_parameter_0_0___ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator_const_Vector_type_parameter_0_0___ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Sets all strategies for each player to equal probabilities</summary>
            public void SetCentroid()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method SetCentroid ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method SetCentroid ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>
            /// <para>Create a new mixed strategy profile where strategies are played</para>
            /// <para>in the same proportions, but with probabilities for each player</para>
            /// <para>summing to one.</para>
            /// </summary>
            public global::gambit.Gambit.MixedStrategyProfile<T> Normalize()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method Normalize ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method Normalize ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Converts the profile to one on the full support of the game</summary>
            public global::gambit.Gambit.MixedStrategyProfile<T> ToFullSupport()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method ToFullSupport ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method ToFullSupport ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Used to read payoffs from cache or compute them and cache them if needed</summary>
            public void ComputePayoffs()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method ComputePayoffs ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method ComputePayoffs ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Reset cache for payoffs and strategy values</summary>
            public virtual void InvalidateCache()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    var ___InvalidateCacheDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr>(0, 1);
                    ___InvalidateCacheDelegate(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    var ___InvalidateCacheDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr>(0, 1, 1);
                    ___InvalidateCacheDelegate(__Instance);
                    return;
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Computes the payoff of the profile to player 'pl'</summary>
            public T GetPayoff(int pl)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Computes the payoff of the profile to the player</summary>
            public T GetPayoff(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> p_player)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Computes the derivative of the player's payoff</summary>
            /// <remarks>
            /// <para>Computes the derivative of the payoff to the player with respect</para>
            /// <para>to the probability the strategy is played</para>
            /// </remarks>
            public T GetPayoffDeriv(int pl, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> s)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetPayoffDeriv ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetPayoffDeriv ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Computes the second derivative of the player's payoff</summary>
            /// <remarks>
            /// <para>Computes the second derivative of the payoff to the player,</para>
            /// <para>with respect to the probabilities with which the strategies are played</para>
            /// </remarks>
            public T GetPayoffDeriv(int pl, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> s1, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> s2)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetPayoffDeriv ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetPayoffDeriv ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Computes the payoff to playing the pure strategy against the profile</summary>
            public T GetPayoff(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> p_strategy)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Computes the regret to playing</summary>
            /// <param name="p_strategy">The strategy to compute the regret for.</param>
            /// <remarks>
            /// <para>Computes the regret to the player of playing strategyagainst the profile.  The regret is defined as the difference</para>
            /// <para>between the best-response payoff and the payoff to playing</para>
            /// <para>GetRegret(const GamePlayer&amp;) const;</para>
            /// <para>GetMaxRegret() const</para>
            /// </remarks>
            public T GetRegret(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> p_strategy)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetRegret ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetRegret ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Computes the regret for player</summary>
            /// <param name="p_player">The player to compute the regret for.</param>
            /// <remarks>
            /// <para>Computes the regret to the player of playing their mixed strategy</para>
            /// <para>as specified in the profile.  The regret is defined as the difference</para>
            /// <para>between the player's best-response payoff and the payoff to playing</para>
            /// <para>their specified mixed strategy.</para>
            /// <para>GetRegret(const GameStrategy&amp;) const;</para>
            /// <para>GetMaxRegret() const</para>
            /// </remarks>
            public T GetRegret(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> p_player)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetRegret ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetRegret ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public static explicit operator global::gambit.Gambit.MixedStrategyProfile<T>(global::gambit.Gambit.MixedStrategyProfileRep<T> p_rep)
            {
                return new global::gambit.Gambit.MixedStrategyProfile<T>(p_rep);
            }

            public static explicit operator global::gambit.Gambit.MixedStrategyProfile<T>(global::gambit.Gambit.MixedBehaviorProfile<T> _0)
            {
                return new global::gambit.Gambit.MixedStrategyProfile<T>(_0);
            }

            public T this[int i]
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public T this[global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> p_strategy]
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public global::gambit.Gambit.Vector<T> this[global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> p_player]
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            /// <summary>Returns the game on which the profile is defined</summary>
            public global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> Game
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Game missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Game missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            /// <summary>Returns the support on which the profile is defined</summary>
            public global::gambit.Gambit.StrategySupportProfile Support
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Support missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Support missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            /// <summary>Returns whether the profile has been invalidated by a subsequent revision to the game</summary>
            public bool IsInvalidated
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method IsInvalidated missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method IsInvalidated missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            /// <summary>Returns the total number of strategies in the profile</summary>
            public ulong MixedProfileLength
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method MixedProfileLength missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method MixedProfileLength missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            /// <summary>Computes the maximum regret to any player in the profile</summary>
            /// <remarks>
            /// <para>Computes the maximum of the regrets of the players in the profile.</para>
            /// <para>GetRegret(const GamePlayer&amp;) const;</para>
            /// <para>GetRegret(const GameStrategy&amp;) const</para>
            /// </remarks>
            public T MaxRegret
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method MaxRegret missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method MaxRegret missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            /// <summary>Computes the Lyapunov value of the profile</summary>
            /// <remarks>
            /// <para>Computes the Lyapunov value of the profile.  This is a nonnegative</para>
            /// <para>value which is zero exactly at Nash equilibria.  This version</para>
            /// <para>implements a positive penalty for profiles which are not on the</para>
            /// <para>simplotope (useful for penalty-function minimization methods).</para>
            /// </remarks>
            public T LiapValue
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method LiapValue missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method LiapValue missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            #region Virtual table interop

            // virtual ~MixedStrategyProfile()
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.MixedStrategyProfile<T>.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // void InvalidateCache() const
            private static global::gambit.Delegates.Action___IntPtr _InvalidateCacheDelegateInstance;

            private static void _InvalidateCacheDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.MixedStrategyProfile<T>.__GetInstance(__instance);
                __target.InvalidateCache();
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _InvalidateCacheDelegateInstance += _InvalidateCacheDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_InvalidateCacheDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        namespace MixedStrategyProfileRep
        {
            [StructLayout(LayoutKind.Sequential, Size = 96)]
            public unsafe partial struct __Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational
            {
                internal __IntPtr vfptr_MixedStrategyProfileRep;
                internal global::gambit.Gambit.Vector.__Internal m_probs;
                internal global::gambit.Gambit.StrategySupportProfile.__Internal m_support;
                internal uint m_gameversion;

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "c__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational_F_MixedStrategyProfileRep___1__N_Gambit_S_MixedStrategyProfileRep__S0", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational(__IntPtr __instance, __IntPtr _0);
            }

            [StructLayout(LayoutKind.Sequential, Size = 96)]
            public unsafe partial struct __Internalc__N_Gambit_S_MixedStrategyProfileRep__d
            {
                internal __IntPtr vfptr_MixedStrategyProfileRep;
                internal global::gambit.Gambit.Vector.__Internal m_probs;
                internal global::gambit.Gambit.StrategySupportProfile.__Internal m_support;
                internal uint m_gameversion;

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "c__N_Gambit_S_MixedStrategyProfileRep__d_F_MixedStrategyProfileRep___1__N_Gambit_S_MixedStrategyProfileRep__d", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_Gambit_S_MixedStrategyProfileRep__d(__IntPtr __instance, __IntPtr _0);
            }
        }

        public unsafe abstract partial class MixedStrategyProfileRep<T> : IDisposable
        {
            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.MixedStrategyProfileRep<T>> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.MixedStrategyProfileRep<T>>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.MixedStrategyProfileRep<T> managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.MixedStrategyProfileRep<T> managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static MixedStrategyProfileRep<T> __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new MixedStrategyProfileRepInternal<T>(native.ToPointer(), skipVTables);
            }

            internal static MixedStrategyProfileRep<T> __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (MixedStrategyProfileRep<T>)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static MixedStrategyProfileRep<T> __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (MixedStrategyProfileRep<T>)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static MixedStrategyProfileRep<T> __CreateInstance(global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational native, bool skipVTables = false)
            {
                return new MixedStrategyProfileRepInternal<T>(native, skipVTables);
            }

            internal static MixedStrategyProfileRep<T> __CreateInstance(global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d native, bool skipVTables = false)
            {
                return new MixedStrategyProfileRepInternal<T>(native, skipVTables);
            }

            protected MixedStrategyProfileRep(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected MixedStrategyProfileRep(global::gambit.Gambit.StrategySupportProfile _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method MixedStrategyProfileRep_T_ ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method MixedStrategyProfileRep_T_ ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void SetCentroid()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method SetCentroid ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method SetCentroid ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public global::gambit.Gambit.MixedStrategyProfileRep<T> Normalize()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method Normalize ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method Normalize ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public abstract T GetPayoff(int pl);

            public abstract T GetPayoffDeriv(int pl, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> _0);

            public abstract T GetPayoffDeriv(int pl, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> _0, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> _1);

            public T GetPayoff(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> p_player)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T GetPayoff(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> p_strategy)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T GetRegret(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetRegret ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetRegret ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T GetRegret(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetRegret ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetRegret ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public virtual void InvalidateCache()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    var ___InvalidateCacheDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr>(0, 5);
                    ___InvalidateCacheDelegate(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    var ___InvalidateCacheDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr>(0, 5, 1);
                    ___InvalidateCacheDelegate(__Instance);
                    return;
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T this[global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> p_strategy]
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfileRep<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfileRep<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public global::gambit.Gambit.Vector<T> MProbs
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        return (global::gambit.Gambit.Vector<T>) (object) global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.__CreateInstance(new __IntPtr(&((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational*)__Instance)->m_probs));
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        return (global::gambit.Gambit.Vector<T>) (object) global::gambit.Gambit.Vector<double>.__CreateInstance(new __IntPtr(&((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d*)__Instance)->m_probs));
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational*)__Instance)->m_probs = *(global::gambit.Gambit.Vector.__Internal*) value.__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d*)__Instance)->m_probs = *(global::gambit.Gambit.Vector.__Internal*) value.__Instance;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public global::gambit.Gambit.StrategySupportProfile MSupport
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        return global::gambit.Gambit.StrategySupportProfile.__CreateInstance(new __IntPtr(&((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational*)__Instance)->m_support));
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        return global::gambit.Gambit.StrategySupportProfile.__CreateInstance(new __IntPtr(&((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d*)__Instance)->m_support));
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational*)__Instance)->m_support = *(global::gambit.Gambit.StrategySupportProfile.__Internal*) value.__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d*)__Instance)->m_support = *(global::gambit.Gambit.StrategySupportProfile.__Internal*) value.__Instance;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public uint MGameversion
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        return ((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational*)__Instance)->m_gameversion;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        return ((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d*)__Instance)->m_gameversion;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        ((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational*)__Instance)->m_gameversion = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        ((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d*)__Instance)->m_gameversion = value;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public abstract global::gambit.Gambit.MixedStrategyProfileRep<T> Copy
            {
                get;
            }

            public T MaxRegret
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method MaxRegret missing from explicit specialization global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method MaxRegret missing from explicit specialization global::gambit.Gambit.MixedStrategyProfileRep<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            #region Virtual table interop

            // virtual ~MixedStrategyProfileRep() = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.MixedStrategyProfileRep<T>.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // MixedStrategyProfileRep<T> *Copy() const = 0
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _CopyDelegateInstance;

            private static __IntPtr _CopyDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.MixedStrategyProfileRep<T>.__GetInstance(__instance);
                var ___ret = __target.Copy;
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // T GetPayoff(int pl) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetPayoffDelegateInstance;

            private static void _GetPayoffDelegateHook(__IntPtr __instance, __IntPtr @return, int pl)
            {
                var __target = global::gambit.Gambit.MixedStrategyProfileRep<T>.__GetInstance(__instance);
                var ___ret = __target.GetPayoff(pl);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Rational.__Internal*) @return = *(global::gambit.Gambit.Rational.__Internal*) ((global::gambit.Gambit.Rational) (object) ___ret).__Instance;
            }

            // T GetPayoffDeriv(int pl, const GameStrategy &, const GameStrategy &) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int___IntPtr___IntPtr _GetPayoffDeriv_1DelegateInstance;

            private static void _GetPayoffDeriv_1DelegateHook(__IntPtr __instance, __IntPtr @return, int pl, __IntPtr _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.MixedStrategyProfileRep<T>.__GetInstance(__instance);
                var __result2 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.__GetOrCreateInstance(_0, false);
                var __result3 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.__GetOrCreateInstance(_1, false);
                var ___ret = __target.GetPayoffDeriv(pl, __result2, __result3);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Rational.__Internal*) @return = *(global::gambit.Gambit.Rational.__Internal*) ((global::gambit.Gambit.Rational) (object) ___ret).__Instance;
            }

            // T GetPayoffDeriv(int pl, const GameStrategy &) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int___IntPtr _GetPayoffDerivDelegateInstance;

            private static void _GetPayoffDerivDelegateHook(__IntPtr __instance, __IntPtr @return, int pl, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.MixedStrategyProfileRep<T>.__GetInstance(__instance);
                var __result2 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.__GetOrCreateInstance(_0, false);
                var ___ret = __target.GetPayoffDeriv(pl, __result2);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Rational.__Internal*) @return = *(global::gambit.Gambit.Rational.__Internal*) ((global::gambit.Gambit.Rational) (object) ___ret).__Instance;
            }

            // void InvalidateCache() const
            private static global::gambit.Delegates.Action___IntPtr _InvalidateCacheDelegateInstance;

            private static void _InvalidateCacheDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.MixedStrategyProfileRep<T>.__GetInstance(__instance);
                __target.InvalidateCache();
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[6];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    _GetPayoffDelegateInstance += _GetPayoffDelegateHook;
                    _GetPayoffDeriv_1DelegateInstance += _GetPayoffDeriv_1DelegateHook;
                    _GetPayoffDerivDelegateInstance += _GetPayoffDerivDelegateHook;
                    _InvalidateCacheDelegateInstance += _InvalidateCacheDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetPayoffDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPayoffDeriv_1DelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetPayoffDerivDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_InvalidateCacheDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                VTables.Methods[0] = new Delegate[6];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class MixedStrategyProfileRepInternal<T> : global::gambit.Gambit.MixedStrategyProfileRep<T>, IDisposable
        {
            private static void* __CopyValue(global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational));
                *(global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational*) ret = native;
                return ret.ToPointer();
            }

            internal MixedStrategyProfileRepInternal(global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            private static void* __CopyValue(global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d));
                *(global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d*) ret = native;
                return ret.ToPointer();
            }

            internal MixedStrategyProfileRepInternal(global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal MixedStrategyProfileRepInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override T GetPayoff(int pl)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    var ___GetPayoffDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 2);
                    var ___ret = new global::gambit.Gambit.Rational.__Internal();
                    ___GetPayoffDelegate(__Instance, new IntPtr(&___ret), pl);
                    var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                    global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    var ___GetPayoffDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_double___IntPtr_int>(0, 2);
                    var ___ret = ___GetPayoffDelegate(__Instance, pl);
                    return ___ret;
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRepInternal<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public override T GetPayoffDeriv(int pl, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    var ___GetPayoffDerivDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int___IntPtr>(0, 4);
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = _0.__Instance;
                    var ___ret = new global::gambit.Gambit.Rational.__Internal();
                    ___GetPayoffDerivDelegate(__Instance, new IntPtr(&___ret), pl, __arg1);
                    var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                    global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    var ___GetPayoffDerivDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_double___IntPtr_int___IntPtr>(0, 4);
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = _0.__Instance;
                    var ___ret = ___GetPayoffDerivDelegate(__Instance, pl, __arg1);
                    return ___ret;
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRepInternal<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public override T GetPayoffDeriv(int pl, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> _0, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> _1)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    var ___GetPayoffDeriv_1Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int___IntPtr___IntPtr>(0, 3);
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = _0.__Instance;
                    if (ReferenceEquals(_1, null))
                        throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                    var __arg2 = _1.__Instance;
                    var ___ret = new global::gambit.Gambit.Rational.__Internal();
                    ___GetPayoffDeriv_1Delegate(__Instance, new IntPtr(&___ret), pl, __arg1, __arg2);
                    var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                    global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    var ___GetPayoffDeriv_1Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_double___IntPtr_int___IntPtr___IntPtr>(0, 3);
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = _0.__Instance;
                    if (ReferenceEquals(_1, null))
                        throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                    var __arg2 = _1.__Instance;
                    var ___ret = ___GetPayoffDeriv_1Delegate(__Instance, pl, __arg1, __arg2);
                    return ___ret;
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRepInternal<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public override global::gambit.Gambit.MixedStrategyProfileRep<T> Copy
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        var ___CopyDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr>(0, 1);
                        var ___ret = ___CopyDelegate(__Instance);
                        var __result0 = global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.__GetOrCreateInstance(___ret, true);
                        return (global::gambit.Gambit.MixedStrategyProfileRep<T>) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        var ___CopyDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr>(0, 1);
                        var ___ret = ___CopyDelegate(__Instance);
                        var __result0 = global::gambit.Gambit.MixedStrategyProfileRep<double>.__GetOrCreateInstance(___ret, true);
                        return (global::gambit.Gambit.MixedStrategyProfileRep<T>) (object) __result0;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRepInternal<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }
        }
    }
}
