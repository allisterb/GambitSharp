// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace gambit
{
    namespace Gambit
    {
        public unsafe partial class IntegerRep : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal ushort len;
                internal ushort sz;
                internal short sgn;
                internal fixed ushort s[1];

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "??0IntegerRep@Gambit@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.IntegerRep> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.IntegerRep>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.IntegerRep managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.IntegerRep managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static IntegerRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new IntegerRep(native.ToPointer(), skipVTables);
            }

            internal static IntegerRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (IntegerRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static IntegerRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new IntegerRep(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private IntegerRep(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected IntegerRep(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public IntegerRep()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.IntegerRep.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public IntegerRep(global::gambit.Gambit.IntegerRep _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.IntegerRep.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::gambit.Gambit.IntegerRep.__Internal*) __Instance) = *((global::gambit.Gambit.IntegerRep.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public ushort Len
            {
                get
                {
                    return ((__Internal*)__Instance)->len;
                }

                set
                {
                    ((__Internal*)__Instance)->len = value;
                }
            }

            public ushort Sz
            {
                get
                {
                    return ((__Internal*)__Instance)->sz;
                }

                set
                {
                    ((__Internal*)__Instance)->sz = value;
                }
            }

            public short Sgn
            {
                get
                {
                    return ((__Internal*)__Instance)->sgn;
                }

                set
                {
                    ((__Internal*)__Instance)->sgn = value;
                }
            }

            public ushort[] S
            {
                get
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<ushort>(((__Internal*)__Instance)->s, 1);
                }

                set
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 1; i++)
                            ((__Internal*)__Instance)->s[i] = value[i];
                    }
                }
            }
        }

        public unsafe partial class Integer : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr rep;

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "??1Integer@Gambit@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Integer> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Integer>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.Integer managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.Integer managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Integer __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Integer(native.ToPointer(), skipVTables);
            }

            internal static Integer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Integer)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Integer __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Integer(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Integer(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Integer(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            protected global::gambit.Gambit.IntegerRep Rep
            {
                get
                {
                    var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(((__Internal*)__Instance)->rep, false);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->rep = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }
        }

        public unsafe partial class integer
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?Ialloc@Gambit@@YAPEAUIntegerRep@1@PEAU21@PEBGHHH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Ialloc(__IntPtr _0, ushort* _1, int _2, int _3, int _4);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?Icalloc@Gambit@@YAPEAUIntegerRep@1@PEAU21@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Icalloc(__IntPtr _0, int _1);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?Icopy_ulong@Gambit@@YAPEAUIntegerRep@1@PEAU21@K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Icopy_ulong(__IntPtr _0, uint _1);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?Icopy_long@Gambit@@YAPEAUIntegerRep@1@PEAU21@J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Icopy_long(__IntPtr _0, int _1);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?Icopy@Gambit@@YAPEAUIntegerRep@1@PEAU21@PEBU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Icopy(__IntPtr _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?Iresize@Gambit@@YAPEAUIntegerRep@1@PEAU21@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Iresize(__IntPtr _0, int _1);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?add@Gambit@@YAPEAUIntegerRep@1@PEBU21@H0HPEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Add(__IntPtr _0, int _1, __IntPtr _2, int _3, __IntPtr _4);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?add@Gambit@@YAPEAUIntegerRep@1@PEBU21@HJPEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Add(__IntPtr _0, int _1, int _2, __IntPtr _3);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?multiply@Gambit@@YAPEAUIntegerRep@1@PEBU21@0PEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Multiply(__IntPtr _0, __IntPtr _1, __IntPtr _2);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?multiply@Gambit@@YAPEAUIntegerRep@1@PEBU21@JPEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Multiply(__IntPtr _0, int _1, __IntPtr _2);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?lshift@Gambit@@YAPEAUIntegerRep@1@PEBU21@JPEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Lshift(__IntPtr _0, int _1, __IntPtr _2);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?lshift@Gambit@@YAPEAUIntegerRep@1@PEBU21@0HPEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Lshift(__IntPtr _0, __IntPtr _1, int _2, __IntPtr _3);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?bitop@Gambit@@YAPEAUIntegerRep@1@PEBU21@0PEAU21@D@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bitop(__IntPtr _0, __IntPtr _1, __IntPtr _2, sbyte _3);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?bitop@Gambit@@YAPEAUIntegerRep@1@PEBU21@JPEAU21@D@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bitop(__IntPtr _0, int _1, __IntPtr _2, sbyte _3);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?power@Gambit@@YAPEAUIntegerRep@1@PEBU21@JPEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Power(__IntPtr _0, int _1, __IntPtr _2);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?div@Gambit@@YAPEAUIntegerRep@1@PEBU21@0PEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Div(__IntPtr _0, __IntPtr _1, __IntPtr _2);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?mod@Gambit@@YAPEAUIntegerRep@1@PEBU21@0PEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Mod(__IntPtr _0, __IntPtr _1, __IntPtr _2);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?div@Gambit@@YAPEAUIntegerRep@1@PEBU21@JPEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Div(__IntPtr _0, int _1, __IntPtr _2);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?mod@Gambit@@YAPEAUIntegerRep@1@PEBU21@JPEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Mod(__IntPtr _0, int _1, __IntPtr _2);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?Compl@Gambit@@YAPEAUIntegerRep@1@PEBU21@PEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Compl(__IntPtr _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?abs@Gambit@@YAPEAUIntegerRep@1@PEBU21@PEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Abs(__IntPtr _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?negate@Gambit@@YAPEAUIntegerRep@1@PEBU21@PEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Negate(__IntPtr _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?gcd@Gambit@@YAPEAUIntegerRep@1@PEBU21@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Gcd(__IntPtr _0, __IntPtr y);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?compare@Gambit@@YAHPEBUIntegerRep@1@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Compare(__IntPtr _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?compare@Gambit@@YAHPEBUIntegerRep@1@J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Compare(__IntPtr _0, int _1);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?ucompare@Gambit@@YAHPEBUIntegerRep@1@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Ucompare(__IntPtr _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?ucompare@Gambit@@YAHPEBUIntegerRep@1@J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Ucompare(__IntPtr _0, int _1);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?Itoa@Gambit@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBUIntegerRep@1@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Itoa(__IntPtr @return, __IntPtr x, int @base, int width);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?cvtItoa@Gambit@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBUIntegerRep@1@V23@AEAHHHHHDDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void CvtItoa(__IntPtr @return, __IntPtr x, __IntPtr fmt, int* fmtlen, int @base, int showbase, int width, int align_right, sbyte fillchar, sbyte Xcase, int showpos);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?atoIntegerRep@Gambit@@YAPEAUIntegerRep@1@PEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr AtoIntegerRep([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string s, int @base);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?Itolong@Gambit@@YAJPEBUIntegerRep@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Itolong(__IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?Itodouble@Gambit@@YANPEBUIntegerRep@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern double Itodouble(__IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?Iislong@Gambit@@YAHPEBUIntegerRep@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Iislong(__IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?Iisdouble@Gambit@@YAHPEBUIntegerRep@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Iisdouble(__IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?lg@Gambit@@YAJPEBUIntegerRep@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Lg(__IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?lg@Gambit@@YAJAEBVInteger@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Lg_1(__IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?ratio@Gambit@@YANAEBVInteger@1@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern double Ratio(__IntPtr x, __IntPtr y);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?gcd@Gambit@@YA?AVInteger@1@AEBV21@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Gcd(__IntPtr @return, __IntPtr _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?even@Gambit@@YAHAEBVInteger@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Even(__IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?odd@Gambit@@YAHAEBVInteger@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Odd(__IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?sign@Gambit@@YAHAEBVInteger@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Sign(__IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?setbit@Gambit@@YAXAEAVInteger@1@J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Setbit(__IntPtr x, int b);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?clearbit@Gambit@@YAXAEAVInteger@1@J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearbit(__IntPtr x, int b);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?testbit@Gambit@@YAHAEBVInteger@1@J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Testbit(__IntPtr x, int b);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?abs@Gambit@@YAXAEBVInteger@1@AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Abs_1(__IntPtr x, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?negate@Gambit@@YAXAEBVInteger@1@AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Negate_1(__IntPtr x, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?complement@Gambit@@YAXAEBVInteger@1@AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Complement(__IntPtr x, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?compare@Gambit@@YAHAEBVInteger@1@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Compare_1(__IntPtr _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?ucompare@Gambit@@YAHAEBVInteger@1@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Ucompare_1(__IntPtr _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?add@Gambit@@YAXAEBVInteger@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Add(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?sub@Gambit@@YAXAEBVInteger@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Sub(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?mul@Gambit@@YAXAEBVInteger@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Mul(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?div@Gambit@@YAXAEBVInteger@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Div_1(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?mod@Gambit@@YAXAEBVInteger@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Mod_1(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?divide@Gambit@@YAXAEBVInteger@1@0AEAV21@1@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Divide(__IntPtr x, __IntPtr y, __IntPtr q, __IntPtr r);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?lshift@Gambit@@YAXAEBVInteger@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Lshift(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?rshift@Gambit@@YAXAEBVInteger@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Rshift(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?pow@Gambit@@YAXAEBVInteger@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Pow(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?compare@Gambit@@YAHAEBVInteger@1@J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Compare_1(__IntPtr _0, int _1);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?ucompare@Gambit@@YAHAEBVInteger@1@J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Ucompare_1(__IntPtr _0, int _1);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?add@Gambit@@YAXAEBVInteger@1@JAEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Add(__IntPtr x, int y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?sub@Gambit@@YAXAEBVInteger@1@JAEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Sub(__IntPtr x, int y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?mul@Gambit@@YAXAEBVInteger@1@JAEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Mul(__IntPtr x, int y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?div@Gambit@@YAXAEBVInteger@1@JAEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Div_1(__IntPtr x, int y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?mod@Gambit@@YAXAEBVInteger@1@JAEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Mod_1(__IntPtr x, int y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?divide@Gambit@@YAXAEBVInteger@1@JAEAV21@AEAJ@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Divide(__IntPtr x, int y, __IntPtr q, int* r);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?lshift@Gambit@@YAXAEBVInteger@1@JAEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Lshift_1(__IntPtr x, int y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?rshift@Gambit@@YAXAEBVInteger@1@JAEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Rshift(__IntPtr x, int y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?pow@Gambit@@YAXAEBVInteger@1@JAEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Pow(__IntPtr x, int y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?compare@Gambit@@YAHJAEBVInteger@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Compare(int _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?ucompare@Gambit@@YAHJAEBVInteger@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Ucompare(int _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?add@Gambit@@YAXJAEBVInteger@1@AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Add(int x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?sub@Gambit@@YAXJAEBVInteger@1@AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Sub(int x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?mul@Gambit@@YAXJAEBVInteger@1@AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Mul(int x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?Itoa@Gambit@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVInteger@1@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Itoa_1(__IntPtr @return, __IntPtr x, int @base, int width);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?atoI@Gambit@@YA?AVInteger@1@PEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AtoI(__IntPtr @return, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string s, int @base);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?abs@Gambit@@YA?AVInteger@1@AEBV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Abs_2(__IntPtr @return, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?sqr@Gambit@@YA?AVInteger@1@AEBV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Sqr(__IntPtr @return, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?pow@Gambit@@YA?AVInteger@1@AEBV21@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Pow_1(__IntPtr @return, __IntPtr x, __IntPtr y);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?pow@Gambit@@YA?AVInteger@1@AEBV21@J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Pow(__IntPtr @return, __IntPtr x, int y);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?Ipow@Gambit@@YA?AVInteger@1@JJ@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Ipow(__IntPtr @return, int x, int y);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?sqrt@Gambit@@YA?AVInteger@1@AEBV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Sqrt(__IntPtr @return, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?lcm@Gambit@@YA?AVInteger@1@AEBV21@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Lcm(__IntPtr @return, __IntPtr x, __IntPtr y);
            }

            public static global::gambit.Gambit.IntegerRep Ialloc(global::gambit.Gambit.IntegerRep _0, ref ushort _1, int _2, int _3, int _4)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                fixed (ushort* ___11 = &_1)
                {
                    var __arg1 = ___11;
                    var ___ret = __Internal.Ialloc(__arg0, __arg1, _2, _3, _4);
                    var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public static global::gambit.Gambit.IntegerRep Icalloc(global::gambit.Gambit.IntegerRep _0, int _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Icalloc(__arg0, _1);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Icopy_ulong(global::gambit.Gambit.IntegerRep _0, uint _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Icopy_ulong(__arg0, _1);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Icopy_long(global::gambit.Gambit.IntegerRep _0, int _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Icopy_long(__arg0, _1);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Icopy(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var ___ret = __Internal.Icopy(__arg0, __arg1);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Iresize(global::gambit.Gambit.IntegerRep _0, int _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Iresize(__arg0, _1);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Add(global::gambit.Gambit.IntegerRep _0, int _1, global::gambit.Gambit.IntegerRep _2, int _3, global::gambit.Gambit.IntegerRep _4)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var __arg4 = _4 is null ? __IntPtr.Zero : _4.__Instance;
                var ___ret = __Internal.Add(__arg0, _1, __arg2, _3, __arg4);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Add(global::gambit.Gambit.IntegerRep _0, int _1, int _2, global::gambit.Gambit.IntegerRep _3)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg3 = _3 is null ? __IntPtr.Zero : _3.__Instance;
                var ___ret = __Internal.Add(__arg0, _1, _2, __arg3);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Multiply(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1, global::gambit.Gambit.IntegerRep _2)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var ___ret = __Internal.Multiply(__arg0, __arg1, __arg2);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Multiply(global::gambit.Gambit.IntegerRep _0, int _1, global::gambit.Gambit.IntegerRep _2)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var ___ret = __Internal.Multiply(__arg0, _1, __arg2);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Lshift(global::gambit.Gambit.IntegerRep _0, int _1, global::gambit.Gambit.IntegerRep _2)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var ___ret = __Internal.Lshift(__arg0, _1, __arg2);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Lshift(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1, int _2, global::gambit.Gambit.IntegerRep _3)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var __arg3 = _3 is null ? __IntPtr.Zero : _3.__Instance;
                var ___ret = __Internal.Lshift(__arg0, __arg1, _2, __arg3);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Bitop(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1, global::gambit.Gambit.IntegerRep _2, char _3)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var __arg3 = global::System.Convert.ToSByte(_3);
                var ___ret = __Internal.Bitop(__arg0, __arg1, __arg2, __arg3);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Bitop(global::gambit.Gambit.IntegerRep _0, int _1, global::gambit.Gambit.IntegerRep _2, char _3)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var __arg3 = global::System.Convert.ToSByte(_3);
                var ___ret = __Internal.Bitop(__arg0, _1, __arg2, __arg3);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Power(global::gambit.Gambit.IntegerRep _0, int _1, global::gambit.Gambit.IntegerRep _2)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var ___ret = __Internal.Power(__arg0, _1, __arg2);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Div(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1, global::gambit.Gambit.IntegerRep _2)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var ___ret = __Internal.Div(__arg0, __arg1, __arg2);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Mod(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1, global::gambit.Gambit.IntegerRep _2)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var ___ret = __Internal.Mod(__arg0, __arg1, __arg2);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Div(global::gambit.Gambit.IntegerRep _0, int _1, global::gambit.Gambit.IntegerRep _2)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var ___ret = __Internal.Div(__arg0, _1, __arg2);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Mod(global::gambit.Gambit.IntegerRep _0, int _1, global::gambit.Gambit.IntegerRep _2)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var ___ret = __Internal.Mod(__arg0, _1, __arg2);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Compl(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var ___ret = __Internal.Compl(__arg0, __arg1);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Abs(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var ___ret = __Internal.Abs(__arg0, __arg1);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Negate(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var ___ret = __Internal.Negate(__arg0, __arg1);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Gcd(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep y)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = y is null ? __IntPtr.Zero : y.__Instance;
                var ___ret = __Internal.Gcd(__arg0, __arg1);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static int Compare(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var ___ret = __Internal.Compare(__arg0, __arg1);
                return ___ret;
            }

            public static int Compare(global::gambit.Gambit.IntegerRep _0, int _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Compare(__arg0, _1);
                return ___ret;
            }

            public static int Ucompare(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var ___ret = __Internal.Ucompare(__arg0, __arg1);
                return ___ret;
            }

            public static int Ucompare(global::gambit.Gambit.IntegerRep _0, int _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Ucompare(__arg0, _1);
                return ___ret;
            }

            public static string Itoa(global::gambit.Gambit.IntegerRep x, int @base = 10, int width = 0)
            {
                var __arg0 = x is null ? __IntPtr.Zero : x.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.Itoa(new IntPtr(&___ret), __arg0, @base, width);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            public static string CvtItoa(global::gambit.Gambit.IntegerRep x, string fmt, ref int fmtlen, int @base, int showbase, int width, int align_right, char fillchar, char Xcase, int showpos)
            {
                var __arg0 = x is null ? __IntPtr.Zero : x.__Instance;
                var __basicString1 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, fmt);
                var __arg1 = __basicString1.__Instance;
                fixed (int* __fmtlen2 = &fmtlen)
                {
                    var __arg2 = __fmtlen2;
                    var __arg7 = global::System.Convert.ToSByte(fillchar);
                    var __arg8 = global::System.Convert.ToSByte(Xcase);
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.CvtItoa(new IntPtr(&___ret), __arg0, __arg1, __arg2, @base, showbase, width, align_right, __arg7, __arg8, showpos);
                    __basicString1.Dispose(disposing: true, callNativeDtor:false);
                    var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }

            public static global::gambit.Gambit.IntegerRep AtoIntegerRep(string s, int @base = 10)
            {
                var ___ret = __Internal.AtoIntegerRep(s, @base);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static int Itolong(global::gambit.Gambit.IntegerRep _0)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Itolong(__arg0);
                return ___ret;
            }

            public static double Itodouble(global::gambit.Gambit.IntegerRep _0)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Itodouble(__arg0);
                return ___ret;
            }

            public static int Iislong(global::gambit.Gambit.IntegerRep _0)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Iislong(__arg0);
                return ___ret;
            }

            public static int Iisdouble(global::gambit.Gambit.IntegerRep _0)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Iisdouble(__arg0);
                return ___ret;
            }

            public static int Lg(global::gambit.Gambit.IntegerRep _0)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Lg(__arg0);
                return ___ret;
            }

            public static int Lg(global::gambit.Gambit.Integer _0)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = __Internal.Lg_1(__arg0);
                return ___ret;
            }

            public static double Ratio(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                var ___ret = __Internal.Ratio(__arg0, __arg1);
                return ___ret;
            }

            public static global::gambit.Gambit.Integer Gcd(global::gambit.Gambit.Integer _0, global::gambit.Gambit.Integer _1)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Gcd(new IntPtr(&___ret), __arg0, __arg1);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static int Even(global::gambit.Gambit.Integer _0)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = __Internal.Even(__arg0);
                return ___ret;
            }

            public static int Odd(global::gambit.Gambit.Integer _0)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = __Internal.Odd(__arg0);
                return ___ret;
            }

            public static int Sign(global::gambit.Gambit.Integer _0)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = __Internal.Sign(__arg0);
                return ___ret;
            }

            public static void Setbit(global::gambit.Gambit.Integer x, int b)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                __Internal.Setbit(__arg0, b);
            }

            public static void Clearbit(global::gambit.Gambit.Integer x, int b)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                __Internal.Clearbit(__arg0, b);
            }

            public static int Testbit(global::gambit.Gambit.Integer x, int b)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = __Internal.Testbit(__arg0, b);
                return ___ret;
            }

            public static void Abs(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = dest.__Instance;
                __Internal.Abs_1(__arg0, __arg1);
            }

            public static void Negate(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = dest.__Instance;
                __Internal.Negate_1(__arg0, __arg1);
            }

            public static void Complement(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = dest.__Instance;
                __Internal.Complement(__arg0, __arg1);
            }

            public static int Compare(global::gambit.Gambit.Integer _0, global::gambit.Gambit.Integer _1)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = __Internal.Compare_1(__arg0, __arg1);
                return ___ret;
            }

            public static int Ucompare(global::gambit.Gambit.Integer _0, global::gambit.Gambit.Integer _1)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = __Internal.Ucompare_1(__arg0, __arg1);
                return ___ret;
            }

            public static void Add(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Add(__arg0, __arg1, __arg2);
            }

            public static void Sub(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Sub(__arg0, __arg1, __arg2);
            }

            public static void Mul(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Mul(__arg0, __arg1, __arg2);
            }

            public static void Div(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Div_1(__arg0, __arg1, __arg2);
            }

            public static void Mod(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Mod_1(__arg0, __arg1, __arg2);
            }

            public static void Divide(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer q, global::gambit.Gambit.Integer r)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(q, null))
                    throw new global::System.ArgumentNullException("q", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = q.__Instance;
                if (ReferenceEquals(r, null))
                    throw new global::System.ArgumentNullException("r", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = r.__Instance;
                __Internal.Divide(__arg0, __arg1, __arg2, __arg3);
            }

            public static void Lshift(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Lshift(__arg0, __arg1, __arg2);
            }

            public static void Rshift(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Rshift(__arg0, __arg1, __arg2);
            }

            public static void Pow(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Pow(__arg0, __arg1, __arg2);
            }

            public static int Compare(global::gambit.Gambit.Integer _0, int _1)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = __Internal.Compare_1(__arg0, _1);
                return ___ret;
            }

            public static int Ucompare(global::gambit.Gambit.Integer _0, int _1)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = __Internal.Ucompare_1(__arg0, _1);
                return ___ret;
            }

            public static void Add(global::gambit.Gambit.Integer x, int y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Add(__arg0, y, __arg2);
            }

            public static void Sub(global::gambit.Gambit.Integer x, int y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Sub(__arg0, y, __arg2);
            }

            public static void Mul(global::gambit.Gambit.Integer x, int y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Mul(__arg0, y, __arg2);
            }

            public static void Div(global::gambit.Gambit.Integer x, int y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Div_1(__arg0, y, __arg2);
            }

            public static void Mod(global::gambit.Gambit.Integer x, int y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Mod_1(__arg0, y, __arg2);
            }

            public static void Divide(global::gambit.Gambit.Integer x, int y, global::gambit.Gambit.Integer q, ref int r)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(q, null))
                    throw new global::System.ArgumentNullException("q", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = q.__Instance;
                fixed (int* __r3 = &r)
                {
                    var __arg3 = __r3;
                    __Internal.Divide(__arg0, y, __arg2, __arg3);
                }
            }

            public static void Lshift(global::gambit.Gambit.Integer x, int y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Lshift_1(__arg0, y, __arg2);
            }

            public static void Rshift(global::gambit.Gambit.Integer x, int y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Rshift(__arg0, y, __arg2);
            }

            public static void Pow(global::gambit.Gambit.Integer x, int y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Pow(__arg0, y, __arg2);
            }

            public static int Compare(int _0, global::gambit.Gambit.Integer _1)
            {
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = __Internal.Compare(_0, __arg1);
                return ___ret;
            }

            public static int Ucompare(int _0, global::gambit.Gambit.Integer _1)
            {
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = __Internal.Ucompare(_0, __arg1);
                return ___ret;
            }

            public static void Add(int x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Add(x, __arg1, __arg2);
            }

            public static void Sub(int x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Sub(x, __arg1, __arg2);
            }

            public static void Mul(int x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Mul(x, __arg1, __arg2);
            }

            public static string Itoa(global::gambit.Gambit.Integer x, int @base, int width)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.Itoa_1(new IntPtr(&___ret), __arg0, @base, width);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            public static global::gambit.Gambit.Integer AtoI(string s, int @base)
            {
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.AtoI(new IntPtr(&___ret), s, @base);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Abs(global::gambit.Gambit.Integer _0)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Abs_2(new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Sqr(global::gambit.Gambit.Integer _0)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Sqr(new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Pow(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Pow_1(new IntPtr(&___ret), __arg0, __arg1);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Pow(global::gambit.Gambit.Integer x, int y)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Pow(new IntPtr(&___ret), __arg0, y);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Ipow(int x, int y)
            {
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Ipow(new IntPtr(&___ret), x, y);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Sqrt(global::gambit.Gambit.Integer _0)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Sqrt(new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Lcm(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Lcm(new IntPtr(&___ret), __arg0, __arg1);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }
        }
    }
}
