// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace gambit
{
    namespace Gambit
    {
        /// <summary>A base class for all Gambit exceptions</summary>
        public unsafe partial class Exception : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Exception> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Exception>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.Exception managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.Exception managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Exception __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Exception(native.ToPointer(), skipVTables);
            }

            internal static Exception __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Exception)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Exception __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Exception)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Exception __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Exception(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Exception(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Exception(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // ~Exception() noexcept override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.Exception.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class GameTreeInfosetRep
        {
            public partial struct __Internal
            {
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.GameTreeInfosetRep> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.GameTreeInfosetRep>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.GameTreeInfosetRep managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.GameTreeInfosetRep managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static GameTreeInfosetRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameTreeInfosetRep(native.ToPointer(), skipVTables);
            }

            internal static GameTreeInfosetRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameTreeInfosetRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static GameTreeInfosetRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameTreeInfosetRep(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GameTreeInfosetRep(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GameTreeInfosetRep(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }
        }

        public unsafe partial class GameTreeNodeRep
        {
            public partial struct __Internal
            {
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.GameTreeNodeRep> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.GameTreeNodeRep>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.GameTreeNodeRep managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.GameTreeNodeRep managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static GameTreeNodeRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameTreeNodeRep(native.ToPointer(), skipVTables);
            }

            internal static GameTreeNodeRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameTreeNodeRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static GameTreeNodeRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameTreeNodeRep(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GameTreeNodeRep(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GameTreeNodeRep(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }
        }

        /// <summary>Exception thrown on out-of-range index</summary>
        public unsafe partial class IndexException : global::gambit.Gambit.Exception, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;
            }

            internal static new IndexException __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new IndexException(native.ToPointer(), skipVTables);
            }

            internal static new IndexException __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (IndexException)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new IndexException __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (IndexException)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static IndexException __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new IndexException(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private IndexException(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected IndexException(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // ~IndexException() noexcept override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.IndexException.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Exception thrown on invalid index ranges</summary>
        public unsafe partial class RangeException : global::gambit.Gambit.Exception, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;
            }

            internal static new RangeException __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new RangeException(native.ToPointer(), skipVTables);
            }

            internal static new RangeException __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (RangeException)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new RangeException __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (RangeException)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static RangeException __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new RangeException(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private RangeException(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected RangeException(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // ~RangeException() noexcept override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.RangeException.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Exception thrown on dimension mismatches</summary>
        public unsafe partial class DimensionException : global::gambit.Gambit.Exception, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;
            }

            internal static new DimensionException __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new DimensionException(native.ToPointer(), skipVTables);
            }

            internal static new DimensionException __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (DimensionException)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new DimensionException __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (DimensionException)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static DimensionException __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new DimensionException(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private DimensionException(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected DimensionException(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // ~DimensionException() noexcept override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.DimensionException.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Exception thrown on invalid value</summary>
        public unsafe partial class ValueException : global::gambit.Gambit.Exception, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;
            }

            internal static new ValueException __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ValueException(native.ToPointer(), skipVTables);
            }

            internal static new ValueException __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ValueException)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ValueException __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ValueException)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ValueException __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ValueException(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ValueException(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ValueException(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // ~ValueException() noexcept override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.ValueException.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Exception thrown on a failed assertion</summary>
        public unsafe partial class AssertionException : global::gambit.Gambit.Exception, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;
            }

            internal static new AssertionException __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new AssertionException(native.ToPointer(), skipVTables);
            }

            internal static new AssertionException __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (AssertionException)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new AssertionException __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (AssertionException)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static AssertionException __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AssertionException(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private AssertionException(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected AssertionException(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // ~AssertionException() noexcept override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.AssertionException.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Exception thrown on attempted division by zero</summary>
        public unsafe partial class ZeroDivideException : global::gambit.Gambit.Exception, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;
            }

            internal static new ZeroDivideException __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ZeroDivideException(native.ToPointer(), skipVTables);
            }

            internal static new ZeroDivideException __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ZeroDivideException)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new ZeroDivideException __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (ZeroDivideException)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static ZeroDivideException __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ZeroDivideException(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ZeroDivideException(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ZeroDivideException(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // ~ZeroDivideException() noexcept override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.ZeroDivideException.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>An exception thrown when attempting to dereference a null pointer</summary>
        public unsafe partial class NullException : global::gambit.Gambit.Exception, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;
            }

            internal static new NullException __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new NullException(native.ToPointer(), skipVTables);
            }

            internal static new NullException __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (NullException)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new NullException __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (NullException)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static NullException __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new NullException(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private NullException(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected NullException(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // ~NullException() noexcept override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.NullException.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class gambit
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?abs@Gambit@@YANN@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern double Abs(double x);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?sqr@Gambit@@YANN@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern double Sqr(double x);
            }

            public static double Abs(double x)
            {
                var ___ret = __Internal.Abs(x);
                return ___ret;
            }

            public static double Sqr(double x)
            {
                var ___ret = __Internal.Sqr(x);
                return ___ret;
            }
        }
    }

    namespace Gambit
    {
        public unsafe partial class IntegerRep : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal ushort len;
                internal ushort sz;
                internal short sgn;
                internal fixed ushort s[1];

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "??0IntegerRep@Gambit@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.IntegerRep> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.IntegerRep>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.IntegerRep managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.IntegerRep managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static IntegerRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new IntegerRep(native.ToPointer(), skipVTables);
            }

            internal static IntegerRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (IntegerRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static IntegerRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new IntegerRep(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private IntegerRep(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected IntegerRep(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public IntegerRep()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.IntegerRep.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public IntegerRep(global::gambit.Gambit.IntegerRep _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.IntegerRep.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::gambit.Gambit.IntegerRep.__Internal*) __Instance) = *((global::gambit.Gambit.IntegerRep.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public ushort Len
            {
                get
                {
                    return ((__Internal*)__Instance)->len;
                }

                set
                {
                    ((__Internal*)__Instance)->len = value;
                }
            }

            public ushort Sz
            {
                get
                {
                    return ((__Internal*)__Instance)->sz;
                }

                set
                {
                    ((__Internal*)__Instance)->sz = value;
                }
            }

            public short Sgn
            {
                get
                {
                    return ((__Internal*)__Instance)->sgn;
                }

                set
                {
                    ((__Internal*)__Instance)->sgn = value;
                }
            }

            public ushort[] S
            {
                get
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<ushort>(((__Internal*)__Instance)->s, 1);
                }

                set
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 1; i++)
                            ((__Internal*)__Instance)->s[i] = value[i];
                    }
                }
            }
        }

        public unsafe partial class Integer : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr rep;

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "??1Integer@Gambit@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Integer> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Integer>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.Integer managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.Integer managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Integer __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Integer(native.ToPointer(), skipVTables);
            }

            internal static Integer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Integer)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Integer __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Integer(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Integer(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Integer(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            protected global::gambit.Gambit.IntegerRep Rep
            {
                get
                {
                    var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(((__Internal*)__Instance)->rep, false);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->rep = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }
        }

        public unsafe partial class integer
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?Ialloc@Gambit@@YAPEAUIntegerRep@1@PEAU21@PEBGHHH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Ialloc(__IntPtr _0, ushort* _1, int _2, int _3, int _4);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?Icalloc@Gambit@@YAPEAUIntegerRep@1@PEAU21@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Icalloc(__IntPtr _0, int _1);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?Icopy_ulong@Gambit@@YAPEAUIntegerRep@1@PEAU21@K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Icopy_ulong(__IntPtr _0, uint _1);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?Icopy_long@Gambit@@YAPEAUIntegerRep@1@PEAU21@J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Icopy_long(__IntPtr _0, int _1);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?Icopy@Gambit@@YAPEAUIntegerRep@1@PEAU21@PEBU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Icopy(__IntPtr _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?Iresize@Gambit@@YAPEAUIntegerRep@1@PEAU21@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Iresize(__IntPtr _0, int _1);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?add@Gambit@@YAPEAUIntegerRep@1@PEBU21@H0HPEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Add(__IntPtr _0, int _1, __IntPtr _2, int _3, __IntPtr _4);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?add@Gambit@@YAPEAUIntegerRep@1@PEBU21@HJPEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Add(__IntPtr _0, int _1, int _2, __IntPtr _3);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?multiply@Gambit@@YAPEAUIntegerRep@1@PEBU21@0PEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Multiply(__IntPtr _0, __IntPtr _1, __IntPtr _2);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?multiply@Gambit@@YAPEAUIntegerRep@1@PEBU21@JPEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Multiply(__IntPtr _0, int _1, __IntPtr _2);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?lshift@Gambit@@YAPEAUIntegerRep@1@PEBU21@JPEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Lshift(__IntPtr _0, int _1, __IntPtr _2);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?lshift@Gambit@@YAPEAUIntegerRep@1@PEBU21@0HPEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Lshift(__IntPtr _0, __IntPtr _1, int _2, __IntPtr _3);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?bitop@Gambit@@YAPEAUIntegerRep@1@PEBU21@0PEAU21@D@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bitop(__IntPtr _0, __IntPtr _1, __IntPtr _2, sbyte _3);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?bitop@Gambit@@YAPEAUIntegerRep@1@PEBU21@JPEAU21@D@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Bitop(__IntPtr _0, int _1, __IntPtr _2, sbyte _3);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?power@Gambit@@YAPEAUIntegerRep@1@PEBU21@JPEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Power(__IntPtr _0, int _1, __IntPtr _2);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?div@Gambit@@YAPEAUIntegerRep@1@PEBU21@0PEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Div(__IntPtr _0, __IntPtr _1, __IntPtr _2);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?mod@Gambit@@YAPEAUIntegerRep@1@PEBU21@0PEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Mod(__IntPtr _0, __IntPtr _1, __IntPtr _2);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?div@Gambit@@YAPEAUIntegerRep@1@PEBU21@JPEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Div(__IntPtr _0, int _1, __IntPtr _2);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?mod@Gambit@@YAPEAUIntegerRep@1@PEBU21@JPEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Mod(__IntPtr _0, int _1, __IntPtr _2);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?Compl@Gambit@@YAPEAUIntegerRep@1@PEBU21@PEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Compl(__IntPtr _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?abs@Gambit@@YAPEAUIntegerRep@1@PEBU21@PEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Abs(__IntPtr _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?negate@Gambit@@YAPEAUIntegerRep@1@PEBU21@PEAU21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Negate(__IntPtr _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?gcd@Gambit@@YAPEAUIntegerRep@1@PEBU21@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Gcd(__IntPtr _0, __IntPtr y);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?compare@Gambit@@YAHPEBUIntegerRep@1@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Compare(__IntPtr _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?compare@Gambit@@YAHPEBUIntegerRep@1@J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Compare(__IntPtr _0, int _1);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?ucompare@Gambit@@YAHPEBUIntegerRep@1@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Ucompare(__IntPtr _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?ucompare@Gambit@@YAHPEBUIntegerRep@1@J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Ucompare(__IntPtr _0, int _1);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?Itoa@Gambit@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBUIntegerRep@1@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Itoa(__IntPtr @return, __IntPtr x, int @base, int width);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?cvtItoa@Gambit@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBUIntegerRep@1@V23@AEAHHHHHDDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void CvtItoa(__IntPtr @return, __IntPtr x, __IntPtr fmt, int* fmtlen, int @base, int showbase, int width, int align_right, sbyte fillchar, sbyte Xcase, int showpos);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?atoIntegerRep@Gambit@@YAPEAUIntegerRep@1@PEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr AtoIntegerRep([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string s, int @base);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?Itolong@Gambit@@YAJPEBUIntegerRep@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Itolong(__IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?Itodouble@Gambit@@YANPEBUIntegerRep@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern double Itodouble(__IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?Iislong@Gambit@@YAHPEBUIntegerRep@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Iislong(__IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?Iisdouble@Gambit@@YAHPEBUIntegerRep@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Iisdouble(__IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?lg@Gambit@@YAJPEBUIntegerRep@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Lg(__IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?lg@Gambit@@YAJAEBVInteger@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Lg_1(__IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?ratio@Gambit@@YANAEBVInteger@1@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern double Ratio(__IntPtr x, __IntPtr y);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?gcd@Gambit@@YA?AVInteger@1@AEBV21@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Gcd(__IntPtr @return, __IntPtr _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?even@Gambit@@YAHAEBVInteger@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Even(__IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?odd@Gambit@@YAHAEBVInteger@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Odd(__IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?sign@Gambit@@YAHAEBVInteger@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Sign(__IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?setbit@Gambit@@YAXAEAVInteger@1@J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Setbit(__IntPtr x, int b);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?clearbit@Gambit@@YAXAEAVInteger@1@J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clearbit(__IntPtr x, int b);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?testbit@Gambit@@YAHAEBVInteger@1@J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Testbit(__IntPtr x, int b);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?abs@Gambit@@YAXAEBVInteger@1@AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Abs_1(__IntPtr x, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?negate@Gambit@@YAXAEBVInteger@1@AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Negate_1(__IntPtr x, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?complement@Gambit@@YAXAEBVInteger@1@AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Complement(__IntPtr x, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?compare@Gambit@@YAHAEBVInteger@1@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Compare_1(__IntPtr _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?ucompare@Gambit@@YAHAEBVInteger@1@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Ucompare_1(__IntPtr _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?add@Gambit@@YAXAEBVInteger@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Add(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?sub@Gambit@@YAXAEBVInteger@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Sub(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?mul@Gambit@@YAXAEBVInteger@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Mul(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?div@Gambit@@YAXAEBVInteger@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Div_1(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?mod@Gambit@@YAXAEBVInteger@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Mod_1(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?divide@Gambit@@YAXAEBVInteger@1@0AEAV21@1@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Divide(__IntPtr x, __IntPtr y, __IntPtr q, __IntPtr r);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?lshift@Gambit@@YAXAEBVInteger@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Lshift(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?rshift@Gambit@@YAXAEBVInteger@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Rshift(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?pow@Gambit@@YAXAEBVInteger@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Pow(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?compare@Gambit@@YAHAEBVInteger@1@J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Compare_1(__IntPtr _0, int _1);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?ucompare@Gambit@@YAHAEBVInteger@1@J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Ucompare_1(__IntPtr _0, int _1);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?add@Gambit@@YAXAEBVInteger@1@JAEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Add(__IntPtr x, int y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?sub@Gambit@@YAXAEBVInteger@1@JAEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Sub(__IntPtr x, int y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?mul@Gambit@@YAXAEBVInteger@1@JAEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Mul(__IntPtr x, int y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?div@Gambit@@YAXAEBVInteger@1@JAEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Div_1(__IntPtr x, int y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?mod@Gambit@@YAXAEBVInteger@1@JAEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Mod_1(__IntPtr x, int y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?divide@Gambit@@YAXAEBVInteger@1@JAEAV21@AEAJ@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Divide(__IntPtr x, int y, __IntPtr q, int* r);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?lshift@Gambit@@YAXAEBVInteger@1@JAEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Lshift_1(__IntPtr x, int y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?rshift@Gambit@@YAXAEBVInteger@1@JAEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Rshift(__IntPtr x, int y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?pow@Gambit@@YAXAEBVInteger@1@JAEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Pow(__IntPtr x, int y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?compare@Gambit@@YAHJAEBVInteger@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Compare(int _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?ucompare@Gambit@@YAHJAEBVInteger@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Ucompare(int _0, __IntPtr _1);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?add@Gambit@@YAXJAEBVInteger@1@AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Add(int x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?sub@Gambit@@YAXJAEBVInteger@1@AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Sub(int x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?mul@Gambit@@YAXJAEBVInteger@1@AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Mul(int x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?Itoa@Gambit@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVInteger@1@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Itoa_1(__IntPtr @return, __IntPtr x, int @base, int width);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?atoI@Gambit@@YA?AVInteger@1@PEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AtoI(__IntPtr @return, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string s, int @base);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?abs@Gambit@@YA?AVInteger@1@AEBV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Abs_2(__IntPtr @return, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?sqr@Gambit@@YA?AVInteger@1@AEBV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Sqr(__IntPtr @return, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?pow@Gambit@@YA?AVInteger@1@AEBV21@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Pow_1(__IntPtr @return, __IntPtr x, __IntPtr y);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?pow@Gambit@@YA?AVInteger@1@AEBV21@J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Pow(__IntPtr @return, __IntPtr x, int y);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?Ipow@Gambit@@YA?AVInteger@1@JJ@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Ipow(__IntPtr @return, int x, int y);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?sqrt@Gambit@@YA?AVInteger@1@AEBV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Sqrt(__IntPtr @return, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?lcm@Gambit@@YA?AVInteger@1@AEBV21@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Lcm(__IntPtr @return, __IntPtr x, __IntPtr y);
            }

            public static global::gambit.Gambit.IntegerRep Ialloc(global::gambit.Gambit.IntegerRep _0, ref ushort _1, int _2, int _3, int _4)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                fixed (ushort* ___11 = &_1)
                {
                    var __arg1 = ___11;
                    var ___ret = __Internal.Ialloc(__arg0, __arg1, _2, _3, _4);
                    var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public static global::gambit.Gambit.IntegerRep Icalloc(global::gambit.Gambit.IntegerRep _0, int _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Icalloc(__arg0, _1);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Icopy_ulong(global::gambit.Gambit.IntegerRep _0, uint _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Icopy_ulong(__arg0, _1);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Icopy_long(global::gambit.Gambit.IntegerRep _0, int _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Icopy_long(__arg0, _1);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Icopy(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var ___ret = __Internal.Icopy(__arg0, __arg1);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Iresize(global::gambit.Gambit.IntegerRep _0, int _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Iresize(__arg0, _1);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Add(global::gambit.Gambit.IntegerRep _0, int _1, global::gambit.Gambit.IntegerRep _2, int _3, global::gambit.Gambit.IntegerRep _4)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var __arg4 = _4 is null ? __IntPtr.Zero : _4.__Instance;
                var ___ret = __Internal.Add(__arg0, _1, __arg2, _3, __arg4);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Add(global::gambit.Gambit.IntegerRep _0, int _1, int _2, global::gambit.Gambit.IntegerRep _3)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg3 = _3 is null ? __IntPtr.Zero : _3.__Instance;
                var ___ret = __Internal.Add(__arg0, _1, _2, __arg3);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Multiply(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1, global::gambit.Gambit.IntegerRep _2)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var ___ret = __Internal.Multiply(__arg0, __arg1, __arg2);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Multiply(global::gambit.Gambit.IntegerRep _0, int _1, global::gambit.Gambit.IntegerRep _2)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var ___ret = __Internal.Multiply(__arg0, _1, __arg2);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Lshift(global::gambit.Gambit.IntegerRep _0, int _1, global::gambit.Gambit.IntegerRep _2)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var ___ret = __Internal.Lshift(__arg0, _1, __arg2);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Lshift(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1, int _2, global::gambit.Gambit.IntegerRep _3)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var __arg3 = _3 is null ? __IntPtr.Zero : _3.__Instance;
                var ___ret = __Internal.Lshift(__arg0, __arg1, _2, __arg3);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Bitop(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1, global::gambit.Gambit.IntegerRep _2, char _3)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var __arg3 = global::System.Convert.ToSByte(_3);
                var ___ret = __Internal.Bitop(__arg0, __arg1, __arg2, __arg3);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Bitop(global::gambit.Gambit.IntegerRep _0, int _1, global::gambit.Gambit.IntegerRep _2, char _3)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var __arg3 = global::System.Convert.ToSByte(_3);
                var ___ret = __Internal.Bitop(__arg0, _1, __arg2, __arg3);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Power(global::gambit.Gambit.IntegerRep _0, int _1, global::gambit.Gambit.IntegerRep _2)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var ___ret = __Internal.Power(__arg0, _1, __arg2);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Div(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1, global::gambit.Gambit.IntegerRep _2)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var ___ret = __Internal.Div(__arg0, __arg1, __arg2);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Mod(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1, global::gambit.Gambit.IntegerRep _2)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var ___ret = __Internal.Mod(__arg0, __arg1, __arg2);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Div(global::gambit.Gambit.IntegerRep _0, int _1, global::gambit.Gambit.IntegerRep _2)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var ___ret = __Internal.Div(__arg0, _1, __arg2);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Mod(global::gambit.Gambit.IntegerRep _0, int _1, global::gambit.Gambit.IntegerRep _2)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
                var ___ret = __Internal.Mod(__arg0, _1, __arg2);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Compl(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var ___ret = __Internal.Compl(__arg0, __arg1);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Abs(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var ___ret = __Internal.Abs(__arg0, __arg1);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Negate(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var ___ret = __Internal.Negate(__arg0, __arg1);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::gambit.Gambit.IntegerRep Gcd(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep y)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = y is null ? __IntPtr.Zero : y.__Instance;
                var ___ret = __Internal.Gcd(__arg0, __arg1);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static int Compare(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var ___ret = __Internal.Compare(__arg0, __arg1);
                return ___ret;
            }

            public static int Compare(global::gambit.Gambit.IntegerRep _0, int _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Compare(__arg0, _1);
                return ___ret;
            }

            public static int Ucompare(global::gambit.Gambit.IntegerRep _0, global::gambit.Gambit.IntegerRep _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var __arg1 = _1 is null ? __IntPtr.Zero : _1.__Instance;
                var ___ret = __Internal.Ucompare(__arg0, __arg1);
                return ___ret;
            }

            public static int Ucompare(global::gambit.Gambit.IntegerRep _0, int _1)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Ucompare(__arg0, _1);
                return ___ret;
            }

            public static string Itoa(global::gambit.Gambit.IntegerRep x, int @base, int width)
            {
                var __arg0 = x is null ? __IntPtr.Zero : x.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.Itoa(new IntPtr(&___ret), __arg0, @base, width);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            public static string CvtItoa(global::gambit.Gambit.IntegerRep x, string fmt, ref int fmtlen, int @base, int showbase, int width, int align_right, char fillchar, char Xcase, int showpos)
            {
                var __arg0 = x is null ? __IntPtr.Zero : x.__Instance;
                var __basicString1 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, fmt);
                var __arg1 = __basicString1.__Instance;
                fixed (int* __fmtlen2 = &fmtlen)
                {
                    var __arg2 = __fmtlen2;
                    var __arg7 = global::System.Convert.ToSByte(fillchar);
                    var __arg8 = global::System.Convert.ToSByte(Xcase);
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.CvtItoa(new IntPtr(&___ret), __arg0, __arg1, __arg2, @base, showbase, width, align_right, __arg7, __arg8, showpos);
                    __basicString1.Dispose(disposing: true, callNativeDtor:false);
                    var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }

            public static global::gambit.Gambit.IntegerRep AtoIntegerRep(string s, int @base)
            {
                var ___ret = __Internal.AtoIntegerRep(s, @base);
                var __result0 = global::gambit.Gambit.IntegerRep.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static int Itolong(global::gambit.Gambit.IntegerRep _0)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Itolong(__arg0);
                return ___ret;
            }

            public static double Itodouble(global::gambit.Gambit.IntegerRep _0)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Itodouble(__arg0);
                return ___ret;
            }

            public static int Iislong(global::gambit.Gambit.IntegerRep _0)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Iislong(__arg0);
                return ___ret;
            }

            public static int Iisdouble(global::gambit.Gambit.IntegerRep _0)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Iisdouble(__arg0);
                return ___ret;
            }

            public static int Lg(global::gambit.Gambit.IntegerRep _0)
            {
                var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
                var ___ret = __Internal.Lg(__arg0);
                return ___ret;
            }

            public static int Lg(global::gambit.Gambit.Integer _0)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = __Internal.Lg_1(__arg0);
                return ___ret;
            }

            public static double Ratio(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                var ___ret = __Internal.Ratio(__arg0, __arg1);
                return ___ret;
            }

            public static global::gambit.Gambit.Integer Gcd(global::gambit.Gambit.Integer _0, global::gambit.Gambit.Integer _1)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Gcd(new IntPtr(&___ret), __arg0, __arg1);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static int Even(global::gambit.Gambit.Integer _0)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = __Internal.Even(__arg0);
                return ___ret;
            }

            public static int Odd(global::gambit.Gambit.Integer _0)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = __Internal.Odd(__arg0);
                return ___ret;
            }

            public static int Sign(global::gambit.Gambit.Integer _0)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = __Internal.Sign(__arg0);
                return ___ret;
            }

            public static void Setbit(global::gambit.Gambit.Integer x, int b)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                __Internal.Setbit(__arg0, b);
            }

            public static void Clearbit(global::gambit.Gambit.Integer x, int b)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                __Internal.Clearbit(__arg0, b);
            }

            public static int Testbit(global::gambit.Gambit.Integer x, int b)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = __Internal.Testbit(__arg0, b);
                return ___ret;
            }

            public static void Abs(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = dest.__Instance;
                __Internal.Abs_1(__arg0, __arg1);
            }

            public static void Negate(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = dest.__Instance;
                __Internal.Negate_1(__arg0, __arg1);
            }

            public static void Complement(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = dest.__Instance;
                __Internal.Complement(__arg0, __arg1);
            }

            public static int Compare(global::gambit.Gambit.Integer _0, global::gambit.Gambit.Integer _1)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = __Internal.Compare_1(__arg0, __arg1);
                return ___ret;
            }

            public static int Ucompare(global::gambit.Gambit.Integer _0, global::gambit.Gambit.Integer _1)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = __Internal.Ucompare_1(__arg0, __arg1);
                return ___ret;
            }

            public static void Add(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Add(__arg0, __arg1, __arg2);
            }

            public static void Sub(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Sub(__arg0, __arg1, __arg2);
            }

            public static void Mul(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Mul(__arg0, __arg1, __arg2);
            }

            public static void Div(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Div_1(__arg0, __arg1, __arg2);
            }

            public static void Mod(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Mod_1(__arg0, __arg1, __arg2);
            }

            public static void Divide(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer q, global::gambit.Gambit.Integer r)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(q, null))
                    throw new global::System.ArgumentNullException("q", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = q.__Instance;
                if (ReferenceEquals(r, null))
                    throw new global::System.ArgumentNullException("r", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = r.__Instance;
                __Internal.Divide(__arg0, __arg1, __arg2, __arg3);
            }

            public static void Lshift(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Lshift(__arg0, __arg1, __arg2);
            }

            public static void Rshift(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Rshift(__arg0, __arg1, __arg2);
            }

            public static void Pow(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Pow(__arg0, __arg1, __arg2);
            }

            public static int Compare(global::gambit.Gambit.Integer _0, int _1)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = __Internal.Compare_1(__arg0, _1);
                return ___ret;
            }

            public static int Ucompare(global::gambit.Gambit.Integer _0, int _1)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = __Internal.Ucompare_1(__arg0, _1);
                return ___ret;
            }

            public static void Add(global::gambit.Gambit.Integer x, int y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Add(__arg0, y, __arg2);
            }

            public static void Sub(global::gambit.Gambit.Integer x, int y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Sub(__arg0, y, __arg2);
            }

            public static void Mul(global::gambit.Gambit.Integer x, int y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Mul(__arg0, y, __arg2);
            }

            public static void Div(global::gambit.Gambit.Integer x, int y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Div_1(__arg0, y, __arg2);
            }

            public static void Mod(global::gambit.Gambit.Integer x, int y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Mod_1(__arg0, y, __arg2);
            }

            public static void Divide(global::gambit.Gambit.Integer x, int y, global::gambit.Gambit.Integer q, ref int r)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(q, null))
                    throw new global::System.ArgumentNullException("q", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = q.__Instance;
                fixed (int* __r3 = &r)
                {
                    var __arg3 = __r3;
                    __Internal.Divide(__arg0, y, __arg2, __arg3);
                }
            }

            public static void Lshift(global::gambit.Gambit.Integer x, int y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Lshift_1(__arg0, y, __arg2);
            }

            public static void Rshift(global::gambit.Gambit.Integer x, int y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Rshift(__arg0, y, __arg2);
            }

            public static void Pow(global::gambit.Gambit.Integer x, int y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Pow(__arg0, y, __arg2);
            }

            public static int Compare(int _0, global::gambit.Gambit.Integer _1)
            {
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = __Internal.Compare(_0, __arg1);
                return ___ret;
            }

            public static int Ucompare(int _0, global::gambit.Gambit.Integer _1)
            {
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = __Internal.Ucompare(_0, __arg1);
                return ___ret;
            }

            public static void Add(int x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Add(x, __arg1, __arg2);
            }

            public static void Sub(int x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Sub(x, __arg1, __arg2);
            }

            public static void Mul(int x, global::gambit.Gambit.Integer y, global::gambit.Gambit.Integer dest)
            {
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Mul(x, __arg1, __arg2);
            }

            public static string Itoa(global::gambit.Gambit.Integer x, int @base, int width)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.Itoa_1(new IntPtr(&___ret), __arg0, @base, width);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            public static global::gambit.Gambit.Integer AtoI(string s, int @base)
            {
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.AtoI(new IntPtr(&___ret), s, @base);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Abs(global::gambit.Gambit.Integer _0)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Abs_2(new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Sqr(global::gambit.Gambit.Integer _0)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Sqr(new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Pow(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Pow_1(new IntPtr(&___ret), __arg0, __arg1);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Pow(global::gambit.Gambit.Integer x, int y)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Pow(new IntPtr(&___ret), __arg0, y);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Ipow(int x, int y)
            {
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Ipow(new IntPtr(&___ret), x, y);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Sqrt(global::gambit.Gambit.Integer _0)
            {
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Sqrt(new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Lcm(global::gambit.Gambit.Integer x, global::gambit.Gambit.Integer y)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Lcm(new IntPtr(&___ret), __arg0, __arg1);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }
        }
    }

    namespace Gambit
    {
        namespace Array
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public unsafe partial struct __Internal
            {
                internal __IntPtr vfptr_Array;
                internal int mindex;
                internal int maxdex;
                internal __IntPtr data;
            }

            namespace Iterator
            {
                [StructLayout(LayoutKind.Sequential, Size = 16)]
                public unsafe partial struct __Internal
                {
                    internal __IntPtr m_array;
                    internal int m_index;
                }
            }

        }

        /// <summary>A basic bounds-checked array</summary>
        public unsafe partial class Array<T> : IDisposable
        {
            public unsafe partial class Iterator : IDisposable
            {
                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Array<T>.Iterator> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Array<T>.Iterator>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.Array<T>.Iterator managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.Array<T>.Iterator managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static Iterator __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new Iterator(native.ToPointer(), skipVTables);
                }

                internal static Iterator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (Iterator)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                protected Iterator(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public Iterator(global::gambit.Gambit.Array<T> p_array, int p_index)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.Array<T>.Iterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public static global::gambit.Gambit.Array<T>.Iterator operator ++(global::gambit.Gambit.Array<T>.Iterator __op)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.Array<T>.Iterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public static bool operator ==(global::gambit.Gambit.Array<T>.Iterator __op, global::gambit.Gambit.Array<T>.Iterator it)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.Array<T>.Iterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public override bool Equals(object obj)
                {
                    return this == obj as global::gambit.Gambit.Array<T>.Iterator;
                }

                public override int GetHashCode()
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.Array<T>.Iterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public static bool operator !=(global::gambit.Gambit.Array<T>.Iterator __op, global::gambit.Gambit.Array<T>.Iterator it)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.Array<T>.Iterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }
            }

            public unsafe partial class ConstIterator : IDisposable
            {
                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Array<T>.ConstIterator> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Array<T>.ConstIterator>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.Array<T>.ConstIterator managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.Array<T>.ConstIterator managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static ConstIterator __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new ConstIterator(native.ToPointer(), skipVTables);
                }

                internal static ConstIterator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (ConstIterator)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                protected ConstIterator(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public ConstIterator(global::gambit.Gambit.Array<T> p_array, int p_index)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.Array<T>.ConstIterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public static global::gambit.Gambit.Array<T>.ConstIterator operator ++(global::gambit.Gambit.Array<T>.ConstIterator __op)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.Array<T>.ConstIterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public static bool operator ==(global::gambit.Gambit.Array<T>.ConstIterator __op, global::gambit.Gambit.Array<T>.ConstIterator it)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.Array<T>.ConstIterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public override bool Equals(object obj)
                {
                    return this == obj as global::gambit.Gambit.Array<T>.ConstIterator;
                }

                public override int GetHashCode()
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.Array<T>.ConstIterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public static bool operator !=(global::gambit.Gambit.Array<T>.ConstIterator __op, global::gambit.Gambit.Array<T>.ConstIterator it)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.Array<T>.ConstIterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Array<T>> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Array<T>>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.Array<T> managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.Array<T> managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Array<T> __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Array<T>(native.ToPointer(), skipVTables);
            }

            internal static Array<T> __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Array<T>)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Array<T> __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Array<T>)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Array<T> __CreateInstance(global::gambit.Gambit.Array.__Internal native, bool skipVTables = false)
            {
                return new Array<T>(native, skipVTables);
            }

            private static void* __CopyValue(global::gambit.Gambit.Array.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.Array.__Internal));
                *(global::gambit.Gambit.Array.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Array(global::gambit.Gambit.Array.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Array(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            /// <summary>Constructs an array of length 'len', starting at '1'</summary>
            public Array(uint len)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<bool>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
            }

            /// <summary>Constructs an array starting at lo and ending at hi</summary>
            public Array(int lo, int hi)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<bool>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
            }

            /// <summary>Copy the contents of another array</summary>
            public Array(global::gambit.Gambit.Array<T> a)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<bool>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Test the equality of two arrays</summary>
            public static bool operator ==(global::gambit.Gambit.Array<T> __op, global::gambit.Gambit.Array<T> a)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<bool>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::gambit.Gambit.Array<T>;
            }

            public override int GetHashCode()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
            }

            /// <summary>Test the inequality of two arrays</summary>
            public static bool operator !=(global::gambit.Gambit.Array<T> __op, global::gambit.Gambit.Array<T> a)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<bool>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
            }

            /// <summary>Return a forward iterator starting at the beginning of the array</summary>
            public global::gambit.Gambit.Array<T>.Iterator Begin()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<bool>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
            }

            /// <summary>Return a forward iterator past the end of the array</summary>
            public global::gambit.Gambit.Array<T>.Iterator End()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<bool>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
            }

            /// <summary>Remove an element from the array.</summary>
            /// <remarks>
            /// <para>Remove the element at a given index from the array.  Returns the value</para>
            /// <para>of the element removed.</para>
            /// </remarks>
            public T Remove(int n)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<bool>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
            }

            /// <summary>
            /// <para>Removes all elements from the array container (which are destroyed),</para>
            /// <para>leaving the container with a size of 0.</para>
            /// </summary>
            public void Clear()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<bool>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
            }

            public static explicit operator global::gambit.Gambit.Array<T>(uint len)
            {
                return new global::gambit.Gambit.Array<T>(len);
            }

            public T this[int index]
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<int>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<bool>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<int>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<bool>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            protected int Mindex
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            protected int Maxdex
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            protected T Data
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        return (T) (object) ((global::gambit.Gambit.Array.__Internal*)__Instance)->data;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(((global::gambit.Gambit.Array.__Internal*)__Instance)->data, false);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.__GetOrCreateInstance(((global::gambit.Gambit.Array.__Internal*)__Instance)->data, false);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__GetOrCreateInstance(((global::gambit.Gambit.Array.__Internal*)__Instance)->data, false);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__GetOrCreateInstance(((global::gambit.Gambit.Array.__Internal*)__Instance)->data, false);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        var __result0 = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.__GetOrCreateInstance(((global::gambit.Gambit.Array.__Internal*)__Instance)->data, true);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__GetOrCreateInstance(((global::gambit.Gambit.Array.__Internal*)__Instance)->data, false);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        var __result0 = global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.__GetOrCreateInstance(((global::gambit.Gambit.Array.__Internal*)__Instance)->data, true);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        var __result0 = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.__GetOrCreateInstance(((global::gambit.Gambit.Array.__Internal*)__Instance)->data, true);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        var __result0 = global::gambit.Gambit.Number.__GetOrCreateInstance(((global::gambit.Gambit.Array.__Internal*)__Instance)->data, false);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        return (T) (object) ((global::gambit.Gambit.Array.__Internal*)__Instance)->data;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        var __value0 = (int) (object) value;
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = (__IntPtr) (object) __value0;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = ((global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = ((global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = ((global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = ((global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = ((global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = ((global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = ((global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = ((global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = ((global::gambit.Gambit.Number) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.Number) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        var __value0 = (bool) (object) (byte) (value ? 1 : 0);
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = (__IntPtr) (object) __value0;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            /// <summary>Return the length of the array</summary>
            public int Length
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<int>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<bool>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            /// <summary>Return the first index</summary>
            public int First
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<int>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<bool>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            /// <summary>Return the last index</summary>
            public int Last
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<int>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<bool>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            /// <summary>Return a const forward iterator starting at the beginning of the array</summary>
            public global::gambit.Gambit.Array<T>.ConstIterator Cbegin
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<int>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<bool>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            /// <summary>Return a const forward iterator past the end of the array</summary>
            public global::gambit.Gambit.Array<T>.ConstIterator Cend
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<int>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<bool>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            /// <summary>
            /// <para>These operations are a partial implementation of operations on</para>
            /// <para>STL-style list containers.  It is suggested that future code be</para>
            /// <para>written to use these, and existing code ported to use them as</para>
            /// <para>possible.</para>
            /// <para>@{</para>
            /// <para>Return whether the array container is empty (has size 0).</para>
            /// </summary>
            public bool Empty
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<int>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<bool>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            /// <summary>Return the number of elements in the array container.</summary>
            public ulong Size
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<int>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<bool>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            #region Virtual table interop

            // virtual ~Array()
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.Array<T>.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe static partial class ArrayExtensions
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?front@?$Array@H@Gambit@@QEAAAEAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int* Front(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?back@?$Array@H@Gambit@@QEAAAEAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int* Back(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?front@?$Array@V?$GameObjectPtr@VGameInfosetRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGameInfosetRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Front_1(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?back@?$Array@V?$GameObjectPtr@VGameInfosetRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGameInfosetRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Back_1(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?front@?$Array@V?$GameObjectPtr@VGameStrategyRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGameStrategyRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Front_2(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?back@?$Array@V?$GameObjectPtr@VGameStrategyRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGameStrategyRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Back_2(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?front@?$Array@V?$GameObjectPtr@VGameNodeRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGameNodeRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Front_3(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?back@?$Array@V?$GameObjectPtr@VGameNodeRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGameNodeRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Back_3(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?front@?$Array@V?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGameActionRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Front_4(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?back@?$Array@V?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGameActionRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Back_4(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?front@?$Array@V?$Array@V?$GameObjectPtr@VGameStrategyRep@Gambit@@@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$Array@V?$GameObjectPtr@VGameStrategyRep@Gambit@@@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Front_5(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?back@?$Array@V?$Array@V?$GameObjectPtr@VGameStrategyRep@Gambit@@@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$Array@V?$GameObjectPtr@VGameStrategyRep@Gambit@@@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Back_5(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?front@?$Array@V?$GameObjectPtr@VGamePlayerRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGamePlayerRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Front_6(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?back@?$Array@V?$GameObjectPtr@VGamePlayerRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGamePlayerRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Back_6(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?front@?$Array@V?$Array@V?$Array@V?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$Array@V?$Array@V?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Front_7(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?back@?$Array@V?$Array@V?$Array@V?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$Array@V?$Array@V?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Back_7(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?front@?$Array@V?$Array@V?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$Array@V?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Front_8(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?back@?$Array@V?$Array@V?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$Array@V?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Back_8(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?front@?$Array@VNumber@Gambit@@@Gambit@@QEAAAEAVNumber@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Front_9(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?back@?$Array@VNumber@Gambit@@@Gambit@@QEAAAEAVNumber@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Back_9(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?front@?$Array@_N@Gambit@@QEAAAEA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern bool* Front_10(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?back@?$Array@_N@Gambit@@QEAAAEA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern bool* Back_10(__IntPtr __instance);
            }

            /// <summary>Access first element.</summary>
            public static int* Front(this global::gambit.Gambit.Array<int> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front(__arg0);
                return ___ret;
            }

            /// <summary>Access last element.</summary>
            public static int* Back(this global::gambit.Gambit.Array<int> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back(__arg0);
                return ___ret;
            }

            /// <summary>Access first element.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> Front(this global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front_1(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access last element.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> Back(this global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back_1(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access first element.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> Front(this global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front_2(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access last element.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> Back(this global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back_2(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access first element.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> Front(this global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front_3(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access last element.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> Back(this global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back_3(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access first element.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> Front(this global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front_4(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access last element.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> Back(this global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back_4(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access first element.</summary>
            public static global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>> Front(this global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front_5(__arg0);
                var __result0 = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Access last element.</summary>
            public static global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>> Back(this global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back_5(__arg0);
                var __result0 = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Access first element.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> Front(this global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front_6(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access last element.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> Back(this global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back_6(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access first element.</summary>
            public static global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>> Front(this global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front_7(__arg0);
                var __result0 = global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Access last element.</summary>
            public static global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>> Back(this global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back_7(__arg0);
                var __result0 = global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Access first element.</summary>
            public static global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>> Front(this global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front_8(__arg0);
                var __result0 = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Access last element.</summary>
            public static global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>> Back(this global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back_8(__arg0);
                var __result0 = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Access first element.</summary>
            public static global::gambit.Gambit.Number Front(this global::gambit.Gambit.Array<global::gambit.Gambit.Number> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front_9(__arg0);
                var __result0 = global::gambit.Gambit.Number.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access last element.</summary>
            public static global::gambit.Gambit.Number Back(this global::gambit.Gambit.Array<global::gambit.Gambit.Number> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back_9(__arg0);
                var __result0 = global::gambit.Gambit.Number.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access first element.</summary>
            public static bool* Front(this global::gambit.Gambit.Array<bool> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front_10(__arg0);
                return ___ret;
            }

            /// <summary>Access last element.</summary>
            public static bool* Back(this global::gambit.Gambit.Array<bool> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back_10(__arg0);
                return ___ret;
            }
        }
    }

    namespace Gambit
    {
        namespace List
        {
            [StructLayout(LayoutKind.Sequential, Size = 48)]
            public unsafe partial struct __Internal
            {
                internal __IntPtr vfptr_List;
                internal int m_length;
                internal __IntPtr m_head;
                internal __IntPtr m_tail;
                internal int m_currentIndex;
                internal __IntPtr m_currentNode;
            }
        }

        /// <summary>A doubly-linked list container.</summary>
        /// <remarks>
        /// <para>This implements a doubly-linked list.  A special feature of this</para>
        /// <para>class is that it caches the last item accessed by indexing via</para>
        /// <para>operator[], meaning that, if accesses are done in sequential order,</para>
        /// <para>indexing time is constant.</para>
        /// <para>This index-cacheing feature was implemented very early in the development</para>
        /// <para>of Gambit, before STL-like concepts of iterators had been fully</para>
        /// <para>developed.  An iterator approach is a better and more robust solution</para>
        /// <para>to iterating lists, both in terms of performance and encapsulation.</para>
        /// <para>Therefore, it is recommended to avoid operator[] and use the provided</para>
        /// <para>iterator classes in new code, and to upgrade existing code to the</para>
        /// <para>iterator idiom as practical.</para>
        /// </remarks>
        public unsafe partial class List<T> : IDisposable
        {
            public unsafe partial class Node : IDisposable
            {
                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.List<T>.Node> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.List<T>.Node>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.List<T>.Node managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.List<T>.Node managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static Node __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new Node(native.ToPointer(), skipVTables);
                }

                internal static Node __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (Node)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                protected Node(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public T MData
                {
                    get
                    {
                        throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.List<T>.Node maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                    }

                    set
                    {
                        throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.List<T>.Node maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                    }
                }

                public global::gambit.Gambit.List<T>.Node MPrev
                {
                    get
                    {
                        throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.List<T>.Node maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                    }

                    set
                    {
                        throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.List<T>.Node maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                    }
                }

                public global::gambit.Gambit.List<T>.Node MNext
                {
                    get
                    {
                        throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.List<T>.Node maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                    }

                    set
                    {
                        throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.List<T>.Node maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                    }
                }
            }

            public unsafe partial class Iterator : IDisposable
            {
                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.List<T>.Iterator> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.List<T>.Iterator>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.List<T>.Iterator managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.List<T>.Iterator managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static Iterator __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new Iterator(native.ToPointer(), skipVTables);
                }

                internal static Iterator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (Iterator)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                protected Iterator(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public Iterator(global::gambit.Gambit.List<T> p_list, global::gambit.Gambit.List<T>.Node p_node)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.List<T>.Iterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public static global::gambit.Gambit.List<T>.Iterator operator ++(global::gambit.Gambit.List<T>.Iterator __op)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.List<T>.Iterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public static bool operator ==(global::gambit.Gambit.List<T>.Iterator __op, global::gambit.Gambit.List<T>.Iterator it)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.List<T>.Iterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public override bool Equals(object obj)
                {
                    return this == obj as global::gambit.Gambit.List<T>.Iterator;
                }

                public override int GetHashCode()
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.List<T>.Iterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public static bool operator !=(global::gambit.Gambit.List<T>.Iterator __op, global::gambit.Gambit.List<T>.Iterator it)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.List<T>.Iterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }
            }

            public unsafe partial class ConstIterator : IDisposable
            {
                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.List<T>.ConstIterator> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.List<T>.ConstIterator>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.List<T>.ConstIterator managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.List<T>.ConstIterator managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static ConstIterator __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new ConstIterator(native.ToPointer(), skipVTables);
                }

                internal static ConstIterator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (ConstIterator)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                protected ConstIterator(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public ConstIterator(global::gambit.Gambit.List<T> p_list, global::gambit.Gambit.List<T>.Node p_node)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.List<T>.ConstIterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public static global::gambit.Gambit.List<T>.ConstIterator operator ++(global::gambit.Gambit.List<T>.ConstIterator __op)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.List<T>.ConstIterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public static bool operator ==(global::gambit.Gambit.List<T>.ConstIterator __op, global::gambit.Gambit.List<T>.ConstIterator it)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.List<T>.ConstIterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public override bool Equals(object obj)
                {
                    return this == obj as global::gambit.Gambit.List<T>.ConstIterator;
                }

                public override int GetHashCode()
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.List<T>.ConstIterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public static bool operator !=(global::gambit.Gambit.List<T>.ConstIterator __op, global::gambit.Gambit.List<T>.ConstIterator it)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.List<T>.ConstIterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.List<T>> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.List<T>>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.List<T> managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.List<T> managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static List<T> __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new List<T>(native.ToPointer(), skipVTables);
            }

            internal static List<T> __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (List<T>)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static List<T> __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (List<T>)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static List<T> __CreateInstance(global::gambit.Gambit.List.__Internal native, bool skipVTables = false)
            {
                return new List<T>(native, skipVTables);
            }

            private static void* __CopyValue(global::gambit.Gambit.List.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.List.__Internal));
                *(global::gambit.Gambit.List.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private List(global::gambit.Gambit.List.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected List(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            public List()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method List_T_ ignored in specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method List_T_ ignored in specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
            }

            public List(global::gambit.Gambit.List<T> _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method List_T_ ignored in specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method List_T_ ignored in specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static bool operator ==(global::gambit.Gambit.List<T> __op, global::gambit.Gambit.List<T> b)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::gambit.Gambit.List<T>;
            }

            public override int GetHashCode()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.List.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.List.__Internal*) __Instance).GetHashCode();
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
            }

            public static bool operator !=(global::gambit.Gambit.List<T> __op, global::gambit.Gambit.List<T> b)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
            }

            /// <summary>Return a forward iterator starting at the beginning of the list</summary>
            public global::gambit.Gambit.List<T>.Iterator Begin()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
            }

            /// <summary>Return a forward iterator past the end of the list</summary>
            public global::gambit.Gambit.List<T>.Iterator End()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
            }

            public static global::gambit.Gambit.List<T> operator +(global::gambit.Gambit.List<T> __op, global::gambit.Gambit.List<T> b)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
            }

            public T Remove(int _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
            }

            /// <summary>
            /// <para>Removes all elements from the list container (which are destroyed),</para>
            /// <para>leaving the container with a size of 0.</para>
            /// </summary>
            public void Clear()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
            }

            public T this[int _0]
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
            }

            protected int MLength
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        return ((global::gambit.Gambit.List.__Internal*)__Instance)->m_length;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        return ((global::gambit.Gambit.List.__Internal*)__Instance)->m_length;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        ((global::gambit.Gambit.List.__Internal*)__Instance)->m_length = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        ((global::gambit.Gambit.List.__Internal*)__Instance)->m_length = value;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
            }

            protected global::gambit.Gambit.List<T>.Node MHead
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        var __result0 = global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.Node.__GetOrCreateInstance(((global::gambit.Gambit.List.__Internal*)__Instance)->m_head, false);
                        return (global::gambit.Gambit.List<T>.Node) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        var __result0 = global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.Node.__GetOrCreateInstance(((global::gambit.Gambit.List.__Internal*)__Instance)->m_head, false);
                        return (global::gambit.Gambit.List<T>.Node) (object) __result0;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        ((global::gambit.Gambit.List.__Internal*)__Instance)->m_head = value is null ? __IntPtr.Zero : value.__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        ((global::gambit.Gambit.List.__Internal*)__Instance)->m_head = value is null ? __IntPtr.Zero : value.__Instance;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
            }

            protected global::gambit.Gambit.List<T>.Node MTail
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        var __result0 = global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.Node.__GetOrCreateInstance(((global::gambit.Gambit.List.__Internal*)__Instance)->m_tail, false);
                        return (global::gambit.Gambit.List<T>.Node) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        var __result0 = global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.Node.__GetOrCreateInstance(((global::gambit.Gambit.List.__Internal*)__Instance)->m_tail, false);
                        return (global::gambit.Gambit.List<T>.Node) (object) __result0;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        ((global::gambit.Gambit.List.__Internal*)__Instance)->m_tail = value is null ? __IntPtr.Zero : value.__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        ((global::gambit.Gambit.List.__Internal*)__Instance)->m_tail = value is null ? __IntPtr.Zero : value.__Instance;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
            }

            protected int MCurrentIndex
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        return ((global::gambit.Gambit.List.__Internal*)__Instance)->m_currentIndex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        return ((global::gambit.Gambit.List.__Internal*)__Instance)->m_currentIndex;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        ((global::gambit.Gambit.List.__Internal*)__Instance)->m_currentIndex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        ((global::gambit.Gambit.List.__Internal*)__Instance)->m_currentIndex = value;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
            }

            protected global::gambit.Gambit.List<T>.Node MCurrentNode
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        var __result0 = global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.Node.__GetOrCreateInstance(((global::gambit.Gambit.List.__Internal*)__Instance)->m_currentNode, false);
                        return (global::gambit.Gambit.List<T>.Node) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        var __result0 = global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.Node.__GetOrCreateInstance(((global::gambit.Gambit.List.__Internal*)__Instance)->m_currentNode, false);
                        return (global::gambit.Gambit.List<T>.Node) (object) __result0;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        ((global::gambit.Gambit.List.__Internal*)__Instance)->m_currentNode = value is null ? __IntPtr.Zero : value.__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        ((global::gambit.Gambit.List.__Internal*)__Instance)->m_currentNode = value is null ? __IntPtr.Zero : value.__Instance;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
            }

            /// <summary>Return a const forward iterator starting at the beginning of the list</summary>
            public global::gambit.Gambit.List<T>.ConstIterator Cbegin
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
            }

            /// <summary>Return a const forward iterator past the end of the list</summary>
            public global::gambit.Gambit.List<T>.ConstIterator Cend
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
            }

            public int Length
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
            }

            /// <summary>
            /// <para>These operations are a partial implementation of operations on</para>
            /// <para>STL-style list containers.  It is suggested that future code be</para>
            /// <para>written to use these, and existing code ported to use them as</para>
            /// <para>possible.</para>
            /// <para>@{</para>
            /// <para>Return whether the list container is empty (has size 0).</para>
            /// </summary>
            public bool Empty
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
            }

            /// <summary>Return the number of elements in the list container.</summary>
            public ulong Size
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.List<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
            }

            #region Virtual table interop

            // List<T>::~List()
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.List<T>.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe static partial class ListExtensions
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?front@?$List@V?$GameObjectPtr@VGameStrategyRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGameStrategyRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Front(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?back@?$List@V?$GameObjectPtr@VGameStrategyRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGameStrategyRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Back(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?front@?$List@V?$GameObjectPtr@VGameInfosetRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGameInfosetRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Front_1(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?back@?$List@V?$GameObjectPtr@VGameInfosetRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGameInfosetRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Back_1(__IntPtr __instance);
            }

            /// <summary>Returns a reference to the first elemnet in the list container.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> Front(this global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Returns a reference to the last element in the list container.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> Back(this global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Returns a reference to the first elemnet in the list container.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> Front(this global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front_1(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Returns a reference to the last element in the list container.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> Back(this global::gambit.Gambit.List<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back_1(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }
        }
    }

    namespace Gambit
    {
    }

    namespace Gambit
    {
        namespace Vector
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public unsafe partial struct __Internal
            {
                internal __IntPtr vfptr_Array;
                internal int mindex;
                internal int maxdex;
                internal __IntPtr data;
            }
        }

        /// <summary>A mathematical vector: a list of numbers with the standard math operators</summary>
        public unsafe partial class Vector<T> : global::gambit.Gambit.Array<T>, IDisposable
        {
            internal static new Vector<T> __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Vector<T>(native.ToPointer(), skipVTables);
            }

            internal static new Vector<T> __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Vector<T>)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Vector<T> __CreateInstance(global::gambit.Gambit.Vector.__Internal native, bool skipVTables = false)
            {
                return new Vector<T>(native, skipVTables);
            }

            private static void* __CopyValue(global::gambit.Gambit.Vector.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.Vector.__Internal));
                *(global::gambit.Gambit.Vector.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Vector(global::gambit.Gambit.Vector.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Vector(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Create a vector of length len, starting at 1</summary>
            public Vector(uint len)
                : this((void*) null)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method Vector_T_ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method Vector_T_ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method Vector_T_ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Create a vector indexed from low to high</summary>
            public Vector(int low, int high)
                : this((void*) null)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method Vector_T_ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method Vector_T_ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method Vector_T_ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Copy constructor</summary>
            public Vector(global::gambit.Gambit.Vector<T> _0)
                : this((void*) null)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method Vector_T_ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method Vector_T_ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method Vector_T_ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::gambit.Gambit.Vector<T> operator +(global::gambit.Gambit.Vector<T> __op, global::gambit.Gambit.Vector<T> V)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            public static global::gambit.Gambit.Vector<T> operator -(global::gambit.Gambit.Vector<T> __op, global::gambit.Gambit.Vector<T> V)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            public static global::gambit.Gambit.Vector<T> operator *(global::gambit.Gambit.Vector<T> __op, T c)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            public static T operator *(global::gambit.Gambit.Vector<T> __op, global::gambit.Gambit.Vector<T> V)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            public static global::gambit.Gambit.Vector<T> operator /(global::gambit.Gambit.Vector<T> __op, T c)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            public static bool operator ==(global::gambit.Gambit.Vector<T> __op, global::gambit.Gambit.Vector<T> V)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::gambit.Gambit.Vector<T>;
            }

            public override int GetHashCode()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Vector.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Vector.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Vector.__Internal*) __Instance).GetHashCode();
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            public static bool operator !=(global::gambit.Gambit.Vector<T> __op, global::gambit.Gambit.Vector<T> V)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Tests if all components of the vector are equal to a constant c</summary>
            public static bool operator ==(global::gambit.Gambit.Vector<T> __op, T c)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            public static bool operator !=(global::gambit.Gambit.Vector<T> __op, T c)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            public bool Check(global::gambit.Gambit.Vector<T> v)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method Check ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method Check ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method Check ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            public static explicit operator global::gambit.Gambit.Vector<T>(uint len)
            {
                return new global::gambit.Gambit.Vector<T>(len);
            }

            public T NormSquared
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        throw new MissingMethodException("Method NormSquared missing from explicit specialization global::gambit.Gambit.Vector<int>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method NormSquared missing from explicit specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method NormSquared missing from explicit specialization global::gambit.Gambit.Vector<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
                }
            }
        }
    }

    namespace Gambit
    {
    }

    namespace Gambit
    {
        /// <summary>A representation of an arbitrary-precision rational number</summary>
        public unsafe partial class Rational : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal global::gambit.Gambit.Integer.__Internal num;
                internal global::gambit.Gambit.Integer.__Internal den;

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "??1Rational@Gambit@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Rational> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Rational>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.Rational managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.Rational managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Rational __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Rational(native.ToPointer(), skipVTables);
            }

            internal static Rational __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Rational)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Rational __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Rational(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Rational(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Rational(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            protected global::gambit.Gambit.Integer Num
            {
                get
                {
                    return global::gambit.Gambit.Integer.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->num));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->num = *(global::gambit.Gambit.Integer.__Internal*) value.__Instance;
                }
            }

            protected global::gambit.Gambit.Integer Den
            {
                get
                {
                    return global::gambit.Gambit.Integer.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->den));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->den = *(global::gambit.Gambit.Integer.__Internal*) value.__Instance;
                }
            }
        }

        public unsafe partial class rational
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?sign@Gambit@@YAHAEBVRational@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Sign(__IntPtr x);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?abs@Gambit@@YA?AVRational@1@AEBV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Abs(__IntPtr @return, __IntPtr x);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?sqr@Gambit@@YA?AVRational@1@AEBV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Sqr(__IntPtr @return, __IntPtr x);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?pow@Gambit@@YA?AVRational@1@AEBV21@J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Pow(__IntPtr @return, __IntPtr x, int y);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?pow@Gambit@@YA?AVRational@1@AEBV21@AEBVInteger@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Pow(__IntPtr @return, __IntPtr x, __IntPtr y);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?floor@Gambit@@YA?AVInteger@1@AEBVRational@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Floor(__IntPtr @return, __IntPtr x);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?ceil@Gambit@@YA?AVInteger@1@AEBVRational@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Ceil(__IntPtr @return, __IntPtr x);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?trunc@Gambit@@YA?AVInteger@1@AEBVRational@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Trunc(__IntPtr @return, __IntPtr x);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?round@Gambit@@YA?AVInteger@1@AEBVRational@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Round(__IntPtr @return, __IntPtr x);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?compare@Gambit@@YAHAEBVRational@1@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Compare(__IntPtr x, __IntPtr y);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?add@Gambit@@YAXAEBVRational@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Add(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?sub@Gambit@@YAXAEBVRational@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Sub(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?mul@Gambit@@YAXAEBVRational@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Mul(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?div@Gambit@@YAXAEBVRational@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Div(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "??$lexical_cast@VRational@Gambit@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Gambit@@YA?AVRational@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void LexicalCast(__IntPtr @return, __IntPtr _0);
            }

            public static int Sign(global::gambit.Gambit.Rational x)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = __Internal.Sign(__arg0);
                return ___ret;
            }

            public static global::gambit.Gambit.Rational Abs(global::gambit.Gambit.Rational x)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                __Internal.Abs(new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Rational Sqr(global::gambit.Gambit.Rational x)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                __Internal.Sqr(new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Rational Pow(global::gambit.Gambit.Rational x, int y)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                __Internal.Pow(new IntPtr(&___ret), __arg0, y);
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Rational Pow(global::gambit.Gambit.Rational x, global::gambit.Gambit.Integer y)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                __Internal.Pow(new IntPtr(&___ret), __arg0, __arg1);
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Floor(global::gambit.Gambit.Rational x)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Floor(new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Ceil(global::gambit.Gambit.Rational x)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Ceil(new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Trunc(global::gambit.Gambit.Rational x)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Trunc(new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Round(global::gambit.Gambit.Rational x)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Round(new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static int Compare(global::gambit.Gambit.Rational x, global::gambit.Gambit.Rational y)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                var ___ret = __Internal.Compare(__arg0, __arg1);
                return ___ret;
            }

            public static void Add(global::gambit.Gambit.Rational x, global::gambit.Gambit.Rational y, global::gambit.Gambit.Rational dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Add(__arg0, __arg1, __arg2);
            }

            public static void Sub(global::gambit.Gambit.Rational x, global::gambit.Gambit.Rational y, global::gambit.Gambit.Rational dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Sub(__arg0, __arg1, __arg2);
            }

            public static void Mul(global::gambit.Gambit.Rational x, global::gambit.Gambit.Rational y, global::gambit.Gambit.Rational dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Mul(__arg0, __arg1, __arg2);
            }

            public static void Div(global::gambit.Gambit.Rational x, global::gambit.Gambit.Rational y, global::gambit.Gambit.Rational dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Div(__arg0, __arg1, __arg2);
            }

            public static global::gambit.Gambit.Rational LexicalCast(string _0)
            {
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, _0);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                __Internal.LexicalCast(new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }
        }
    }

    namespace Gambit
    {
        namespace PVector
        {
            [StructLayout(LayoutKind.Sequential, Size = 56)]
            public unsafe partial struct __Internal
            {
                internal __IntPtr vfptr_Array;
                internal int mindex;
                internal int maxdex;
                internal __IntPtr data;
                internal __IntPtr svptr;
                internal global::gambit.Gambit.Array.__Internal svlen;
            }
        }

        public unsafe partial class PVector<T> : global::gambit.Gambit.Vector<T>, IDisposable
        {
            internal static new PVector<T> __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PVector<T>(native.ToPointer(), skipVTables);
            }

            internal static new PVector<T> __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PVector<T>)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static PVector<T> __CreateInstance(global::gambit.Gambit.PVector.__Internal native, bool skipVTables = false)
            {
                return new PVector<T>(native, skipVTables);
            }

            private static void* __CopyValue(global::gambit.Gambit.PVector.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.PVector.__Internal));
                *(global::gambit.Gambit.PVector.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private PVector(global::gambit.Gambit.PVector.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected PVector(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public PVector()
                : this((void*) null)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method PVector_T_ ignored in specialization global::gambit.Gambit.PVector<int>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.PVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>.");
            }

            public PVector(global::gambit.Gambit.Array<int> sig)
                : this((void*) null)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method PVector_T_ ignored in specialization global::gambit.Gambit.PVector<int>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.PVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>.");
            }

            public PVector(global::gambit.Gambit.Vector<T> val, global::gambit.Gambit.Array<int> sig)
                : this((void*) null)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method PVector_T_ ignored in specialization global::gambit.Gambit.PVector<int>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.PVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>.");
            }

            public PVector(global::gambit.Gambit.PVector<T> v)
                : this((void*) null)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method PVector_T_ ignored in specialization global::gambit.Gambit.PVector<int>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.PVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>.");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            protected int Check(global::gambit.Gambit.PVector<T> v)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method Check ignored in specialization global::gambit.Gambit.PVector<int>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.PVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>.");
            }

            public global::gambit.Gambit.Vector<T> GetRow(int row)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method GetRow ignored in specialization global::gambit.Gambit.PVector<int>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.PVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>.");
            }

            public void GetRow(int row, global::gambit.Gambit.Vector<T> v)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method GetRow ignored in specialization global::gambit.Gambit.PVector<int>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.PVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>.");
            }

            public void SetRow(int row, global::gambit.Gambit.Vector<T> v)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method SetRow ignored in specialization global::gambit.Gambit.PVector<int>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.PVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>.");
            }

            public void CopyRow(int row, global::gambit.Gambit.PVector<T> v)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method CopyRow ignored in specialization global::gambit.Gambit.PVector<int>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.PVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>.");
            }

            public static global::gambit.Gambit.PVector<T> operator +(global::gambit.Gambit.PVector<T> __op, global::gambit.Gambit.PVector<T> v)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.PVector<int>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.PVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>.");
            }

            public static global::gambit.Gambit.PVector<T> operator -(global::gambit.Gambit.PVector<T> __op, global::gambit.Gambit.PVector<T> v)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.PVector<int>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.PVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>.");
            }

            public static T operator *(global::gambit.Gambit.PVector<T> __op, global::gambit.Gambit.PVector<T> v)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.PVector<int>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.PVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>.");
            }

            public static global::gambit.Gambit.PVector<T> operator /(global::gambit.Gambit.PVector<T> __op, T c)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.PVector<int>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.PVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>.");
            }

            public static bool operator ==(global::gambit.Gambit.PVector<T> __op, global::gambit.Gambit.PVector<T> v)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.PVector<int>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.PVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>.");
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::gambit.Gambit.PVector<T>;
            }

            public override int GetHashCode()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.PVector.__Internal*) __Instance).GetHashCode();
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.PVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>.");
            }

            public static bool operator !=(global::gambit.Gambit.PVector<T> __op, global::gambit.Gambit.PVector<T> v)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.PVector<int>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.PVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>.");
            }

            public static explicit operator global::gambit.Gambit.PVector<T>(global::gambit.Gambit.Array<int> sig)
            {
                return new global::gambit.Gambit.PVector<T>(sig);
            }

            protected T Svptr
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        return (T) (object) ((global::gambit.Gambit.PVector.__Internal*)__Instance)->svptr;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.PVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        var __value0 = (int) (object) value;
                        ((global::gambit.Gambit.PVector.__Internal*)__Instance)->svptr = (__IntPtr) (object) __value0;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.PVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>.");
                }
            }

            protected global::gambit.Gambit.Array<int> Svlen
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        return global::gambit.Gambit.Array<int>.__CreateInstance(new __IntPtr(&((global::gambit.Gambit.PVector.__Internal*)__Instance)->svlen));
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.PVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::gambit.Gambit.PVector.__Internal*)__Instance)->svlen = *(global::gambit.Gambit.Array.__Internal*) value.__Instance;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.PVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>.");
                }
            }

            public global::gambit.Gambit.Array<int> Lengths
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        throw new MissingMethodException("Method Lengths missing from explicit specialization global::gambit.Gambit.PVector<int>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.PVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>.");
                }
            }
        }

        public unsafe static partial class PVectorExtensions
        {
            public partial struct __Internal
            {
            }
        }
    }

    namespace Gambit
    {
        namespace DVector
        {
            [StructLayout(LayoutKind.Sequential, Size = 112)]
            public unsafe partial struct __Internal
            {
                internal __IntPtr vfptr_Array;
                internal int mindex;
                internal int maxdex;
                internal __IntPtr data;
                internal __IntPtr svptr;
                internal global::gambit.Gambit.Array.__Internal svlen;
                internal __IntPtr dvptr;
                internal global::gambit.Gambit.Array.__Internal dvlen;
                internal global::gambit.Gambit.Array.__Internal dvidx;
            }
        }

        public unsafe partial class DVector<T> : global::gambit.Gambit.PVector<T>, IDisposable
        {
            internal static new DVector<T> __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new DVector<T>(native.ToPointer(), skipVTables);
            }

            internal static new DVector<T> __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (DVector<T>)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static DVector<T> __CreateInstance(global::gambit.Gambit.DVector.__Internal native, bool skipVTables = false)
            {
                return new DVector<T>(native, skipVTables);
            }

            private static void* __CopyValue(global::gambit.Gambit.DVector.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.DVector.__Internal));
                *(global::gambit.Gambit.DVector.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private DVector(global::gambit.Gambit.DVector.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected DVector(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public DVector(global::gambit.Gambit.PVector<int> sig)
                : this((void*) null)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method DVector_T_ ignored in specialization global::gambit.Gambit.DVector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method DVector_T_ ignored in specialization global::gambit.Gambit.DVector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.DVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public DVector(global::gambit.Gambit.DVector<T> v)
                : this((void*) null)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method DVector_T_ ignored in specialization global::gambit.Gambit.DVector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method DVector_T_ ignored in specialization global::gambit.Gambit.DVector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.DVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::gambit.Gambit.DVector<T>(global::gambit.Gambit.PVector<int> sig)
            {
                return new global::gambit.Gambit.DVector<T>(sig);
            }

            protected T Dvptr
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        var __result0 = global::gambit.Gambit.Rational.__GetOrCreateInstance(((global::gambit.Gambit.DVector.__Internal*)__Instance)->dvptr, false);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        return (T) (object) ((global::gambit.Gambit.DVector.__Internal*)__Instance)->dvptr;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.DVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        var __value = ((global::gambit.Gambit.Rational) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.Rational) (object) value).__Instance;
                        ((global::gambit.Gambit.DVector.__Internal*)__Instance)->dvptr = new __IntPtr(&__value);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        var __value0 = (double) (object) value;
                        ((global::gambit.Gambit.DVector.__Internal*)__Instance)->dvptr = (__IntPtr) (object) __value0;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.DVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            protected global::gambit.Gambit.Array<int> Dvlen
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        return global::gambit.Gambit.Array<int>.__CreateInstance(new __IntPtr(&((global::gambit.Gambit.DVector.__Internal*)__Instance)->dvlen));
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        return global::gambit.Gambit.Array<int>.__CreateInstance(new __IntPtr(&((global::gambit.Gambit.DVector.__Internal*)__Instance)->dvlen));
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.DVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::gambit.Gambit.DVector.__Internal*)__Instance)->dvlen = *(global::gambit.Gambit.Array.__Internal*) value.__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::gambit.Gambit.DVector.__Internal*)__Instance)->dvlen = *(global::gambit.Gambit.Array.__Internal*) value.__Instance;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.DVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            protected global::gambit.Gambit.Array<int> Dvidx
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        return global::gambit.Gambit.Array<int>.__CreateInstance(new __IntPtr(&((global::gambit.Gambit.DVector.__Internal*)__Instance)->dvidx));
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        return global::gambit.Gambit.Array<int>.__CreateInstance(new __IntPtr(&((global::gambit.Gambit.DVector.__Internal*)__Instance)->dvidx));
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.DVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::gambit.Gambit.DVector.__Internal*)__Instance)->dvidx = *(global::gambit.Gambit.Array.__Internal*) value.__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::gambit.Gambit.DVector.__Internal*)__Instance)->dvidx = *(global::gambit.Gambit.Array.__Internal*) value.__Instance;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.DVector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }
        }
    }

    namespace Gambit
    {
        /// <summary>This class represents a numerical data value in a game.</summary>
        /// <remarks>
        /// <para>Numerical data in a game (outcome payoffs and chance move probabilities) are</para>
        /// <para>stored using instances of this class.  This class accomplishes two objectives:</para>
        /// <para>1.  The canonical representation of a numerical data value is a rational number.</para>
        /// <para>This means that algorithms which compute using rational numbers will produce</para>
        /// <para>the expected results reliably.</para>
        /// <para>2.  The text representation of a number is recorded.  Therefore, calling code</para>
        /// <para>can use either rational numbers or decimals, and this class will recall that</para>
        /// <para>representation correctly.  Therefore, &quot;10.1&quot; is represented internally</para>
        /// <para>as Rational(101, 100), but the representation &quot;10.1&quot; is returned by the</para>
        /// <para>string, and not &quot;101/100&quot;.</para>
        /// </remarks>
        public unsafe partial class Number : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 56)]
            public partial struct __Internal
            {
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_text;
                internal global::gambit.Gambit.Rational.__Internal m_rational;
                internal double m_double;

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "??1Number@Gambit@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Number> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Number>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.Number managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.Number managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Number __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Number(native.ToPointer(), skipVTables);
            }

            internal static Number __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Number)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Number __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Number(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Number(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Number(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }
    }

    namespace Gambit
    {
        namespace GameObjectPtr
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public unsafe partial struct __Internal
            {
                internal __IntPtr rep;

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "c__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep_F__GameObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "c__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep_F__GameObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "c__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep_F__GameObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "c__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep_F__GameObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "??1?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "c__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep_F__GameObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "??1?$GameObjectPtr@VGameOutcomeRep@Gambit@@@Gambit@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameOutcomeRep(__IntPtr __instance);
            }
        }

        public unsafe partial class GameObjectPtr<T> : IDisposable
        {
            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.GameObjectPtr<T>> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.GameObjectPtr<T>>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.GameObjectPtr<T> managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.GameObjectPtr<T> managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static GameObjectPtr<T> __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameObjectPtr<T>(native.ToPointer(), skipVTables);
            }

            internal static GameObjectPtr<T> __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameObjectPtr<T>)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static GameObjectPtr<T> __CreateInstance(global::gambit.Gambit.GameObjectPtr.__Internal native, bool skipVTables = false)
            {
                return new GameObjectPtr<T>(native, skipVTables);
            }

            private static void* __CopyValue(global::gambit.Gambit.GameObjectPtr.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.GameObjectPtr.__Internal));
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GameObjectPtr(global::gambit.Gambit.GameObjectPtr.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GameObjectPtr(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public GameObjectPtr(global::gambit.Gambit.GameObjectPtr<T> r)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameRep)))
                {
                    throw new MissingMethodException("Method GameObjectPtr_T_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameInfosetRep)))
                {
                    throw new MissingMethodException("Method GameObjectPtr_T_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GamePlayerRep)))
                {
                    throw new MissingMethodException("Method GameObjectPtr_T_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameStrategyRep)))
                {
                    throw new MissingMethodException("Method GameObjectPtr_T_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameActionRep)))
                {
                    throw new MissingMethodException("Method GameObjectPtr_T_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameNodeRep)))
                {
                    throw new MissingMethodException("Method GameObjectPtr_T_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameOutcomeRep)))
                {
                    throw new MissingMethodException("Method GameObjectPtr_T_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.GameObjectPtr<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameRep>, <global::gambit.Gambit.GameInfosetRep>, <global::gambit.Gambit.GamePlayerRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameActionRep>, <global::gambit.Gambit.GameNodeRep>, <global::gambit.Gambit.GameOutcomeRep>.");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static bool operator ==(global::gambit.Gambit.GameObjectPtr<T> __op, global::gambit.Gambit.GameObjectPtr<T> r)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameInfosetRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GamePlayerRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameStrategyRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameActionRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameNodeRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameOutcomeRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.GameObjectPtr<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameRep>, <global::gambit.Gambit.GameInfosetRep>, <global::gambit.Gambit.GamePlayerRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameActionRep>, <global::gambit.Gambit.GameNodeRep>, <global::gambit.Gambit.GameOutcomeRep>.");
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::gambit.Gambit.GameObjectPtr<T>;
            }

            public override int GetHashCode()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameRep)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.GameObjectPtr.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameInfosetRep)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.GameObjectPtr.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GamePlayerRep)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.GameObjectPtr.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameStrategyRep)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.GameObjectPtr.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameActionRep)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.GameObjectPtr.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameNodeRep)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.GameObjectPtr.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameOutcomeRep)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.GameObjectPtr.__Internal*) __Instance).GetHashCode();
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.GameObjectPtr<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameRep>, <global::gambit.Gambit.GameInfosetRep>, <global::gambit.Gambit.GamePlayerRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameActionRep>, <global::gambit.Gambit.GameNodeRep>, <global::gambit.Gambit.GameOutcomeRep>.");
            }

            public static bool operator !=(global::gambit.Gambit.GameObjectPtr<T> __op, global::gambit.Gambit.GameObjectPtr<T> r)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameInfosetRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GamePlayerRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameStrategyRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameActionRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameNodeRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameOutcomeRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.GameObjectPtr<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameRep>, <global::gambit.Gambit.GameInfosetRep>, <global::gambit.Gambit.GamePlayerRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameActionRep>, <global::gambit.Gambit.GameNodeRep>, <global::gambit.Gambit.GameOutcomeRep>.");
            }

            public static bool operator !(global::gambit.Gambit.GameObjectPtr<T> __op)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameRep)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameInfosetRep)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GamePlayerRep)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameStrategyRep)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameActionRep)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameNodeRep)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameOutcomeRep)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.GameObjectPtr<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameRep>, <global::gambit.Gambit.GameInfosetRep>, <global::gambit.Gambit.GamePlayerRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameActionRep>, <global::gambit.Gambit.GameNodeRep>, <global::gambit.Gambit.GameOutcomeRep>.");
            }
        }

        /// <summary>
        /// <para>This is a base class for all game-related objects.  Primary among</para>
        /// <para>its responsibility is maintaining a reference count.  Calling code</para>
        /// <para>which maintains pointers to objects representing parts of a game</para>
        /// <para>(e.g., nodes) which may be deleted should increment the reference</para>
        /// <para>count for that object.  The library guarantees that any object</para>
        /// <para>with a positive reference count will not have its memory deleted,</para>
        /// <para>but will instead be marked as deleted.  Calling code should always</para>
        /// <para>be careful to check the deleted status of the object before any</para>
        /// <para>operations on it.</para>
        /// </summary>
        public unsafe partial class GameObject : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_GameObject;
                internal int m_refCount;
                internal byte m_valid;
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.GameObject> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.GameObject>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.GameObject managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.GameObject managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static GameObject __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameObject(native.ToPointer(), skipVTables);
            }

            internal static GameObject __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameObject)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static GameObject __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GameObject)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GameObject __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameObject(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GameObject(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GameObject(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            protected int MRefCount
            {
                get
                {
                    return ((__Internal*)__Instance)->m_refCount;
                }

                set
                {
                    ((__Internal*)__Instance)->m_refCount = value;
                }
            }

            protected bool MValid
            {
                get
                {
                    return ((__Internal*)__Instance)->m_valid != 0;
                }

                set
                {
                    ((__Internal*)__Instance)->m_valid = (byte) (value ? 1 : 0);
                }
            }

            #region Virtual table interop

            // virtual ~GameObject() = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.GameObject.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class BaseGameRep : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_BaseGameRep;
                internal int m_refCount;
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.BaseGameRep> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.BaseGameRep>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.BaseGameRep managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.BaseGameRep managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static BaseGameRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new BaseGameRep(native.ToPointer(), skipVTables);
            }

            internal static BaseGameRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (BaseGameRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static BaseGameRep __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (BaseGameRep)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static BaseGameRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new BaseGameRep(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private BaseGameRep(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected BaseGameRep(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            protected int MRefCount
            {
                get
                {
                    return ((__Internal*)__Instance)->m_refCount;
                }

                set
                {
                    ((__Internal*)__Instance)->m_refCount = value;
                }
            }

            #region Virtual table interop

            // virtual ~BaseGameRep() = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.BaseGameRep.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>An exception thrown when attempting to dereference an invalidated object</summary>
        public unsafe partial class InvalidObjectException : global::gambit.Gambit.Exception, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;
            }

            internal static new InvalidObjectException __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new InvalidObjectException(native.ToPointer(), skipVTables);
            }

            internal static new InvalidObjectException __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (InvalidObjectException)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new InvalidObjectException __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (InvalidObjectException)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static InvalidObjectException __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new InvalidObjectException(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private InvalidObjectException(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected InvalidObjectException(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public virtual string What()
            {
                var ___WhatDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr>(0, 1);
                var ___ret = ___WhatDelegate(__Instance);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            #region Virtual table interop

            // ~InvalidObjectException() noexcept override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.InvalidObjectException.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // char *what() const noexcept override
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _WhatDelegateInstance;

            private static __IntPtr _WhatDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.InvalidObjectException.__GetInstance(__instance);
                var ___ret = __target.What();
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _WhatDelegateInstance += _WhatDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_WhatDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe static partial class GameObjectPtrExtensions
        {
            public partial struct __Internal
            {
            }
        }
    }

    namespace Gambit
    {
        /// <summary>Exception thrown when an operation that is undefined is attempted</summary>
        public unsafe partial class UndefinedException : global::gambit.Gambit.Exception, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;
            }

            internal static new UndefinedException __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new UndefinedException(native.ToPointer(), skipVTables);
            }

            internal static new UndefinedException __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (UndefinedException)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new UndefinedException __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (UndefinedException)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static UndefinedException __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new UndefinedException(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private UndefinedException(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected UndefinedException(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // ~UndefinedException() noexcept override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.UndefinedException.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Exception thrown on an operation between incompatible objects</summary>
        public unsafe partial class MismatchException : global::gambit.Gambit.Exception, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;
            }

            internal static new MismatchException __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new MismatchException(native.ToPointer(), skipVTables);
            }

            internal static new MismatchException __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (MismatchException)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new MismatchException __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (MismatchException)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static MismatchException __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new MismatchException(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private MismatchException(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected MismatchException(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public virtual string What()
            {
                var ___WhatDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr>(0, 1);
                var ___ret = ___WhatDelegate(__Instance);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            #region Virtual table interop

            // ~MismatchException() noexcept override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.MismatchException.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // char *what() const noexcept override
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _WhatDelegateInstance;

            private static __IntPtr _WhatDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.MismatchException.__GetInstance(__instance);
                var ___ret = __target.What();
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _WhatDelegateInstance += _WhatDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_WhatDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Exception thrown when comparing different versions of a game</summary>
        public unsafe partial class GameStructureChangedException : global::gambit.Gambit.Exception, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;
            }

            internal static new GameStructureChangedException __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameStructureChangedException(native.ToPointer(), skipVTables);
            }

            internal static new GameStructureChangedException __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameStructureChangedException)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GameStructureChangedException __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GameStructureChangedException)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GameStructureChangedException __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameStructureChangedException(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GameStructureChangedException(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GameStructureChangedException(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public virtual string What()
            {
                var ___WhatDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr>(0, 1);
                var ___ret = ___WhatDelegate(__Instance);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            #region Virtual table interop

            // ~GameStructureChangedException() noexcept override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.GameStructureChangedException.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // char *what() const noexcept override
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _WhatDelegateInstance;

            private static __IntPtr _WhatDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameStructureChangedException.__GetInstance(__instance);
                var ___ret = __target.What();
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _WhatDelegateInstance += _WhatDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_WhatDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Exception thrown on a parse error when reading a game savefile</summary>
        public unsafe partial class InvalidFileException : global::gambit.Gambit.Exception, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;
            }

            internal static new InvalidFileException __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new InvalidFileException(native.ToPointer(), skipVTables);
            }

            internal static new InvalidFileException __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (InvalidFileException)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new InvalidFileException __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (InvalidFileException)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static InvalidFileException __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new InvalidFileException(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private InvalidFileException(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected InvalidFileException(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // ~InvalidFileException() noexcept override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.InvalidFileException.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>This class represents an outcome in a game.  An outcome</para>
        /// <para>specifies a vector of payoffs to players.</para>
        /// </summary>
        public unsafe partial class GameOutcomeRep : global::gambit.Gambit.GameObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 88)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_GameObject;
                internal int m_refCount;
                internal byte m_valid;
                internal __IntPtr m_game;
                internal int m_number;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_label;
                internal global::gambit.Gambit.Array.__Internal m_payoffs;
            }

            internal static new GameOutcomeRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameOutcomeRep(native.ToPointer(), skipVTables);
            }

            internal static new GameOutcomeRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameOutcomeRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GameOutcomeRep __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GameOutcomeRep)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GameOutcomeRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameOutcomeRep(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GameOutcomeRep(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GameOutcomeRep(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // ~GameOutcomeRep() override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.GameOutcomeRep.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>An action at an information set in an extensive game</summary>
        public unsafe abstract partial class GameActionRep : global::gambit.Gambit.GameObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_GameObject;
                internal int m_refCount;
                internal byte m_valid;
            }

            internal static new GameActionRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameActionRepInternal(native.ToPointer(), skipVTables);
            }

            internal static new GameActionRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameActionRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GameActionRep __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GameActionRep)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GameActionRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameActionRepInternal(native, skipVTables);
            }

            protected GameActionRep(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public abstract bool Precedes(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> _0);

            public abstract void DeleteAction();

            public abstract int Number
            {
                get;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> Infoset
            {
                get;
            }

            public abstract string Label
            {
                get;

                set;
            }

            #region Virtual table interop

            // ~GameActionRep() override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.GameActionRep.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // int GetNumber() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _GetNumberDelegateInstance;

            private static int _GetNumberDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameActionRep.__GetInstance(__instance);
                var ___ret = __target.Number;
                return ___ret;
            }

            // GameInfoset GetInfoset() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetInfosetDelegateInstance;

            private static void _GetInfosetDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameActionRep.__GetInstance(__instance);
                var ___ret = __target.Infoset;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // std::string &GetLabel() const = 0
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _GetLabelDelegateInstance;

            private static __IntPtr _GetLabelDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameActionRep.__GetInstance(__instance);
                var ___ret = __target.Label;
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                return __basicString0.__Instance;
            }

            // void SetLabel(const std::string &p_label) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetLabelDelegateInstance;

            private static void _SetLabelDelegateHook(__IntPtr __instance, __IntPtr p_label)
            {
                var __target = global::gambit.Gambit.GameActionRep.__GetInstance(__instance);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(p_label);
                __target.Label = global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            // bool Precedes(const GameNode &) const = 0
            private static global::gambit.Delegates.Func_bool___IntPtr___IntPtr _PrecedesDelegateInstance;

            private static bool _PrecedesDelegateHook(__IntPtr __instance, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameActionRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__GetOrCreateInstance(_0, false);
                var ___ret = __target.Precedes(__result0);
                return ___ret;
            }

            // void DeleteAction() = 0
            private static global::gambit.Delegates.Action___IntPtr _DeleteActionDelegateInstance;

            private static void _DeleteActionDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameActionRep.__GetInstance(__instance);
                __target.DeleteAction();
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[7];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetNumberDelegateInstance += _GetNumberDelegateHook;
                    _GetInfosetDelegateInstance += _GetInfosetDelegateHook;
                    _GetLabelDelegateInstance += _GetLabelDelegateHook;
                    _SetLabelDelegateInstance += _SetLabelDelegateHook;
                    _PrecedesDelegateInstance += _PrecedesDelegateHook;
                    _DeleteActionDelegateInstance += _DeleteActionDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetNumberDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetInfosetDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetLabelDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetLabelDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_PrecedesDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_DeleteActionDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 7, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 7, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                VTables.Methods[0] = new Delegate[7];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>An information set in an extensive game</summary>
        public unsafe abstract partial class GameInfosetRep : global::gambit.Gambit.GameObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_GameObject;
                internal int m_refCount;
                internal byte m_valid;
            }

            internal static new GameInfosetRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameInfosetRepInternal(native.ToPointer(), skipVTables);
            }

            internal static new GameInfosetRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameInfosetRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GameInfosetRep __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GameInfosetRep)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GameInfosetRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameInfosetRepInternal(native, skipVTables);
            }

            protected GameInfosetRep(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> InsertAction(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> p_where);

            /// <summary>Returns the p_index'th action at the information set</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> GetAction(int p_index);

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> GetMember(int p_index);

            public abstract bool Precedes(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> _0);

            public abstract global::gambit.Gambit.Number GetActionProb(int i);

            public abstract global::gambit.Gambit.Number GetActionProb(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> _0);

            public abstract void Reveal(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> _0);

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> Game
            {
                get;
            }

            public abstract int Number
            {
                get;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> Player
            {
                get;

                set;
            }

            public abstract bool IsChanceInfoset
            {
                get;
            }

            public abstract string Label
            {
                get;

                set;
            }

            /// <summary>Returns the number of actions available at the information set</summary>
            public abstract int NumActions
            {
                get;
            }

            /// <summary>Returns the actions available at the information set</summary>
            public abstract global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>> Actions
            {
                get;
            }

            public abstract int NumMembers
            {
                get;
            }

            public abstract global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>> Members
            {
                get;
            }

            #region Virtual table interop

            // ~GameInfosetRep() override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // Game GetGame() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetGameDelegateInstance;

            private static void _GetGameDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.Game;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // int GetNumber() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _GetNumberDelegateInstance;

            private static int _GetNumberDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.Number;
                return ___ret;
            }

            // GamePlayer GetPlayer() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetPlayerDelegateInstance;

            private static void _GetPlayerDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.Player;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // void SetPlayer(GamePlayer p) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetPlayerDelegateInstance;

            private static void _SetPlayerDelegateHook(__IntPtr __instance, __IntPtr p)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__GetOrCreateInstance(p, false);
                __target.Player = __result0;
            }

            // bool IsChanceInfoset() const = 0
            private static global::gambit.Delegates.Func_bool___IntPtr _IsChanceInfosetDelegateInstance;

            private static bool _IsChanceInfosetDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.IsChanceInfoset;
                return ___ret;
            }

            // void SetLabel(const std::string &p_label) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetLabelDelegateInstance;

            private static void _SetLabelDelegateHook(__IntPtr __instance, __IntPtr p_label)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(p_label);
                __target.Label = global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            // std::string &GetLabel() const = 0
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _GetLabelDelegateInstance;

            private static __IntPtr _GetLabelDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.Label;
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                return __basicString0.__Instance;
            }

            // GameAction InsertAction(GameAction p_where = nullptr) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr _InsertActionDelegateInstance;

            private static void _InsertActionDelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr p_where)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__GetOrCreateInstance(p_where, false);
                var ___ret = __target.InsertAction(__result1);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // int NumActions() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _NumActionsDelegateInstance;

            private static int _NumActionsDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.NumActions;
                return ___ret;
            }

            // GameAction GetAction(int p_index) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetActionDelegateInstance;

            private static void _GetActionDelegateHook(__IntPtr __instance, __IntPtr @return, int p_index)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.GetAction(p_index);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // Array<GameAction> GetActions() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetActionsDelegateInstance;

            private static void _GetActionsDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.Actions;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // int NumMembers() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _NumMembersDelegateInstance;

            private static int _NumMembersDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.NumMembers;
                return ___ret;
            }

            // GameNode GetMember(int p_index) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetMemberDelegateInstance;

            private static void _GetMemberDelegateHook(__IntPtr __instance, __IntPtr @return, int p_index)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.GetMember(p_index);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // Array<GameNode> GetMembers() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetMembersDelegateInstance;

            private static void _GetMembersDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.Members;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // bool Precedes(GameNode) const = 0
            private static global::gambit.Delegates.Func_bool___IntPtr___IntPtr _PrecedesDelegateInstance;

            private static bool _PrecedesDelegateHook(__IntPtr __instance, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__GetOrCreateInstance(_0, false);
                var ___ret = __target.Precedes(__result0);
                return ___ret;
            }

            // Number &GetActionProb(const GameAction &) const = 0
            private static global::gambit.Delegates.Func___IntPtr___IntPtr___IntPtr _GetActionProb_1DelegateInstance;

            private static __IntPtr _GetActionProb_1DelegateHook(__IntPtr __instance, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__GetOrCreateInstance(_0, false);
                var ___ret = __target.GetActionProb(__result0);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // Number &GetActionProb(int i) const = 0
            private static global::gambit.Delegates.Func___IntPtr___IntPtr_int _GetActionProbDelegateInstance;

            private static __IntPtr _GetActionProbDelegateHook(__IntPtr __instance, int i)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.GetActionProb(i);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void Reveal(GamePlayer) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _RevealDelegateInstance;

            private static void _RevealDelegateHook(__IntPtr __instance, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__GetOrCreateInstance(_0, false);
                __target.Reveal(__result0);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[19];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetGameDelegateInstance += _GetGameDelegateHook;
                    _GetNumberDelegateInstance += _GetNumberDelegateHook;
                    _GetPlayerDelegateInstance += _GetPlayerDelegateHook;
                    _SetPlayerDelegateInstance += _SetPlayerDelegateHook;
                    _IsChanceInfosetDelegateInstance += _IsChanceInfosetDelegateHook;
                    _SetLabelDelegateInstance += _SetLabelDelegateHook;
                    _GetLabelDelegateInstance += _GetLabelDelegateHook;
                    _InsertActionDelegateInstance += _InsertActionDelegateHook;
                    _NumActionsDelegateInstance += _NumActionsDelegateHook;
                    _GetActionDelegateInstance += _GetActionDelegateHook;
                    _GetActionsDelegateInstance += _GetActionsDelegateHook;
                    _NumMembersDelegateInstance += _NumMembersDelegateHook;
                    _GetMemberDelegateInstance += _GetMemberDelegateHook;
                    _GetMembersDelegateInstance += _GetMembersDelegateHook;
                    _PrecedesDelegateInstance += _PrecedesDelegateHook;
                    _GetActionProb_1DelegateInstance += _GetActionProb_1DelegateHook;
                    _GetActionProbDelegateInstance += _GetActionProbDelegateHook;
                    _RevealDelegateInstance += _RevealDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetGameDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetNumberDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPlayerDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetPlayerDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_IsChanceInfosetDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_SetLabelDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetLabelDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_InsertActionDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_NumActionsDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_GetActionDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_GetActionsDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_NumMembersDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_GetMemberDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_GetMembersDelegateInstance);
                    Thunks[15] = Marshal.GetFunctionPointerForDelegate(_PrecedesDelegateInstance);
                    Thunks[16] = Marshal.GetFunctionPointerForDelegate(_GetActionProb_1DelegateInstance);
                    Thunks[17] = Marshal.GetFunctionPointerForDelegate(_GetActionProbDelegateInstance);
                    Thunks[18] = Marshal.GetFunctionPointerForDelegate(_RevealDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 19, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 19, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                ManagedVTables[0][7] = Thunks[7];
                                ManagedVTables[0][8] = Thunks[8];
                                ManagedVTables[0][9] = Thunks[9];
                                ManagedVTables[0][10] = Thunks[10];
                                ManagedVTables[0][11] = Thunks[11];
                                ManagedVTables[0][12] = Thunks[12];
                                ManagedVTables[0][13] = Thunks[13];
                                ManagedVTables[0][14] = Thunks[14];
                                ManagedVTables[0][15] = Thunks[15];
                                ManagedVTables[0][16] = Thunks[16];
                                ManagedVTables[0][17] = Thunks[17];
                                ManagedVTables[0][18] = Thunks[18];
                                VTables.Methods[0] = new Delegate[19];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>A strategy in a game.</summary>
        /// <remarks>
        /// <para>This class represents a strategy in a game.</para>
        /// <para>For strategic games, this object internally stores an offset.</para>
        /// <para>This offset has the</para>
        /// <para>property that, for a strategy profile, adding the offsets of the</para>
        /// <para>strategies gives the index into the strategic game's table to</para>
        /// <para>find the outcome for that strategy profile, making payoff computation</para>
        /// <para>relatively efficient.</para>
        /// </remarks>
        public unsafe partial class GameStrategyRep : global::gambit.Gambit.GameObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 96)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_GameObject;
                internal int m_refCount;
                internal byte m_valid;
                internal int m_number;
                internal int m_id;
                internal __IntPtr m_player;
                internal int m_offset;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_label;
                internal global::gambit.Gambit.Array.__Internal m_behav;
            }

            internal static new GameStrategyRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameStrategyRep(native.ToPointer(), skipVTables);
            }

            internal static new GameStrategyRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameStrategyRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GameStrategyRep __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GameStrategyRep)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GameStrategyRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameStrategyRep(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GameStrategyRep(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GameStrategyRep(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // GameStrategyRep
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.GameStrategyRep.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>A player in a game</summary>
        public unsafe partial class GamePlayerRep : global::gambit.Gambit.GameObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 112)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_GameObject;
                internal int m_refCount;
                internal byte m_valid;
                internal __IntPtr m_game;
                internal int m_number;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_label;
                internal global::gambit.Gambit.Array.__Internal m_infosets;
                internal global::gambit.Gambit.Array.__Internal m_strategies;
            }

            internal static new GamePlayerRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GamePlayerRep(native.ToPointer(), skipVTables);
            }

            internal static new GamePlayerRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GamePlayerRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GamePlayerRep __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GamePlayerRep)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GamePlayerRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GamePlayerRep(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GamePlayerRep(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GamePlayerRep(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // ~GamePlayerRep() override
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.GamePlayerRep.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>A node in an extensive game</summary>
        public unsafe abstract partial class GameNodeRep : global::gambit.Gambit.GameObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_GameObject;
                internal int m_refCount;
                internal byte m_valid;
            }

            internal static new GameNodeRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameNodeRepInternal(native.ToPointer(), skipVTables);
            }

            internal static new GameNodeRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameNodeRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GameNodeRep __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GameNodeRep)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GameNodeRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameNodeRepInternal(native, skipVTables);
            }

            protected GameNodeRep(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> GetChild(int i);

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> GetChild(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> _0);

            public abstract bool IsSuccessorOf(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> from);

            public abstract void DeleteParent();

            public abstract void DeleteTree();

            public abstract void CopyTree(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> src);

            public abstract void MoveTree(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> src);

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> AppendMove(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> p_player, int p_actions);

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> AppendMove(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> p_infoset);

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> InsertMove(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> p_player, int p_actions);

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> InsertMove(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> p_infoset);

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> Game
            {
                get;
            }

            public abstract string Label
            {
                get;

                set;
            }

            public abstract int Number
            {
                get;
            }

            public abstract int NumberInInfoset
            {
                get;
            }

            public abstract int NumChildren
            {
                get;
            }

            public abstract global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>> Children
            {
                get;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> Infoset
            {
                get;

                set;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> LeaveInfoset
            {
                get;
            }

            public abstract bool IsTerminal
            {
                get;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> Player
            {
                get;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> PriorAction
            {
                get;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> Parent
            {
                get;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> NextSibling
            {
                get;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> PriorSibling
            {
                get;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> Outcome
            {
                get;

                set;
            }

            public abstract bool IsSubgameRoot
            {
                get;
            }

            /// <summary>Create a separate Game object containing the subgame rooted at the node</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> CopySubgame
            {
                get;
            }

            #region Virtual table interop

            // ~GameNodeRep() override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // Game GetGame() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetGameDelegateInstance;

            private static void _GetGameDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.Game;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // std::string &GetLabel() const = 0
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _GetLabelDelegateInstance;

            private static __IntPtr _GetLabelDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.Label;
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                return __basicString0.__Instance;
            }

            // void SetLabel(const std::string &p_label) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetLabelDelegateInstance;

            private static void _SetLabelDelegateHook(__IntPtr __instance, __IntPtr p_label)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(p_label);
                __target.Label = global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            // int GetNumber() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _GetNumberDelegateInstance;

            private static int _GetNumberDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.Number;
                return ___ret;
            }

            // int NumberInInfoset() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _NumberInInfosetDelegateInstance;

            private static int _NumberInInfosetDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.NumberInInfoset;
                return ___ret;
            }

            // int NumChildren() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _NumChildrenDelegateInstance;

            private static int _NumChildrenDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.NumChildren;
                return ___ret;
            }

            // GameNode GetChild(const GameAction &) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr _GetChild_1DelegateInstance;

            private static void _GetChild_1DelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__GetOrCreateInstance(_0, false);
                var ___ret = __target.GetChild(__result1);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameNode GetChild(int i) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetChildDelegateInstance;

            private static void _GetChildDelegateHook(__IntPtr __instance, __IntPtr @return, int i)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.GetChild(i);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // Array<GameNode> GetChildren() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetChildrenDelegateInstance;

            private static void _GetChildrenDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.Children;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // GameInfoset GetInfoset() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetInfosetDelegateInstance;

            private static void _GetInfosetDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.Infoset;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // void SetInfoset(GameInfoset) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetInfosetDelegateInstance;

            private static void _SetInfosetDelegateHook(__IntPtr __instance, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(_0, false);
                __target.Infoset = __result0;
            }

            // GameInfoset LeaveInfoset() = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _LeaveInfosetDelegateInstance;

            private static void _LeaveInfosetDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.LeaveInfoset;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // bool IsTerminal() const = 0
            private static global::gambit.Delegates.Func_bool___IntPtr _IsTerminalDelegateInstance;

            private static bool _IsTerminalDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.IsTerminal;
                return ___ret;
            }

            // GamePlayer GetPlayer() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetPlayerDelegateInstance;

            private static void _GetPlayerDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.Player;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameAction GetPriorAction() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetPriorActionDelegateInstance;

            private static void _GetPriorActionDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.PriorAction;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameNode GetParent() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetParentDelegateInstance;

            private static void _GetParentDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.Parent;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameNode GetNextSibling() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetNextSiblingDelegateInstance;

            private static void _GetNextSiblingDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.NextSibling;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameNode GetPriorSibling() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetPriorSiblingDelegateInstance;

            private static void _GetPriorSiblingDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.PriorSibling;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameOutcome GetOutcome() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetOutcomeDelegateInstance;

            private static void _GetOutcomeDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.Outcome;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // void SetOutcome(const GameOutcome &p_outcome) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetOutcomeDelegateInstance;

            private static void _SetOutcomeDelegateHook(__IntPtr __instance, __IntPtr p_outcome)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.__GetOrCreateInstance(p_outcome, false);
                __target.Outcome = __result0;
            }

            // bool IsSuccessorOf(GameNode from) const = 0
            private static global::gambit.Delegates.Func_bool___IntPtr___IntPtr _IsSuccessorOfDelegateInstance;

            private static bool _IsSuccessorOfDelegateHook(__IntPtr __instance, __IntPtr from)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__GetOrCreateInstance(from, false);
                var ___ret = __target.IsSuccessorOf(__result0);
                return ___ret;
            }

            // bool IsSubgameRoot() const = 0
            private static global::gambit.Delegates.Func_bool___IntPtr _IsSubgameRootDelegateInstance;

            private static bool _IsSubgameRootDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.IsSubgameRoot;
                return ___ret;
            }

            // void DeleteParent() = 0
            private static global::gambit.Delegates.Action___IntPtr _DeleteParentDelegateInstance;

            private static void _DeleteParentDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                __target.DeleteParent();
            }

            // void DeleteTree() = 0
            private static global::gambit.Delegates.Action___IntPtr _DeleteTreeDelegateInstance;

            private static void _DeleteTreeDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                __target.DeleteTree();
            }

            // void CopyTree(GameNode src) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _CopyTreeDelegateInstance;

            private static void _CopyTreeDelegateHook(__IntPtr __instance, __IntPtr src)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__GetOrCreateInstance(src, false);
                __target.CopyTree(__result0);
            }

            // void MoveTree(GameNode src) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _MoveTreeDelegateInstance;

            private static void _MoveTreeDelegateHook(__IntPtr __instance, __IntPtr src)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__GetOrCreateInstance(src, false);
                __target.MoveTree(__result0);
            }

            // Game CopySubgame() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _CopySubgameDelegateInstance;

            private static void _CopySubgameDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.CopySubgame;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameInfoset AppendMove(GameInfoset p_infoset) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr _AppendMove_1DelegateInstance;

            private static void _AppendMove_1DelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr p_infoset)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(p_infoset, false);
                var ___ret = __target.AppendMove(__result1);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameInfoset AppendMove(GamePlayer p_player, int p_actions) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr_int _AppendMoveDelegateInstance;

            private static void _AppendMoveDelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr p_player, int p_actions)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__GetOrCreateInstance(p_player, false);
                var ___ret = __target.AppendMove(__result1, p_actions);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameInfoset InsertMove(GameInfoset p_infoset) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr _InsertMove_1DelegateInstance;

            private static void _InsertMove_1DelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr p_infoset)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(p_infoset, false);
                var ___ret = __target.InsertMove(__result1);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameInfoset InsertMove(GamePlayer p_player, int p_actions) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr_int _InsertMoveDelegateInstance;

            private static void _InsertMoveDelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr p_player, int p_actions)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__GetOrCreateInstance(p_player, false);
                var ___ret = __target.InsertMove(__result1, p_actions);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[32];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetGameDelegateInstance += _GetGameDelegateHook;
                    _GetLabelDelegateInstance += _GetLabelDelegateHook;
                    _SetLabelDelegateInstance += _SetLabelDelegateHook;
                    _GetNumberDelegateInstance += _GetNumberDelegateHook;
                    _NumberInInfosetDelegateInstance += _NumberInInfosetDelegateHook;
                    _NumChildrenDelegateInstance += _NumChildrenDelegateHook;
                    _GetChild_1DelegateInstance += _GetChild_1DelegateHook;
                    _GetChildDelegateInstance += _GetChildDelegateHook;
                    _GetChildrenDelegateInstance += _GetChildrenDelegateHook;
                    _GetInfosetDelegateInstance += _GetInfosetDelegateHook;
                    _SetInfosetDelegateInstance += _SetInfosetDelegateHook;
                    _LeaveInfosetDelegateInstance += _LeaveInfosetDelegateHook;
                    _IsTerminalDelegateInstance += _IsTerminalDelegateHook;
                    _GetPlayerDelegateInstance += _GetPlayerDelegateHook;
                    _GetPriorActionDelegateInstance += _GetPriorActionDelegateHook;
                    _GetParentDelegateInstance += _GetParentDelegateHook;
                    _GetNextSiblingDelegateInstance += _GetNextSiblingDelegateHook;
                    _GetPriorSiblingDelegateInstance += _GetPriorSiblingDelegateHook;
                    _GetOutcomeDelegateInstance += _GetOutcomeDelegateHook;
                    _SetOutcomeDelegateInstance += _SetOutcomeDelegateHook;
                    _IsSuccessorOfDelegateInstance += _IsSuccessorOfDelegateHook;
                    _IsSubgameRootDelegateInstance += _IsSubgameRootDelegateHook;
                    _DeleteParentDelegateInstance += _DeleteParentDelegateHook;
                    _DeleteTreeDelegateInstance += _DeleteTreeDelegateHook;
                    _CopyTreeDelegateInstance += _CopyTreeDelegateHook;
                    _MoveTreeDelegateInstance += _MoveTreeDelegateHook;
                    _CopySubgameDelegateInstance += _CopySubgameDelegateHook;
                    _AppendMove_1DelegateInstance += _AppendMove_1DelegateHook;
                    _AppendMoveDelegateInstance += _AppendMoveDelegateHook;
                    _InsertMove_1DelegateInstance += _InsertMove_1DelegateHook;
                    _InsertMoveDelegateInstance += _InsertMoveDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetGameDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetLabelDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_SetLabelDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNumberDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_NumberInInfosetDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_NumChildrenDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetChild_1DelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_GetChildDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetChildrenDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_GetInfosetDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_SetInfosetDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_LeaveInfosetDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_IsTerminalDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_GetPlayerDelegateInstance);
                    Thunks[15] = Marshal.GetFunctionPointerForDelegate(_GetPriorActionDelegateInstance);
                    Thunks[16] = Marshal.GetFunctionPointerForDelegate(_GetParentDelegateInstance);
                    Thunks[17] = Marshal.GetFunctionPointerForDelegate(_GetNextSiblingDelegateInstance);
                    Thunks[18] = Marshal.GetFunctionPointerForDelegate(_GetPriorSiblingDelegateInstance);
                    Thunks[19] = Marshal.GetFunctionPointerForDelegate(_GetOutcomeDelegateInstance);
                    Thunks[20] = Marshal.GetFunctionPointerForDelegate(_SetOutcomeDelegateInstance);
                    Thunks[21] = Marshal.GetFunctionPointerForDelegate(_IsSuccessorOfDelegateInstance);
                    Thunks[22] = Marshal.GetFunctionPointerForDelegate(_IsSubgameRootDelegateInstance);
                    Thunks[23] = Marshal.GetFunctionPointerForDelegate(_DeleteParentDelegateInstance);
                    Thunks[24] = Marshal.GetFunctionPointerForDelegate(_DeleteTreeDelegateInstance);
                    Thunks[25] = Marshal.GetFunctionPointerForDelegate(_CopyTreeDelegateInstance);
                    Thunks[26] = Marshal.GetFunctionPointerForDelegate(_MoveTreeDelegateInstance);
                    Thunks[27] = Marshal.GetFunctionPointerForDelegate(_CopySubgameDelegateInstance);
                    Thunks[28] = Marshal.GetFunctionPointerForDelegate(_AppendMove_1DelegateInstance);
                    Thunks[29] = Marshal.GetFunctionPointerForDelegate(_AppendMoveDelegateInstance);
                    Thunks[30] = Marshal.GetFunctionPointerForDelegate(_InsertMove_1DelegateInstance);
                    Thunks[31] = Marshal.GetFunctionPointerForDelegate(_InsertMoveDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 32, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 32, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                ManagedVTables[0][7] = Thunks[7];
                                ManagedVTables[0][8] = Thunks[8];
                                ManagedVTables[0][9] = Thunks[9];
                                ManagedVTables[0][10] = Thunks[10];
                                ManagedVTables[0][11] = Thunks[11];
                                ManagedVTables[0][12] = Thunks[12];
                                ManagedVTables[0][13] = Thunks[13];
                                ManagedVTables[0][14] = Thunks[14];
                                ManagedVTables[0][15] = Thunks[15];
                                ManagedVTables[0][16] = Thunks[16];
                                ManagedVTables[0][17] = Thunks[17];
                                ManagedVTables[0][18] = Thunks[18];
                                ManagedVTables[0][19] = Thunks[19];
                                ManagedVTables[0][20] = Thunks[20];
                                ManagedVTables[0][21] = Thunks[21];
                                ManagedVTables[0][22] = Thunks[22];
                                ManagedVTables[0][23] = Thunks[23];
                                ManagedVTables[0][24] = Thunks[24];
                                ManagedVTables[0][25] = Thunks[25];
                                ManagedVTables[0][26] = Thunks[26];
                                ManagedVTables[0][27] = Thunks[27];
                                ManagedVTables[0][28] = Thunks[28];
                                ManagedVTables[0][29] = Thunks[29];
                                ManagedVTables[0][30] = Thunks[30];
                                ManagedVTables[0][31] = Thunks[31];
                                VTables.Methods[0] = new Delegate[32];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>This is the class for representing an arbitrary finite game.</summary>
        public unsafe abstract partial class GameRep : global::gambit.Gambit.BaseGameRep, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 88)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_BaseGameRep;
                internal int m_refCount;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_title;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_comment;
                internal uint m_version;
            }

            internal static new GameRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameRepInternal(native.ToPointer(), skipVTables);
            }

            internal static new GameRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GameRep __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GameRep)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GameRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameRepInternal(native, skipVTables);
            }

            protected GameRep(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Build any computed values anew</summary>
            protected virtual void BuildComputedValues()
            {
                var ___BuildComputedValuesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr>(0, 1);
                ___BuildComputedValuesDelegate(__Instance);
            }

            /// <summary>Returns the smallest payoff in any outcome of the game</summary>
            public abstract global::gambit.Gambit.Rational GetMinPayoff(int pl);

            /// <summary>Returns the largest payoff in any outcome of the game</summary>
            public abstract global::gambit.Gambit.Rational GetMaxPayoff(int pl);

            /// <summary>
            /// <para>Returns true if the game is perfect recall.  If not,</para>
            /// <para>a pair of violating information sets is returned in the parameters.</para>
            /// </summary>
            public abstract bool IsPerfectRecall(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> _0, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> _1);

            /// <summary>Gets the i'th strategy in the game, numbered globally</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> GetStrategy(int p_index);

            public abstract global::gambit.Gambit.PureStrategyProfile NewPureStrategyProfile();

            public abstract global::gambit.Gambit.MixedStrategyProfile<double> NewMixedStrategyProfile(double _0);

            public abstract global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational> NewMixedStrategyProfile(global::gambit.Gambit.Rational _0);

            public abstract global::gambit.Gambit.MixedStrategyProfile<double> NewMixedStrategyProfile(double _0, global::gambit.Gambit.StrategySupportProfile _1);

            public abstract global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational> NewMixedStrategyProfile(global::gambit.Gambit.Rational _0, global::gambit.Gambit.StrategySupportProfile _1);

            /// <summary>Returns the pl'th player in the game</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> GetPlayer(int pl);

            /// <summary>Creates a new player in the game, with no moves</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> NewPlayer();

            /// <summary>Returns the iset'th information set in the game (numbered globally)</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> GetInfoset(int iset);

            /// <summary>Returns the act'th action in the game (numbered globally)</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> GetAction(int act);

            /// <summary>Returns the index'th outcome defined in the game</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> GetOutcome(int index);

            /// <summary>Creates a new outcome in the game</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> NewOutcome();

            /// <summary>Deletes the specified outcome from the game</summary>
            public abstract void DeleteOutcome(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> _0);

            /// <summary>Set the probability distribution of actions at a chance node</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> SetChanceProbs(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> _0, global::gambit.Gambit.Array<global::gambit.Gambit.Number> _1);

            protected string MTitle
            {
                get
                {
                    var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_title));
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }

                set
                {
                    global::Std.BasicStringExtensions.__Internal.Assign(new __IntPtr(&((__Internal*)__Instance)->m_title), value);
                }
            }

            protected string MComment
            {
                get
                {
                    var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_comment));
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }

                set
                {
                    global::Std.BasicStringExtensions.__Internal.Assign(new __IntPtr(&((__Internal*)__Instance)->m_comment), value);
                }
            }

            protected uint MVersion
            {
                get
                {
                    return ((__Internal*)__Instance)->m_version;
                }

                set
                {
                    ((__Internal*)__Instance)->m_version = value;
                }
            }

            /// <summary>Create a copy of the game, as a new game</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> Copy
            {
                get;
            }

            /// <summary>Returns true if the game has a game tree representation</summary>
            public abstract bool IsTree
            {
                get;
            }

            /// <summary>Returns true if the game has a action-graph game representation</summary>
            public virtual bool IsAgg
            {
                get
                {
                    var ___IsAggDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr>(0, 4);
                    var ___ret = ___IsAggDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the text label associated with the game</summary>
            /// <remarks>Set the text label associated with the game</remarks>
            public virtual string Title
            {
                get
                {
                    var ___GetTitleDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr>(0, 5);
                    var ___ret = ___GetTitleDelegate(__Instance);
                    var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(___ret);
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }

                set
                {
                    var ___SetTitleDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 6);
                    var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, value);
                    var __arg0 = __basicString0.__Instance;
                    ___SetTitleDelegate(__Instance, __arg0);
                    __basicString0.Dispose();
                }
            }

            /// <summary>Get the text comment associated with the game</summary>
            /// <remarks>Set the text comment associated with the game</remarks>
            public virtual string Comment
            {
                get
                {
                    var ___GetCommentDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr>(0, 7);
                    var ___ret = ___GetCommentDelegate(__Instance);
                    var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(___ret);
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }

                set
                {
                    var ___SetCommentDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 8);
                    var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, value);
                    var __arg0 = __basicString0.__Instance;
                    ___SetCommentDelegate(__Instance, __arg0);
                    __basicString0.Dispose();
                }
            }

            /// <summary>Returns true if the game is constant-sum</summary>
            public abstract bool IsConstSum
            {
                get;
            }

            /// <summary>The number of actions in each information set</summary>
            public abstract global::gambit.Gambit.PVector<int> NumActions
            {
                get;
            }

            /// <summary>The number of members in each information set</summary>
            public abstract global::gambit.Gambit.PVector<int> NumMembers
            {
                get;
            }

            /// <summary>The number of strategies for each player</summary>
            public abstract global::gambit.Gambit.Array<int> NumStrategies
            {
                get;
            }

            /// <summary>Returns the number of strategy contingencies in the game</summary>
            public abstract int NumStrategyContingencies
            {
                get;
            }

            /// <summary>Returns the total number of actions in the game</summary>
            public abstract int BehavProfileLength
            {
                get;
            }

            /// <summary>Returns the total number of strategies in the game</summary>
            public abstract int MixedProfileLength
            {
                get;
            }

            /// <summary>Returns the number of players in the game</summary>
            public abstract int NumPlayers
            {
                get;
            }

            /// <summary>Returns the set of players in the game</summary>
            public virtual global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>> Players
            {
                get
                {
                    var ___GetPlayersDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 30);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___GetPlayersDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>Returns the chance (nature) player</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> Chance
            {
                get;
            }

            /// <summary>Returns the set of information sets in the game</summary>
            public abstract global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>> Infosets
            {
                get;
            }

            /// <summary>Returns an array with the number of information sets per personal player</summary>
            public abstract global::gambit.Gambit.Array<int> NumInfosets
            {
                get;
            }

            /// <summary>Returns the number of outcomes defined in the game</summary>
            public abstract int NumOutcomes
            {
                get;
            }

            /// <summary>Returns the root node of the game</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> Root
            {
                get;
            }

            /// <summary>Returns the number of nodes in the game</summary>
            public abstract int NumNodes
            {
                get;
            }

            #region Virtual table interop

            // ~GameRep() override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // void BuildComputedValues()
            private static global::gambit.Delegates.Action___IntPtr _BuildComputedValuesDelegateInstance;

            private static void _BuildComputedValuesDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                __target.BuildComputedValues();
            }

            // Game Copy() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _CopyDelegateInstance;

            private static void _CopyDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.Copy;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // bool IsTree() const = 0
            private static global::gambit.Delegates.Func_bool___IntPtr _IsTreeDelegateInstance;

            private static bool _IsTreeDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.IsTree;
                return ___ret;
            }

            // bool IsAgg() const
            private static global::gambit.Delegates.Func_bool___IntPtr _IsAggDelegateInstance;

            private static bool _IsAggDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.IsAgg;
                return ___ret;
            }

            // std::string &GetTitle() const
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _GetTitleDelegateInstance;

            private static __IntPtr _GetTitleDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.Title;
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                return __basicString0.__Instance;
            }

            // void SetTitle(const std::string &p_title)
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetTitleDelegateInstance;

            private static void _SetTitleDelegateHook(__IntPtr __instance, __IntPtr p_title)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(p_title);
                __target.Title = global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            // std::string &GetComment() const
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _GetCommentDelegateInstance;

            private static __IntPtr _GetCommentDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.Comment;
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                return __basicString0.__Instance;
            }

            // void SetComment(const std::string &p_comment)
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetCommentDelegateInstance;

            private static void _SetCommentDelegateHook(__IntPtr __instance, __IntPtr p_comment)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(p_comment);
                __target.Comment = global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            // bool IsConstSum() const = 0
            private static global::gambit.Delegates.Func_bool___IntPtr _IsConstSumDelegateInstance;

            private static bool _IsConstSumDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.IsConstSum;
                return ___ret;
            }

            // Rational GetMinPayoff(int pl = 0) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetMinPayoffDelegateInstance;

            private static void _GetMinPayoffDelegateHook(__IntPtr __instance, __IntPtr @return, int pl)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.GetMinPayoff(pl);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Rational.__Internal*) @return = *(global::gambit.Gambit.Rational.__Internal*) ___ret.__Instance;
            }

            // Rational GetMaxPayoff(int pl = 0) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetMaxPayoffDelegateInstance;

            private static void _GetMaxPayoffDelegateHook(__IntPtr __instance, __IntPtr @return, int pl)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.GetMaxPayoff(pl);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Rational.__Internal*) @return = *(global::gambit.Gambit.Rational.__Internal*) ___ret.__Instance;
            }

            // bool IsPerfectRecall(GameInfoset &, GameInfoset &) const = 0
            private static global::gambit.Delegates.Func_bool___IntPtr___IntPtr___IntPtr _IsPerfectRecallDelegateInstance;

            private static bool _IsPerfectRecallDelegateHook(__IntPtr __instance, __IntPtr _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(_0, false);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(_1, false);
                var ___ret = __target.IsPerfectRecall(__result0, __result1);
                return ___ret;
            }

            // PVector<int> NumActions() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NumActionsDelegateInstance;

            private static void _NumActionsDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NumActions;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.PVector.__Internal*) @return = *(global::gambit.Gambit.PVector.__Internal*) ___ret.__Instance;
            }

            // PVector<int> NumMembers() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NumMembersDelegateInstance;

            private static void _NumMembersDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NumMembers;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.PVector.__Internal*) @return = *(global::gambit.Gambit.PVector.__Internal*) ___ret.__Instance;
            }

            // Array<int> NumStrategies() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NumStrategiesDelegateInstance;

            private static void _NumStrategiesDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NumStrategies;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // GameStrategy GetStrategy(int p_index) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetStrategyDelegateInstance;

            private static void _GetStrategyDelegateHook(__IntPtr __instance, __IntPtr @return, int p_index)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.GetStrategy(p_index);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // int NumStrategyContingencies() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _NumStrategyContingenciesDelegateInstance;

            private static int _NumStrategyContingenciesDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NumStrategyContingencies;
                return ___ret;
            }

            // int BehavProfileLength() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _BehavProfileLengthDelegateInstance;

            private static int _BehavProfileLengthDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.BehavProfileLength;
                return ___ret;
            }

            // int MixedProfileLength() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _MixedProfileLengthDelegateInstance;

            private static int _MixedProfileLengthDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.MixedProfileLength;
                return ___ret;
            }

            // PureStrategyProfile NewPureStrategyProfile() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NewPureStrategyProfileDelegateInstance;

            private static void _NewPureStrategyProfileDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NewPureStrategyProfile();
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.PureStrategyProfile.__Internal*) @return = *(global::gambit.Gambit.PureStrategyProfile.__Internal*) ___ret.__Instance;
            }

            // MixedStrategyProfile<Rational> NewMixedStrategyProfile(const Rational &, const StrategySupportProfile &) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr _NewMixedStrategyProfile_3DelegateInstance;

            private static void _NewMixedStrategyProfile_3DelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.Rational.__GetOrCreateInstance(_0, false);
                var __result2 = global::gambit.Gambit.StrategySupportProfile.__GetOrCreateInstance(_1, false);
                var ___ret = __target.NewMixedStrategyProfile(__result1, __result2);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) @return = *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) ___ret.__Instance;
            }

            // MixedStrategyProfile<double> NewMixedStrategyProfile(double, const StrategySupportProfile &) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_double___IntPtr _NewMixedStrategyProfile_2DelegateInstance;

            private static void _NewMixedStrategyProfile_2DelegateHook(__IntPtr __instance, __IntPtr @return, double _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var __result2 = global::gambit.Gambit.StrategySupportProfile.__GetOrCreateInstance(_1, false);
                var ___ret = __target.NewMixedStrategyProfile(_0, __result2);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) @return = *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) ___ret.__Instance;
            }

            // MixedStrategyProfile<Rational> NewMixedStrategyProfile(const Rational &) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr _NewMixedStrategyProfile_1DelegateInstance;

            private static void _NewMixedStrategyProfile_1DelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.Rational.__GetOrCreateInstance(_0, false);
                var ___ret = __target.NewMixedStrategyProfile(__result1);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) @return = *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) ___ret.__Instance;
            }

            // MixedStrategyProfile<double> NewMixedStrategyProfile(double) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_double _NewMixedStrategyProfileDelegateInstance;

            private static void _NewMixedStrategyProfileDelegateHook(__IntPtr __instance, __IntPtr @return, double _0)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NewMixedStrategyProfile(_0);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) @return = *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) ___ret.__Instance;
            }

            // int NumPlayers() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _NumPlayersDelegateInstance;

            private static int _NumPlayersDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NumPlayers;
                return ___ret;
            }

            // GamePlayer GetPlayer(int pl) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetPlayerDelegateInstance;

            private static void _GetPlayerDelegateHook(__IntPtr __instance, __IntPtr @return, int pl)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.GetPlayer(pl);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // Array<GamePlayer> GetPlayers() const
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetPlayersDelegateInstance;

            private static void _GetPlayersDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.Players;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // GamePlayer GetChance() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetChanceDelegateInstance;

            private static void _GetChanceDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.Chance;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GamePlayer NewPlayer() = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NewPlayerDelegateInstance;

            private static void _NewPlayerDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NewPlayer();
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameInfoset GetInfoset(int iset) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetInfosetDelegateInstance;

            private static void _GetInfosetDelegateHook(__IntPtr __instance, __IntPtr @return, int iset)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.GetInfoset(iset);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // Array<GameInfoset> GetInfosets() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetInfosetsDelegateInstance;

            private static void _GetInfosetsDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.Infosets;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // Array<int> NumInfosets() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NumInfosetsDelegateInstance;

            private static void _NumInfosetsDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NumInfosets;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // GameAction GetAction(int act) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetActionDelegateInstance;

            private static void _GetActionDelegateHook(__IntPtr __instance, __IntPtr @return, int act)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.GetAction(act);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // int NumOutcomes() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _NumOutcomesDelegateInstance;

            private static int _NumOutcomesDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NumOutcomes;
                return ___ret;
            }

            // GameOutcome GetOutcome(int index) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetOutcomeDelegateInstance;

            private static void _GetOutcomeDelegateHook(__IntPtr __instance, __IntPtr @return, int index)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.GetOutcome(index);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameOutcome NewOutcome() = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NewOutcomeDelegateInstance;

            private static void _NewOutcomeDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NewOutcome();
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // void DeleteOutcome(const GameOutcome &) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _DeleteOutcomeDelegateInstance;

            private static void _DeleteOutcomeDelegateHook(__IntPtr __instance, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.__GetOrCreateInstance(_0, false);
                __target.DeleteOutcome(__result0);
            }

            // GameNode GetRoot() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetRootDelegateInstance;

            private static void _GetRootDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.Root;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // int NumNodes() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _NumNodesDelegateInstance;

            private static int _NumNodesDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NumNodes;
                return ___ret;
            }

            // Game SetChanceProbs(const GameInfoset &, const Array<Number> &) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr _SetChanceProbsDelegateInstance;

            private static void _SetChanceProbsDelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(_0, false);
                var __result2 = global::gambit.Gambit.Array<global::gambit.Gambit.Number>.__GetOrCreateInstance(_1, false, skipVTables: true);
                var ___ret = __target.SetChanceProbs(__result1, __result2);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[41];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _BuildComputedValuesDelegateInstance += _BuildComputedValuesDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    _IsTreeDelegateInstance += _IsTreeDelegateHook;
                    _IsAggDelegateInstance += _IsAggDelegateHook;
                    _GetTitleDelegateInstance += _GetTitleDelegateHook;
                    _SetTitleDelegateInstance += _SetTitleDelegateHook;
                    _GetCommentDelegateInstance += _GetCommentDelegateHook;
                    _SetCommentDelegateInstance += _SetCommentDelegateHook;
                    _IsConstSumDelegateInstance += _IsConstSumDelegateHook;
                    _GetMinPayoffDelegateInstance += _GetMinPayoffDelegateHook;
                    _GetMaxPayoffDelegateInstance += _GetMaxPayoffDelegateHook;
                    _IsPerfectRecallDelegateInstance += _IsPerfectRecallDelegateHook;
                    _NumActionsDelegateInstance += _NumActionsDelegateHook;
                    _NumMembersDelegateInstance += _NumMembersDelegateHook;
                    _NumStrategiesDelegateInstance += _NumStrategiesDelegateHook;
                    _GetStrategyDelegateInstance += _GetStrategyDelegateHook;
                    _NumStrategyContingenciesDelegateInstance += _NumStrategyContingenciesDelegateHook;
                    _BehavProfileLengthDelegateInstance += _BehavProfileLengthDelegateHook;
                    _MixedProfileLengthDelegateInstance += _MixedProfileLengthDelegateHook;
                    _NewPureStrategyProfileDelegateInstance += _NewPureStrategyProfileDelegateHook;
                    _NewMixedStrategyProfile_3DelegateInstance += _NewMixedStrategyProfile_3DelegateHook;
                    _NewMixedStrategyProfile_2DelegateInstance += _NewMixedStrategyProfile_2DelegateHook;
                    _NewMixedStrategyProfile_1DelegateInstance += _NewMixedStrategyProfile_1DelegateHook;
                    _NewMixedStrategyProfileDelegateInstance += _NewMixedStrategyProfileDelegateHook;
                    _NumPlayersDelegateInstance += _NumPlayersDelegateHook;
                    _GetPlayerDelegateInstance += _GetPlayerDelegateHook;
                    _GetPlayersDelegateInstance += _GetPlayersDelegateHook;
                    _GetChanceDelegateInstance += _GetChanceDelegateHook;
                    _NewPlayerDelegateInstance += _NewPlayerDelegateHook;
                    _GetInfosetDelegateInstance += _GetInfosetDelegateHook;
                    _GetInfosetsDelegateInstance += _GetInfosetsDelegateHook;
                    _NumInfosetsDelegateInstance += _NumInfosetsDelegateHook;
                    _GetActionDelegateInstance += _GetActionDelegateHook;
                    _NumOutcomesDelegateInstance += _NumOutcomesDelegateHook;
                    _GetOutcomeDelegateInstance += _GetOutcomeDelegateHook;
                    _NewOutcomeDelegateInstance += _NewOutcomeDelegateHook;
                    _DeleteOutcomeDelegateInstance += _DeleteOutcomeDelegateHook;
                    _GetRootDelegateInstance += _GetRootDelegateHook;
                    _NumNodesDelegateInstance += _NumNodesDelegateHook;
                    _SetChanceProbsDelegateInstance += _SetChanceProbsDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_BuildComputedValuesDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_IsTreeDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_IsAggDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetTitleDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_SetTitleDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetCommentDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_SetCommentDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_IsConstSumDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_GetMinPayoffDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_GetMaxPayoffDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_IsPerfectRecallDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_NumActionsDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_NumMembersDelegateInstance);
                    Thunks[15] = Marshal.GetFunctionPointerForDelegate(_NumStrategiesDelegateInstance);
                    Thunks[16] = Marshal.GetFunctionPointerForDelegate(_GetStrategyDelegateInstance);
                    Thunks[17] = Marshal.GetFunctionPointerForDelegate(_NumStrategyContingenciesDelegateInstance);
                    Thunks[18] = Marshal.GetFunctionPointerForDelegate(_BehavProfileLengthDelegateInstance);
                    Thunks[19] = Marshal.GetFunctionPointerForDelegate(_MixedProfileLengthDelegateInstance);
                    Thunks[20] = Marshal.GetFunctionPointerForDelegate(_NewPureStrategyProfileDelegateInstance);
                    Thunks[21] = Marshal.GetFunctionPointerForDelegate(_NewMixedStrategyProfile_3DelegateInstance);
                    Thunks[22] = Marshal.GetFunctionPointerForDelegate(_NewMixedStrategyProfile_2DelegateInstance);
                    Thunks[23] = Marshal.GetFunctionPointerForDelegate(_NewMixedStrategyProfile_1DelegateInstance);
                    Thunks[24] = Marshal.GetFunctionPointerForDelegate(_NewMixedStrategyProfileDelegateInstance);
                    Thunks[25] = Marshal.GetFunctionPointerForDelegate(_NumPlayersDelegateInstance);
                    Thunks[26] = Marshal.GetFunctionPointerForDelegate(_GetPlayerDelegateInstance);
                    Thunks[27] = Marshal.GetFunctionPointerForDelegate(_GetPlayersDelegateInstance);
                    Thunks[28] = Marshal.GetFunctionPointerForDelegate(_GetChanceDelegateInstance);
                    Thunks[29] = Marshal.GetFunctionPointerForDelegate(_NewPlayerDelegateInstance);
                    Thunks[30] = Marshal.GetFunctionPointerForDelegate(_GetInfosetDelegateInstance);
                    Thunks[31] = Marshal.GetFunctionPointerForDelegate(_GetInfosetsDelegateInstance);
                    Thunks[32] = Marshal.GetFunctionPointerForDelegate(_NumInfosetsDelegateInstance);
                    Thunks[33] = Marshal.GetFunctionPointerForDelegate(_GetActionDelegateInstance);
                    Thunks[34] = Marshal.GetFunctionPointerForDelegate(_NumOutcomesDelegateInstance);
                    Thunks[35] = Marshal.GetFunctionPointerForDelegate(_GetOutcomeDelegateInstance);
                    Thunks[36] = Marshal.GetFunctionPointerForDelegate(_NewOutcomeDelegateInstance);
                    Thunks[37] = Marshal.GetFunctionPointerForDelegate(_DeleteOutcomeDelegateInstance);
                    Thunks[38] = Marshal.GetFunctionPointerForDelegate(_GetRootDelegateInstance);
                    Thunks[39] = Marshal.GetFunctionPointerForDelegate(_NumNodesDelegateInstance);
                    Thunks[40] = Marshal.GetFunctionPointerForDelegate(_SetChanceProbsDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 44, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 44, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                ManagedVTables[0][7] = Thunks[7];
                                ManagedVTables[0][8] = Thunks[8];
                                ManagedVTables[0][9] = Thunks[9];
                                ManagedVTables[0][10] = Thunks[10];
                                ManagedVTables[0][11] = Thunks[11];
                                ManagedVTables[0][12] = Thunks[12];
                                ManagedVTables[0][16] = Thunks[13];
                                ManagedVTables[0][17] = Thunks[14];
                                ManagedVTables[0][18] = Thunks[15];
                                ManagedVTables[0][19] = Thunks[16];
                                ManagedVTables[0][20] = Thunks[17];
                                ManagedVTables[0][21] = Thunks[18];
                                ManagedVTables[0][22] = Thunks[19];
                                ManagedVTables[0][23] = Thunks[20];
                                ManagedVTables[0][24] = Thunks[21];
                                ManagedVTables[0][25] = Thunks[22];
                                ManagedVTables[0][26] = Thunks[23];
                                ManagedVTables[0][27] = Thunks[24];
                                ManagedVTables[0][28] = Thunks[25];
                                ManagedVTables[0][29] = Thunks[26];
                                ManagedVTables[0][30] = Thunks[27];
                                ManagedVTables[0][31] = Thunks[28];
                                ManagedVTables[0][32] = Thunks[29];
                                ManagedVTables[0][33] = Thunks[30];
                                ManagedVTables[0][34] = Thunks[31];
                                ManagedVTables[0][35] = Thunks[32];
                                ManagedVTables[0][36] = Thunks[33];
                                ManagedVTables[0][37] = Thunks[34];
                                ManagedVTables[0][38] = Thunks[35];
                                ManagedVTables[0][39] = Thunks[36];
                                ManagedVTables[0][40] = Thunks[37];
                                ManagedVTables[0][41] = Thunks[38];
                                ManagedVTables[0][42] = Thunks[39];
                                ManagedVTables[0][43] = Thunks[40];
                                VTables.Methods[0] = new Delegate[44];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class GameActionRepInternal : global::gambit.Gambit.GameActionRep, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal GameActionRepInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal GameActionRepInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override bool Precedes(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> _0)
            {
                var ___PrecedesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr___IntPtr>(0, 5);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = ___PrecedesDelegate(__Instance, __arg0);
                return ___ret;
            }

            public override void DeleteAction()
            {
                var ___DeleteActionDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr>(0, 6);
                ___DeleteActionDelegate(__Instance);
            }

            public override int Number
            {
                get
                {
                    var ___GetNumberDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 1);
                    var ___ret = ___GetNumberDelegate(__Instance);
                    return ___ret;
                }
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> Infoset
            {
                get
                {
                    var ___GetInfosetDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 2);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetInfosetDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public override string Label
            {
                get
                {
                    var ___GetLabelDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr>(0, 3);
                    var ___ret = ___GetLabelDelegate(__Instance);
                    var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(___ret);
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }

                set
                {
                    var ___SetLabelDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 4);
                    var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, value);
                    var __arg0 = __basicString0.__Instance;
                    ___SetLabelDelegate(__Instance, __arg0);
                    __basicString0.Dispose();
                }
            }
        }

        public unsafe partial class GameInfosetRepInternal : global::gambit.Gambit.GameInfosetRep, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal GameInfosetRepInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal GameInfosetRepInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> InsertAction(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> p_where)
            {
                var ___InsertActionDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 8);
                if (ReferenceEquals(p_where, null))
                    throw new global::System.ArgumentNullException("p_where", "Cannot be null because it is passed by value.");
                var __arg0 = p_where.__Instance;
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___InsertActionDelegate(__Instance, new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the p_index'th action at the information set</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> GetAction(int p_index)
            {
                var ___GetActionDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 10);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetActionDelegate(__Instance, new IntPtr(&___ret), p_index);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> GetMember(int p_index)
            {
                var ___GetMemberDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 13);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetMemberDelegate(__Instance, new IntPtr(&___ret), p_index);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep(new __IntPtr(&___ret));
                return _____ret;
            }

            public override bool Precedes(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> _0)
            {
                var ___PrecedesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr___IntPtr>(0, 15);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is passed by value.");
                var __arg0 = _0.__Instance;
                var ___ret = ___PrecedesDelegate(__Instance, __arg0);
                return ___ret;
            }

            public override global::gambit.Gambit.Number GetActionProb(int i)
            {
                var ___GetActionProbDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr_int>(0, 17);
                var ___ret = ___GetActionProbDelegate(__Instance, i);
                var __result0 = global::gambit.Gambit.Number.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public override global::gambit.Gambit.Number GetActionProb(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> _0)
            {
                var ___GetActionProb_1Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr___IntPtr>(0, 16);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = ___GetActionProb_1Delegate(__Instance, __arg0);
                var __result0 = global::gambit.Gambit.Number.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public override void Reveal(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> _0)
            {
                var ___RevealDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 18);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is passed by value.");
                var __arg0 = _0.__Instance;
                ___RevealDelegate(__Instance, __arg0);
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> Game
            {
                get
                {
                    var ___GetGameDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 1);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetGameDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public override int Number
            {
                get
                {
                    var ___GetNumberDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 2);
                    var ___ret = ___GetNumberDelegate(__Instance);
                    return ___ret;
                }
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> Player
            {
                get
                {
                    var ___GetPlayerDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 3);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetPlayerDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep(new __IntPtr(&___ret));
                    return _____ret;
                }

                set
                {
                    var ___SetPlayerDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 4);
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    var __arg0 = value.__Instance;
                    ___SetPlayerDelegate(__Instance, __arg0);
                }
            }

            public override bool IsChanceInfoset
            {
                get
                {
                    var ___IsChanceInfosetDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr>(0, 5);
                    var ___ret = ___IsChanceInfosetDelegate(__Instance);
                    return ___ret;
                }
            }

            public override string Label
            {
                get
                {
                    var ___GetLabelDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr>(0, 7);
                    var ___ret = ___GetLabelDelegate(__Instance);
                    var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(___ret);
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }

                set
                {
                    var ___SetLabelDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 6);
                    var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, value);
                    var __arg0 = __basicString0.__Instance;
                    ___SetLabelDelegate(__Instance, __arg0);
                    __basicString0.Dispose();
                }
            }

            /// <summary>Returns the number of actions available at the information set</summary>
            public override int NumActions
            {
                get
                {
                    var ___NumActionsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 9);
                    var ___ret = ___NumActionsDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the actions available at the information set</summary>
            public override global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>> Actions
            {
                get
                {
                    var ___GetActionsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 11);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___GetActionsDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            public override int NumMembers
            {
                get
                {
                    var ___NumMembersDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 12);
                    var ___ret = ___NumMembersDelegate(__Instance);
                    return ___ret;
                }
            }

            public override global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>> Members
            {
                get
                {
                    var ___GetMembersDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 14);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___GetMembersDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }
        }

        public unsafe partial class GameNodeRepInternal : global::gambit.Gambit.GameNodeRep, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal GameNodeRepInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal GameNodeRepInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> GetChild(int i)
            {
                var ___GetChildDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 8);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetChildDelegate(__Instance, new IntPtr(&___ret), i);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> GetChild(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> _0)
            {
                var ___GetChild_1Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 7);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetChild_1Delegate(__Instance, new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep(new __IntPtr(&___ret));
                return _____ret;
            }

            public override bool IsSuccessorOf(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> from)
            {
                var ___IsSuccessorOfDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr___IntPtr>(0, 21);
                if (ReferenceEquals(from, null))
                    throw new global::System.ArgumentNullException("from", "Cannot be null because it is passed by value.");
                var __arg0 = from.__Instance;
                var ___ret = ___IsSuccessorOfDelegate(__Instance, __arg0);
                return ___ret;
            }

            public override void DeleteParent()
            {
                var ___DeleteParentDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr>(0, 23);
                ___DeleteParentDelegate(__Instance);
            }

            public override void DeleteTree()
            {
                var ___DeleteTreeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr>(0, 24);
                ___DeleteTreeDelegate(__Instance);
            }

            public override void CopyTree(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> src)
            {
                var ___CopyTreeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 25);
                if (ReferenceEquals(src, null))
                    throw new global::System.ArgumentNullException("src", "Cannot be null because it is passed by value.");
                var __arg0 = src.__Instance;
                ___CopyTreeDelegate(__Instance, __arg0);
            }

            public override void MoveTree(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> src)
            {
                var ___MoveTreeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 26);
                if (ReferenceEquals(src, null))
                    throw new global::System.ArgumentNullException("src", "Cannot be null because it is passed by value.");
                var __arg0 = src.__Instance;
                ___MoveTreeDelegate(__Instance, __arg0);
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> AppendMove(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> p_player, int p_actions)
            {
                var ___AppendMoveDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr_int>(0, 29);
                if (ReferenceEquals(p_player, null))
                    throw new global::System.ArgumentNullException("p_player", "Cannot be null because it is passed by value.");
                var __arg0 = p_player.__Instance;
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___AppendMoveDelegate(__Instance, new IntPtr(&___ret), __arg0, p_actions);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> AppendMove(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> p_infoset)
            {
                var ___AppendMove_1Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 28);
                if (ReferenceEquals(p_infoset, null))
                    throw new global::System.ArgumentNullException("p_infoset", "Cannot be null because it is passed by value.");
                var __arg0 = p_infoset.__Instance;
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___AppendMove_1Delegate(__Instance, new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> InsertMove(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> p_player, int p_actions)
            {
                var ___InsertMoveDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr_int>(0, 31);
                if (ReferenceEquals(p_player, null))
                    throw new global::System.ArgumentNullException("p_player", "Cannot be null because it is passed by value.");
                var __arg0 = p_player.__Instance;
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___InsertMoveDelegate(__Instance, new IntPtr(&___ret), __arg0, p_actions);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> InsertMove(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> p_infoset)
            {
                var ___InsertMove_1Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 30);
                if (ReferenceEquals(p_infoset, null))
                    throw new global::System.ArgumentNullException("p_infoset", "Cannot be null because it is passed by value.");
                var __arg0 = p_infoset.__Instance;
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___InsertMove_1Delegate(__Instance, new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> Game
            {
                get
                {
                    var ___GetGameDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 1);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetGameDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public override string Label
            {
                get
                {
                    var ___GetLabelDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___GetLabelDelegate(__Instance);
                    var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(___ret);
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }

                set
                {
                    var ___SetLabelDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 3);
                    var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, value);
                    var __arg0 = __basicString0.__Instance;
                    ___SetLabelDelegate(__Instance, __arg0);
                    __basicString0.Dispose();
                }
            }

            public override int Number
            {
                get
                {
                    var ___GetNumberDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 4);
                    var ___ret = ___GetNumberDelegate(__Instance);
                    return ___ret;
                }
            }

            public override int NumberInInfoset
            {
                get
                {
                    var ___NumberInInfosetDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 5);
                    var ___ret = ___NumberInInfosetDelegate(__Instance);
                    return ___ret;
                }
            }

            public override int NumChildren
            {
                get
                {
                    var ___NumChildrenDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 6);
                    var ___ret = ___NumChildrenDelegate(__Instance);
                    return ___ret;
                }
            }

            public override global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>> Children
            {
                get
                {
                    var ___GetChildrenDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 9);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___GetChildrenDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> Infoset
            {
                get
                {
                    var ___GetInfosetDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 10);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetInfosetDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep(new __IntPtr(&___ret));
                    return _____ret;
                }

                set
                {
                    var ___SetInfosetDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 11);
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    var __arg0 = value.__Instance;
                    ___SetInfosetDelegate(__Instance, __arg0);
                }
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> LeaveInfoset
            {
                get
                {
                    var ___LeaveInfosetDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 12);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___LeaveInfosetDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public override bool IsTerminal
            {
                get
                {
                    var ___IsTerminalDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr>(0, 13);
                    var ___ret = ___IsTerminalDelegate(__Instance);
                    return ___ret;
                }
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> Player
            {
                get
                {
                    var ___GetPlayerDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 14);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetPlayerDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> PriorAction
            {
                get
                {
                    var ___GetPriorActionDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 15);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetPriorActionDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> Parent
            {
                get
                {
                    var ___GetParentDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 16);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetParentDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> NextSibling
            {
                get
                {
                    var ___GetNextSiblingDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 17);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetNextSiblingDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> PriorSibling
            {
                get
                {
                    var ___GetPriorSiblingDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 18);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetPriorSiblingDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> Outcome
            {
                get
                {
                    var ___GetOutcomeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 19);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetOutcomeDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameOutcomeRep(new __IntPtr(&___ret));
                    return _____ret;
                }

                set
                {
                    var ___SetOutcomeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 20);
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    ___SetOutcomeDelegate(__Instance, __arg0);
                }
            }

            public override bool IsSubgameRoot
            {
                get
                {
                    var ___IsSubgameRootDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr>(0, 22);
                    var ___ret = ___IsSubgameRootDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Create a separate Game object containing the subgame rooted at the node</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> CopySubgame
            {
                get
                {
                    var ___CopySubgameDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 27);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___CopySubgameDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }
        }

        public unsafe partial class GameRepInternal : global::gambit.Gambit.GameRep, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal GameRepInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal GameRepInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Returns the smallest payoff in any outcome of the game</summary>
            public override global::gambit.Gambit.Rational GetMinPayoff(int pl)
            {
                var ___GetMinPayoffDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 10);
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                ___GetMinPayoffDelegate(__Instance, new IntPtr(&___ret), pl);
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the largest payoff in any outcome of the game</summary>
            public override global::gambit.Gambit.Rational GetMaxPayoff(int pl)
            {
                var ___GetMaxPayoffDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 11);
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                ___GetMaxPayoffDelegate(__Instance, new IntPtr(&___ret), pl);
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>
            /// <para>Returns true if the game is perfect recall.  If not,</para>
            /// <para>a pair of violating information sets is returned in the parameters.</para>
            /// </summary>
            public override bool IsPerfectRecall(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> _0, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> _1)
            {
                var ___IsPerfectRecallDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr___IntPtr___IntPtr>(0, 12);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = ___IsPerfectRecallDelegate(__Instance, __arg0, __arg1);
                return ___ret;
            }

            /// <summary>Gets the i'th strategy in the game, numbered globally</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> GetStrategy(int p_index)
            {
                var ___GetStrategyDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 19);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetStrategyDelegate(__Instance, new IntPtr(&___ret), p_index);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.PureStrategyProfile NewPureStrategyProfile()
            {
                var ___NewPureStrategyProfileDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 23);
                var ___ret = new global::gambit.Gambit.PureStrategyProfile.__Internal();
                ___NewPureStrategyProfileDelegate(__Instance, new IntPtr(&___ret));
                var _____ret = global::gambit.Gambit.PureStrategyProfile.__CreateInstance(___ret);
                global::gambit.Gambit.PureStrategyProfile.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.MixedStrategyProfile<double> NewMixedStrategyProfile(double _0)
            {
                var ___NewMixedStrategyProfileDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_double>(0, 27);
                var ___ret = new global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d();
                ___NewMixedStrategyProfileDelegate(__Instance, new IntPtr(&___ret), _0);
                var _____ret = global::gambit.Gambit.MixedStrategyProfile<double>.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            public override global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational> NewMixedStrategyProfile(global::gambit.Gambit.Rational _0)
            {
                var ___NewMixedStrategyProfile_1Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 26);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = new global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational();
                ___NewMixedStrategyProfile_1Delegate(__Instance, new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            public override global::gambit.Gambit.MixedStrategyProfile<double> NewMixedStrategyProfile(double _0, global::gambit.Gambit.StrategySupportProfile _1)
            {
                var ___NewMixedStrategyProfile_2Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_double___IntPtr>(0, 25);
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = new global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d();
                ___NewMixedStrategyProfile_2Delegate(__Instance, new IntPtr(&___ret), _0, __arg1);
                var _____ret = global::gambit.Gambit.MixedStrategyProfile<double>.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            public override global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational> NewMixedStrategyProfile(global::gambit.Gambit.Rational _0, global::gambit.Gambit.StrategySupportProfile _1)
            {
                var ___NewMixedStrategyProfile_3Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr>(0, 24);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = new global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational();
                ___NewMixedStrategyProfile_3Delegate(__Instance, new IntPtr(&___ret), __arg0, __arg1);
                var _____ret = global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            /// <summary>Returns the pl'th player in the game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> GetPlayer(int pl)
            {
                var ___GetPlayerDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 29);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetPlayerDelegate(__Instance, new IntPtr(&___ret), pl);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Creates a new player in the game, with no moves</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> NewPlayer()
            {
                var ___NewPlayerDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 32);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___NewPlayerDelegate(__Instance, new IntPtr(&___ret));
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the iset'th information set in the game (numbered globally)</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> GetInfoset(int iset)
            {
                var ___GetInfosetDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 33);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetInfosetDelegate(__Instance, new IntPtr(&___ret), iset);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the act'th action in the game (numbered globally)</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> GetAction(int act)
            {
                var ___GetActionDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 36);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetActionDelegate(__Instance, new IntPtr(&___ret), act);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the index'th outcome defined in the game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> GetOutcome(int index)
            {
                var ___GetOutcomeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 38);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetOutcomeDelegate(__Instance, new IntPtr(&___ret), index);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameOutcomeRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Creates a new outcome in the game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> NewOutcome()
            {
                var ___NewOutcomeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 39);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___NewOutcomeDelegate(__Instance, new IntPtr(&___ret));
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameOutcomeRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Deletes the specified outcome from the game</summary>
            public override void DeleteOutcome(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> _0)
            {
                var ___DeleteOutcomeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 40);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                ___DeleteOutcomeDelegate(__Instance, __arg0);
            }

            /// <summary>Set the probability distribution of actions at a chance node</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> SetChanceProbs(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> _0, global::gambit.Gambit.Array<global::gambit.Gambit.Number> _1)
            {
                var ___SetChanceProbsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr>(0, 43);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___SetChanceProbsDelegate(__Instance, new IntPtr(&___ret), __arg0, __arg1);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Create a copy of the game, as a new game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 2);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___CopyDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Returns true if the game has a game tree representation</summary>
            public override bool IsTree
            {
                get
                {
                    var ___IsTreeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr>(0, 3);
                    var ___ret = ___IsTreeDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns true if the game is constant-sum</summary>
            public override bool IsConstSum
            {
                get
                {
                    var ___IsConstSumDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr>(0, 9);
                    var ___ret = ___IsConstSumDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>The number of actions in each information set</summary>
            public override global::gambit.Gambit.PVector<int> NumActions
            {
                get
                {
                    var ___NumActionsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 16);
                    var ___ret = new global::gambit.Gambit.PVector.__Internal();
                    ___NumActionsDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.PVector<int>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>The number of members in each information set</summary>
            public override global::gambit.Gambit.PVector<int> NumMembers
            {
                get
                {
                    var ___NumMembersDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 17);
                    var ___ret = new global::gambit.Gambit.PVector.__Internal();
                    ___NumMembersDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.PVector<int>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>The number of strategies for each player</summary>
            public override global::gambit.Gambit.Array<int> NumStrategies
            {
                get
                {
                    var ___NumStrategiesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 18);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___NumStrategiesDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<int>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>Returns the number of strategy contingencies in the game</summary>
            public override int NumStrategyContingencies
            {
                get
                {
                    var ___NumStrategyContingenciesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 20);
                    var ___ret = ___NumStrategyContingenciesDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the total number of actions in the game</summary>
            public override int BehavProfileLength
            {
                get
                {
                    var ___BehavProfileLengthDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 21);
                    var ___ret = ___BehavProfileLengthDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the total number of strategies in the game</summary>
            public override int MixedProfileLength
            {
                get
                {
                    var ___MixedProfileLengthDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 22);
                    var ___ret = ___MixedProfileLengthDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the number of players in the game</summary>
            public override int NumPlayers
            {
                get
                {
                    var ___NumPlayersDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 28);
                    var ___ret = ___NumPlayersDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the chance (nature) player</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> Chance
            {
                get
                {
                    var ___GetChanceDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 31);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetChanceDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Returns the set of information sets in the game</summary>
            public override global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>> Infosets
            {
                get
                {
                    var ___GetInfosetsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 34);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___GetInfosetsDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>Returns an array with the number of information sets per personal player</summary>
            public override global::gambit.Gambit.Array<int> NumInfosets
            {
                get
                {
                    var ___NumInfosetsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 35);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___NumInfosetsDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<int>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>Returns the number of outcomes defined in the game</summary>
            public override int NumOutcomes
            {
                get
                {
                    var ___NumOutcomesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 37);
                    var ___ret = ___NumOutcomesDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the root node of the game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> Root
            {
                get
                {
                    var ___GetRootDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 41);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetRootDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Returns the number of nodes in the game</summary>
            public override int NumNodes
            {
                get
                {
                    var ___NumNodesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 42);
                    var ___ret = ___NumNodesDelegate(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class game
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?NewTree@Gambit@@YA?AV?$GameObjectPtr@VGameRep@Gambit@@@1@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void NewTree(__IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "?NewTable@Gambit@@YA?AV?$GameObjectPtr@VGameRep@Gambit@@@1@AEBV?$Array@H@1@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void NewTable(__IntPtr @return, __IntPtr p_dim, bool p_sparseOutcomes);
            }

            /// <summary>Factory function to create new game tree</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> NewTree()
            {
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                __Internal.NewTree(new IntPtr(&___ret));
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Factory function to create new game table</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> NewTable(global::gambit.Gambit.Array<int> p_dim, bool p_sparseOutcomes)
            {
                if (ReferenceEquals(p_dim, null))
                    throw new global::System.ArgumentNullException("p_dim", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = p_dim.__Instance;
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                __Internal.NewTable(new IntPtr(&___ret), __arg0, p_sparseOutcomes);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(new __IntPtr(&___ret));
                return _____ret;
            }
        }
    }

    namespace Gambit
    {
        /// <summary>
        /// <para>This class represents a strategy profile on a strategic game.</para>
        /// <para>It specifies exactly one strategy for each player defined on the</para>
        /// <para>game.</para>
        /// </summary>
        public unsafe abstract partial class PureStrategyProfileRep : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 40)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_PureStrategyProfileRep;
                internal global::gambit.Gambit.GameObjectPtr.__Internal m_nfg;
                internal global::gambit.Gambit.Array.__Internal m_profile;
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.PureStrategyProfileRep> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.PureStrategyProfileRep>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.PureStrategyProfileRep managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.PureStrategyProfileRep managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static PureStrategyProfileRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PureStrategyProfileRepInternal(native.ToPointer(), skipVTables);
            }

            internal static PureStrategyProfileRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PureStrategyProfileRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static PureStrategyProfileRep __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (PureStrategyProfileRep)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static PureStrategyProfileRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PureStrategyProfileRepInternal(native, skipVTables);
            }

            protected PureStrategyProfileRep(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Set the strategy for a player</summary>
            public abstract void SetStrategy(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> _0);

            /// <summary>Get the payoff to player pl that results from the profile</summary>
            public abstract global::gambit.Gambit.Rational GetPayoff(int pl);

            /// <summary>Get the value of playing strategy against the profile</summary>
            public abstract global::gambit.Gambit.Rational GetStrategyValue(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> _0);

            protected global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> MNfg
            {
                get
                {
                    return global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_nfg));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->m_nfg = *(global::gambit.Gambit.GameObjectPtr.__Internal*) value.__Instance;
                }
            }

            protected global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>> MProfile
            {
                get
                {
                    return global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_profile));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->m_profile = *(global::gambit.Gambit.Array.__Internal*) value.__Instance;
                }
            }

            /// <summary>
            /// <para>Create a copy of the strategy profile.</para>
            /// <para>Caller is responsible for memory management of the created object.</para>
            /// </summary>
            protected abstract global::gambit.Gambit.PureStrategyProfileRep Copy
            {
                get;
            }

            /// <summary>Get the index uniquely identifying the strategy profile</summary>
            public virtual int Index
            {
                get
                {
                    var ___GetIndexDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 2);
                    var ___ret = ___GetIndexDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the outcome that results from the profile</summary>
            /// <remarks>Set the outcome that results from the profile</remarks>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> Outcome
            {
                get;

                set;
            }

            #region Virtual table interop

            // PureStrategyProfileRep *Copy() const = 0
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _CopyDelegateInstance;

            private static __IntPtr _CopyDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.PureStrategyProfileRep.__GetInstance(__instance);
                var ___ret = __target.Copy;
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // virtual ~PureStrategyProfileRep() = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.PureStrategyProfileRep.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // long GetIndex() const
            private static global::gambit.Delegates.Func_int___IntPtr _GetIndexDelegateInstance;

            private static int _GetIndexDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.PureStrategyProfileRep.__GetInstance(__instance);
                var ___ret = __target.Index;
                return ___ret;
            }

            // void SetStrategy(const GameStrategy &) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetStrategyDelegateInstance;

            private static void _SetStrategyDelegateHook(__IntPtr __instance, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.PureStrategyProfileRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.__GetOrCreateInstance(_0, false);
                __target.SetStrategy(__result0);
            }

            // GameOutcome GetOutcome() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetOutcomeDelegateInstance;

            private static void _GetOutcomeDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.PureStrategyProfileRep.__GetInstance(__instance);
                var ___ret = __target.Outcome;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // void SetOutcome(GameOutcome p_outcome) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetOutcomeDelegateInstance;

            private static void _SetOutcomeDelegateHook(__IntPtr __instance, __IntPtr p_outcome)
            {
                var __target = global::gambit.Gambit.PureStrategyProfileRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.__GetOrCreateInstance(p_outcome, false);
                __target.Outcome = __result0;
            }

            // Rational GetPayoff(int pl) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetPayoffDelegateInstance;

            private static void _GetPayoffDelegateHook(__IntPtr __instance, __IntPtr @return, int pl)
            {
                var __target = global::gambit.Gambit.PureStrategyProfileRep.__GetInstance(__instance);
                var ___ret = __target.GetPayoff(pl);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Rational.__Internal*) @return = *(global::gambit.Gambit.Rational.__Internal*) ___ret.__Instance;
            }

            // Rational GetStrategyValue(const GameStrategy &) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr _GetStrategyValueDelegateInstance;

            private static void _GetStrategyValueDelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.PureStrategyProfileRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.__GetOrCreateInstance(_0, false);
                var ___ret = __target.GetStrategyValue(__result1);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Rational.__Internal*) @return = *(global::gambit.Gambit.Rational.__Internal*) ___ret.__Instance;
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[8];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _CopyDelegateInstance += _CopyDelegateHook;
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetIndexDelegateInstance += _GetIndexDelegateHook;
                    _SetStrategyDelegateInstance += _SetStrategyDelegateHook;
                    _GetOutcomeDelegateInstance += _GetOutcomeDelegateHook;
                    _SetOutcomeDelegateInstance += _SetOutcomeDelegateHook;
                    _GetPayoffDelegateInstance += _GetPayoffDelegateHook;
                    _GetStrategyValueDelegateInstance += _GetStrategyValueDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetIndexDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_SetStrategyDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetOutcomeDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_SetOutcomeDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_GetPayoffDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetStrategyValueDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 8, 0);
                                ManagedVTablesDtorOnly[0][1] = Thunks[1];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 8, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                ManagedVTables[0][7] = Thunks[7];
                                VTables.Methods[0] = new Delegate[8];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class PureStrategyProfile : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr rep;

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "c__N_Gambit_S_PureStrategyProfile__PureStrategyProfile", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.PureStrategyProfile> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.PureStrategyProfile>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.PureStrategyProfile managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.PureStrategyProfile managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static PureStrategyProfile __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PureStrategyProfile(native.ToPointer(), skipVTables);
            }

            internal static PureStrategyProfile __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PureStrategyProfile)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static PureStrategyProfile __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PureStrategyProfile(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private PureStrategyProfile(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected PureStrategyProfile(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        /// <summary>
        /// <para>This class iterates through the contingencies in a strategic game.</para>
        /// <para>It visits each strategy profile in turn, advancing one contingency</para>
        /// <para>on each call of NextContingency().  Optionally, the strategy of</para>
        /// <para>one player may be held fixed during the iteration (by the use of the</para>
        /// <para>second constructor).</para>
        /// </summary>
        public unsafe partial class StrategyProfileIterator : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 104)]
            public partial struct __Internal
            {
                internal byte m_atEnd;
                internal global::gambit.Gambit.StrategySupportProfile.__Internal m_support;
                internal global::gambit.Gambit.Array.__Internal m_currentStrat;
                internal global::gambit.Gambit.PureStrategyProfile.__Internal m_profile;
                internal int m_frozen1;
                internal int m_frozen2;

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "c__N_Gambit_S_StrategyProfileIterator__StrategyProfileIterator", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.StrategyProfileIterator> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.StrategyProfileIterator>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.StrategyProfileIterator managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.StrategyProfileIterator managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static StrategyProfileIterator __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new StrategyProfileIterator(native.ToPointer(), skipVTables);
            }

            internal static StrategyProfileIterator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (StrategyProfileIterator)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static StrategyProfileIterator __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new StrategyProfileIterator(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private StrategyProfileIterator(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected StrategyProfileIterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        public unsafe partial class PureStrategyProfileRepInternal : global::gambit.Gambit.PureStrategyProfileRep, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal PureStrategyProfileRepInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal PureStrategyProfileRepInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Set the strategy for a player</summary>
            public override void SetStrategy(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> _0)
            {
                var ___SetStrategyDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 3);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                ___SetStrategyDelegate(__Instance, __arg0);
            }

            /// <summary>Get the payoff to player pl that results from the profile</summary>
            public override global::gambit.Gambit.Rational GetPayoff(int pl)
            {
                var ___GetPayoffDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 6);
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                ___GetPayoffDelegate(__Instance, new IntPtr(&___ret), pl);
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get the value of playing strategy against the profile</summary>
            public override global::gambit.Gambit.Rational GetStrategyValue(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> _0)
            {
                var ___GetStrategyValueDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 7);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                ___GetStrategyValueDelegate(__Instance, new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>
            /// <para>Create a copy of the strategy profile.</para>
            /// <para>Caller is responsible for memory management of the created object.</para>
            /// </summary>
            protected override global::gambit.Gambit.PureStrategyProfileRep Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr>(0, 0);
                    var ___ret = ___CopyDelegate(__Instance);
                    var __result0 = global::gambit.Gambit.PureStrategyProfileRep.__GetOrCreateInstance(___ret, true);
                    return __result0;
                }
            }

            /// <summary>Get the outcome that results from the profile</summary>
            /// <remarks>Set the outcome that results from the profile</remarks>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> Outcome
            {
                get
                {
                    var ___GetOutcomeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 4);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetOutcomeDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameOutcomeRep(new __IntPtr(&___ret));
                    return _____ret;
                }

                set
                {
                    var ___SetOutcomeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 5);
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    var __arg0 = value.__Instance;
                    ___SetOutcomeDelegate(__Instance, __arg0);
                }
            }
        }
    }

    namespace Gambit
    {
        namespace MixedStrategyProfile
        {
            [StructLayout(LayoutKind.Sequential, Size = 48)]
            public unsafe partial struct __Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational
            {
                internal __IntPtr vfptr_MixedStrategyProfile;
                internal __IntPtr m_rep;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep___N_Gambit_S_Rational___N_std_S_less__S3____N_std_S_allocator____N_std_S_pair__1S3__S5____N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_ map_strategy_payoffs;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_Gambit_S_Rational___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_ map_profile_payoffs;
            }

            [StructLayout(LayoutKind.Sequential, Size = 48)]
            public unsafe partial struct __Internalc__N_Gambit_S_MixedStrategyProfile__d
            {
                internal __IntPtr vfptr_MixedStrategyProfile;
                internal __IntPtr m_rep;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep_d___N_std_S_less__S3____N_std_S_allocator____N_std_S_pair__1S3__d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_ map_strategy_payoffs;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep_d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__d map_profile_payoffs;
            }
        }

        /// <summary>A probability distribution over strategies in a game</summary>
        /// <remarks>
        /// <para>A probability distribution over strategies, such that each player</para>
        /// <para>independently chooses from among his strategies with specified</para>
        /// <para>probabilities.</para>
        /// </remarks>
        public unsafe partial class MixedStrategyProfile<T> : IDisposable
        {
            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.MixedStrategyProfile<T>> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.MixedStrategyProfile<T>>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.MixedStrategyProfile<T> managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.MixedStrategyProfile<T> managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static MixedStrategyProfile<T> __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new MixedStrategyProfile<T>(native.ToPointer(), skipVTables);
            }

            internal static MixedStrategyProfile<T> __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (MixedStrategyProfile<T>)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static MixedStrategyProfile<T> __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (MixedStrategyProfile<T>)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static MixedStrategyProfile<T> __CreateInstance(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational native, bool skipVTables = false)
            {
                return new MixedStrategyProfile<T>(native, skipVTables);
            }

            private static void* __CopyValue(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational));
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) ret = native;
                return ret.ToPointer();
            }

            private MixedStrategyProfile(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal static MixedStrategyProfile<T> __CreateInstance(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d native, bool skipVTables = false)
            {
                return new MixedStrategyProfile<T>(native, skipVTables);
            }

            private static void* __CopyValue(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d));
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) ret = native;
                return ret.ToPointer();
            }

            private MixedStrategyProfile(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected MixedStrategyProfile(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            public MixedStrategyProfile(global::gambit.Gambit.MixedStrategyProfileRep<T> p_rep)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method MixedStrategyProfile_T_ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method MixedStrategyProfile_T_ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Convert a behavior strategy profile to a mixed strategy profile</summary>
            public MixedStrategyProfile(global::gambit.Gambit.MixedBehaviorProfile<T> _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method MixedStrategyProfile_T_ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method MixedStrategyProfile_T_ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Make a copy of the mixed strategy profile</summary>
            public MixedStrategyProfile(global::gambit.Gambit.MixedStrategyProfile<T> _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method MixedStrategyProfile_T_ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method MixedStrategyProfile_T_ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Check underlying game has not changed; raise exception if it has</summary>
            public void CheckVersion()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method CheckVersion ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method CheckVersion ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Test for the equality of two profiles</summary>
            public static bool operator ==(global::gambit.Gambit.MixedStrategyProfile<T> __op, global::gambit.Gambit.MixedStrategyProfile<T> p_profile)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::gambit.Gambit.MixedStrategyProfile<T>;
            }

            public override int GetHashCode()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) __Instance).GetHashCode();
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Test for the inequality of two profiles</summary>
            public static bool operator !=(global::gambit.Gambit.MixedStrategyProfile<T> __op, global::gambit.Gambit.MixedStrategyProfile<T> p_profile)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public static implicit operator global::gambit.Gambit.Vector<T>(global::gambit.Gambit.MixedStrategyProfile<T> __op)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator_const_Vector_type_parameter_0_0___ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator_const_Vector_type_parameter_0_0___ ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Sets all strategies for each player to equal probabilities</summary>
            public void SetCentroid()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method SetCentroid ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method SetCentroid ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>
            /// <para>Create a new mixed strategy profile where strategies are played</para>
            /// <para>in the same proportions, but with probabilities for each player</para>
            /// <para>summing to one.</para>
            /// </summary>
            public global::gambit.Gambit.MixedStrategyProfile<T> Normalize()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method Normalize ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method Normalize ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Converts the profile to one on the full support of the game</summary>
            public global::gambit.Gambit.MixedStrategyProfile<T> ToFullSupport()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method ToFullSupport ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method ToFullSupport ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Used to read payoffs from cache or compute them and cache them if needed</summary>
            public void ComputePayoffs()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method ComputePayoffs ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method ComputePayoffs ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Reset cache for payoffs and strategy values</summary>
            public virtual void InvalidateCache()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    var ___InvalidateCacheDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr>(0, 1);
                    ___InvalidateCacheDelegate(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    var ___InvalidateCacheDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr>(0, 1, 1);
                    ___InvalidateCacheDelegate(__Instance);
                    return;
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Computes the payoff of the profile to player 'pl'</summary>
            public T GetPayoff(int pl)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Computes the payoff of the profile to the player</summary>
            public T GetPayoff(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> p_player)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Computes the derivative of the player's payoff</summary>
            /// <remarks>
            /// <para>Computes the derivative of the payoff to the player with respect</para>
            /// <para>to the probability the strategy is played</para>
            /// </remarks>
            public T GetPayoffDeriv(int pl, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> s)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetPayoffDeriv ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetPayoffDeriv ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Computes the second derivative of the player's payoff</summary>
            /// <remarks>
            /// <para>Computes the second derivative of the payoff to the player,</para>
            /// <para>with respect to the probabilities with which the strategies are played</para>
            /// </remarks>
            public T GetPayoffDeriv(int pl, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> s1, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> s2)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetPayoffDeriv ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetPayoffDeriv ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Computes the payoff to playing the pure strategy against the profile</summary>
            public T GetPayoff(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> p_strategy)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Computes the regret to playing</summary>
            /// <param name="p_strategy">The strategy to compute the regret for.</param>
            /// <remarks>
            /// <para>Computes the regret to the player of playing strategyagainst the profile.  The regret is defined as the difference</para>
            /// <para>between the best-response payoff and the payoff to playing</para>
            /// <para>GetRegret(const GamePlayer&amp;) const;</para>
            /// <para>GetMaxRegret() const</para>
            /// </remarks>
            public T GetRegret(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> p_strategy)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetRegret ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetRegret ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Computes the regret for player</summary>
            /// <param name="p_player">The player to compute the regret for.</param>
            /// <remarks>
            /// <para>Computes the regret to the player of playing their mixed strategy</para>
            /// <para>as specified in the profile.  The regret is defined as the difference</para>
            /// <para>between the player's best-response payoff and the payoff to playing</para>
            /// <para>their specified mixed strategy.</para>
            /// <para>GetRegret(const GameStrategy&amp;) const;</para>
            /// <para>GetMaxRegret() const</para>
            /// </remarks>
            public T GetRegret(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> p_player)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetRegret ignored in specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetRegret ignored in specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public static explicit operator global::gambit.Gambit.MixedStrategyProfile<T>(global::gambit.Gambit.MixedStrategyProfileRep<T> p_rep)
            {
                return new global::gambit.Gambit.MixedStrategyProfile<T>(p_rep);
            }

            public static explicit operator global::gambit.Gambit.MixedStrategyProfile<T>(global::gambit.Gambit.MixedBehaviorProfile<T> _0)
            {
                return new global::gambit.Gambit.MixedStrategyProfile<T>(_0);
            }

            public T this[int i]
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public T this[global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> p_strategy]
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public global::gambit.Gambit.Vector<T> this[global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> p_player]
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            /// <summary>Returns the game on which the profile is defined</summary>
            public global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> Game
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Game missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Game missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            /// <summary>Returns the support on which the profile is defined</summary>
            public global::gambit.Gambit.StrategySupportProfile Support
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Support missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Support missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            /// <summary>Returns whether the profile has been invalidated by a subsequent revision to the game</summary>
            public bool IsInvalidated
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method IsInvalidated missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method IsInvalidated missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            /// <summary>Returns the total number of strategies in the profile</summary>
            public ulong MixedProfileLength
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method MixedProfileLength missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method MixedProfileLength missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            /// <summary>Computes the maximum regret to any player in the profile</summary>
            /// <remarks>
            /// <para>Computes the maximum of the regrets of the players in the profile.</para>
            /// <para>GetRegret(const GamePlayer&amp;) const;</para>
            /// <para>GetRegret(const GameStrategy&amp;) const</para>
            /// </remarks>
            public T MaxRegret
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method MaxRegret missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method MaxRegret missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            /// <summary>Computes the Lyapunov value of the profile</summary>
            /// <remarks>
            /// <para>Computes the Lyapunov value of the profile.  This is a nonnegative</para>
            /// <para>value which is zero exactly at Nash equilibria.  This version</para>
            /// <para>implements a positive penalty for profiles which are not on the</para>
            /// <para>simplotope (useful for penalty-function minimization methods).</para>
            /// </remarks>
            public T LiapValue
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method LiapValue missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method LiapValue missing from explicit specialization global::gambit.Gambit.MixedStrategyProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            #region Virtual table interop

            // virtual ~MixedStrategyProfile()
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.MixedStrategyProfile<T>.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // void InvalidateCache() const
            private static global::gambit.Delegates.Action___IntPtr _InvalidateCacheDelegateInstance;

            private static void _InvalidateCacheDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.MixedStrategyProfile<T>.__GetInstance(__instance);
                __target.InvalidateCache();
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _InvalidateCacheDelegateInstance += _InvalidateCacheDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_InvalidateCacheDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        namespace MixedStrategyProfileRep
        {
            [StructLayout(LayoutKind.Sequential, Size = 96)]
            public unsafe partial struct __Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational
            {
                internal __IntPtr vfptr_MixedStrategyProfileRep;
                internal global::gambit.Gambit.Vector.__Internal m_probs;
                internal global::gambit.Gambit.StrategySupportProfile.__Internal m_support;
                internal uint m_gameversion;

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "c__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational_F_MixedStrategyProfileRep___1__N_Gambit_S_MixedStrategyProfileRep__S0", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational(__IntPtr __instance, __IntPtr _0);
            }

            [StructLayout(LayoutKind.Sequential, Size = 96)]
            public unsafe partial struct __Internalc__N_Gambit_S_MixedStrategyProfileRep__d
            {
                internal __IntPtr vfptr_MixedStrategyProfileRep;
                internal global::gambit.Gambit.Vector.__Internal m_probs;
                internal global::gambit.Gambit.StrategySupportProfile.__Internal m_support;
                internal uint m_gameversion;

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "c__N_Gambit_S_MixedStrategyProfileRep__d_F_MixedStrategyProfileRep___1__N_Gambit_S_MixedStrategyProfileRep__d", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_Gambit_S_MixedStrategyProfileRep__d(__IntPtr __instance, __IntPtr _0);
            }
        }

        public unsafe abstract partial class MixedStrategyProfileRep<T> : IDisposable
        {
            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.MixedStrategyProfileRep<T>> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.MixedStrategyProfileRep<T>>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.MixedStrategyProfileRep<T> managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.MixedStrategyProfileRep<T> managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static MixedStrategyProfileRep<T> __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new MixedStrategyProfileRepInternal<T>(native.ToPointer(), skipVTables);
            }

            internal static MixedStrategyProfileRep<T> __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (MixedStrategyProfileRep<T>)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static MixedStrategyProfileRep<T> __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (MixedStrategyProfileRep<T>)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static MixedStrategyProfileRep<T> __CreateInstance(global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational native, bool skipVTables = false)
            {
                return new MixedStrategyProfileRepInternal<T>(native, skipVTables);
            }

            internal static MixedStrategyProfileRep<T> __CreateInstance(global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d native, bool skipVTables = false)
            {
                return new MixedStrategyProfileRepInternal<T>(native, skipVTables);
            }

            protected MixedStrategyProfileRep(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected MixedStrategyProfileRep(global::gambit.Gambit.StrategySupportProfile _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method MixedStrategyProfileRep_T_ ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method MixedStrategyProfileRep_T_ ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void SetCentroid()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method SetCentroid ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method SetCentroid ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public global::gambit.Gambit.MixedStrategyProfileRep<T> Normalize()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method Normalize ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method Normalize ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public abstract T GetPayoff(int pl);

            public abstract T GetPayoffDeriv(int pl, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> _0);

            public abstract T GetPayoffDeriv(int pl, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> _0, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> _1);

            public T GetPayoff(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> p_player)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T GetPayoff(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> p_strategy)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T GetRegret(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetRegret ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetRegret ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T GetRegret(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetRegret ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetRegret ignored in specialization global::gambit.Gambit.MixedStrategyProfileRep<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public virtual void InvalidateCache()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    var ___InvalidateCacheDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr>(0, 5);
                    ___InvalidateCacheDelegate(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    var ___InvalidateCacheDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr>(0, 5, 1);
                    ___InvalidateCacheDelegate(__Instance);
                    return;
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T this[global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> p_strategy]
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfileRep<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedStrategyProfileRep<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public global::gambit.Gambit.Vector<T> MProbs
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        return (global::gambit.Gambit.Vector<T>) (object) global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.__CreateInstance(new __IntPtr(&((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational*)__Instance)->m_probs));
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        return (global::gambit.Gambit.Vector<T>) (object) global::gambit.Gambit.Vector<double>.__CreateInstance(new __IntPtr(&((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d*)__Instance)->m_probs));
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational*)__Instance)->m_probs = *(global::gambit.Gambit.Vector.__Internal*) value.__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d*)__Instance)->m_probs = *(global::gambit.Gambit.Vector.__Internal*) value.__Instance;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public global::gambit.Gambit.StrategySupportProfile MSupport
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        return global::gambit.Gambit.StrategySupportProfile.__CreateInstance(new __IntPtr(&((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational*)__Instance)->m_support));
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        return global::gambit.Gambit.StrategySupportProfile.__CreateInstance(new __IntPtr(&((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d*)__Instance)->m_support));
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational*)__Instance)->m_support = *(global::gambit.Gambit.StrategySupportProfile.__Internal*) value.__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d*)__Instance)->m_support = *(global::gambit.Gambit.StrategySupportProfile.__Internal*) value.__Instance;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public uint MGameversion
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        return ((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational*)__Instance)->m_gameversion;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        return ((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d*)__Instance)->m_gameversion;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        ((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational*)__Instance)->m_gameversion = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        ((global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d*)__Instance)->m_gameversion = value;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public abstract global::gambit.Gambit.MixedStrategyProfileRep<T> Copy
            {
                get;
            }

            public T MaxRegret
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method MaxRegret missing from explicit specialization global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method MaxRegret missing from explicit specialization global::gambit.Gambit.MixedStrategyProfileRep<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRep<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            #region Virtual table interop

            // virtual ~MixedStrategyProfileRep() = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.MixedStrategyProfileRep<T>.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // MixedStrategyProfileRep<T> *Copy() const = 0
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _CopyDelegateInstance;

            private static __IntPtr _CopyDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.MixedStrategyProfileRep<T>.__GetInstance(__instance);
                var ___ret = __target.Copy;
                return ___ret is null ? __IntPtr.Zero : ___ret.__Instance;
            }

            // T GetPayoff(int pl) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetPayoffDelegateInstance;

            private static void _GetPayoffDelegateHook(__IntPtr __instance, __IntPtr @return, int pl)
            {
                var __target = global::gambit.Gambit.MixedStrategyProfileRep<T>.__GetInstance(__instance);
                var ___ret = __target.GetPayoff(pl);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Rational.__Internal*) @return = *(global::gambit.Gambit.Rational.__Internal*) ((global::gambit.Gambit.Rational) (object) ___ret).__Instance;
            }

            // T GetPayoffDeriv(int pl, const GameStrategy &, const GameStrategy &) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int___IntPtr___IntPtr _GetPayoffDeriv_1DelegateInstance;

            private static void _GetPayoffDeriv_1DelegateHook(__IntPtr __instance, __IntPtr @return, int pl, __IntPtr _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.MixedStrategyProfileRep<T>.__GetInstance(__instance);
                var __result2 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.__GetOrCreateInstance(_0, false);
                var __result3 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.__GetOrCreateInstance(_1, false);
                var ___ret = __target.GetPayoffDeriv(pl, __result2, __result3);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Rational.__Internal*) @return = *(global::gambit.Gambit.Rational.__Internal*) ((global::gambit.Gambit.Rational) (object) ___ret).__Instance;
            }

            // T GetPayoffDeriv(int pl, const GameStrategy &) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int___IntPtr _GetPayoffDerivDelegateInstance;

            private static void _GetPayoffDerivDelegateHook(__IntPtr __instance, __IntPtr @return, int pl, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.MixedStrategyProfileRep<T>.__GetInstance(__instance);
                var __result2 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.__GetOrCreateInstance(_0, false);
                var ___ret = __target.GetPayoffDeriv(pl, __result2);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Rational.__Internal*) @return = *(global::gambit.Gambit.Rational.__Internal*) ((global::gambit.Gambit.Rational) (object) ___ret).__Instance;
            }

            // void InvalidateCache() const
            private static global::gambit.Delegates.Action___IntPtr _InvalidateCacheDelegateInstance;

            private static void _InvalidateCacheDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.MixedStrategyProfileRep<T>.__GetInstance(__instance);
                __target.InvalidateCache();
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[6];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    _GetPayoffDelegateInstance += _GetPayoffDelegateHook;
                    _GetPayoffDeriv_1DelegateInstance += _GetPayoffDeriv_1DelegateHook;
                    _GetPayoffDerivDelegateInstance += _GetPayoffDerivDelegateHook;
                    _InvalidateCacheDelegateInstance += _InvalidateCacheDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetPayoffDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPayoffDeriv_1DelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetPayoffDerivDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_InvalidateCacheDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                VTables.Methods[0] = new Delegate[6];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class MixedStrategyProfileRepInternal<T> : global::gambit.Gambit.MixedStrategyProfileRep<T>, IDisposable
        {
            private static void* __CopyValue(global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational));
                *(global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational*) ret = native;
                return ret.ToPointer();
            }

            internal MixedStrategyProfileRepInternal(global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep____N_Gambit_S_Rational native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            private static void* __CopyValue(global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d));
                *(global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d*) ret = native;
                return ret.ToPointer();
            }

            internal MixedStrategyProfileRepInternal(global::gambit.Gambit.MixedStrategyProfileRep.__Internalc__N_Gambit_S_MixedStrategyProfileRep__d native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal MixedStrategyProfileRepInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override T GetPayoff(int pl)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    var ___GetPayoffDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 2);
                    var ___ret = new global::gambit.Gambit.Rational.__Internal();
                    ___GetPayoffDelegate(__Instance, new IntPtr(&___ret), pl);
                    var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                    global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    var ___GetPayoffDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_double___IntPtr_int>(0, 2);
                    var ___ret = ___GetPayoffDelegate(__Instance, pl);
                    return ___ret;
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRepInternal<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public override T GetPayoffDeriv(int pl, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    var ___GetPayoffDerivDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int___IntPtr>(0, 4);
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = _0.__Instance;
                    var ___ret = new global::gambit.Gambit.Rational.__Internal();
                    ___GetPayoffDerivDelegate(__Instance, new IntPtr(&___ret), pl, __arg1);
                    var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                    global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    var ___GetPayoffDerivDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_double___IntPtr_int___IntPtr>(0, 4);
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = _0.__Instance;
                    var ___ret = ___GetPayoffDerivDelegate(__Instance, pl, __arg1);
                    return ___ret;
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRepInternal<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public override T GetPayoffDeriv(int pl, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> _0, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> _1)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    var ___GetPayoffDeriv_1Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int___IntPtr___IntPtr>(0, 3);
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = _0.__Instance;
                    if (ReferenceEquals(_1, null))
                        throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                    var __arg2 = _1.__Instance;
                    var ___ret = new global::gambit.Gambit.Rational.__Internal();
                    ___GetPayoffDeriv_1Delegate(__Instance, new IntPtr(&___ret), pl, __arg1, __arg2);
                    var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                    global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    var ___GetPayoffDeriv_1Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_double___IntPtr_int___IntPtr___IntPtr>(0, 3);
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = _0.__Instance;
                    if (ReferenceEquals(_1, null))
                        throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                    var __arg2 = _1.__Instance;
                    var ___ret = ___GetPayoffDeriv_1Delegate(__Instance, pl, __arg1, __arg2);
                    return ___ret;
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRepInternal<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public override global::gambit.Gambit.MixedStrategyProfileRep<T> Copy
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        var ___CopyDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr>(0, 1);
                        var ___ret = ___CopyDelegate(__Instance);
                        var __result0 = global::gambit.Gambit.MixedStrategyProfileRep<global::gambit.Gambit.Rational>.__GetOrCreateInstance(___ret, true);
                        return (global::gambit.Gambit.MixedStrategyProfileRep<T>) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        var ___CopyDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr>(0, 1);
                        var ___ret = ___CopyDelegate(__Instance);
                        var __result0 = global::gambit.Gambit.MixedStrategyProfileRep<double>.__GetOrCreateInstance(___ret, true);
                        return (global::gambit.Gambit.MixedStrategyProfileRep<T>) (object) __result0;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedStrategyProfileRepInternal<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }
        }
    }

    namespace Gambit
    {
        /// <summary>A support on a strategic game</summary>
        /// <remarks>
        /// <para>This class represents a subset of the strategies in strategic game.</para>
        /// <para>It is enforced that each player has at least one strategy; thus,</para>
        /// <para>the strategies in a support can be viewed as a restriction of a game</para>
        /// <para>to a subset of its strategies.  This is useful for eliminating</para>
        /// <para>dominated strategies from consideration, and in computational</para>
        /// <para>approaches that enumerate possible equilibrium supports.</para>
        /// <para>Within the support, strategies are maintained in the same order</para>
        /// <para>in which they appear in the underlying game.</para>
        /// </remarks>
        public unsafe partial class StrategySupportProfile : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 56)]
            public partial struct __Internal
            {
                internal global::gambit.Gambit.GameObjectPtr.__Internal m_nfg;
                internal global::gambit.Gambit.Array.__Internal m_support;
                internal global::gambit.Gambit.Array.__Internal m_profileIndex;

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "c__N_Gambit_S_StrategySupportProfile__StrategySupportProfile", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);
            }

            public unsafe partial class Iterator : IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 16)]
                public partial struct __Internal
                {
                    internal __IntPtr support;
                    internal int pl;
                    internal int strat;

                    [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "??0iterator@StrategySupportProfile@Gambit@@QEAA@AEBV012@@Z", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.StrategySupportProfile.Iterator> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.StrategySupportProfile.Iterator>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.StrategySupportProfile.Iterator managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.StrategySupportProfile.Iterator managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static Iterator __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new Iterator(native.ToPointer(), skipVTables);
                }

                internal static Iterator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (Iterator)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static Iterator __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new Iterator(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Iterator(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected Iterator(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public Iterator(global::gambit.Gambit.StrategySupportProfile.Iterator _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.StrategySupportProfile.Iterator.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    *((global::gambit.Gambit.StrategySupportProfile.Iterator.__Internal*) __Instance) = *((global::gambit.Gambit.StrategySupportProfile.Iterator.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.StrategySupportProfile> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.StrategySupportProfile>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.StrategySupportProfile managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.StrategySupportProfile managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static StrategySupportProfile __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new StrategySupportProfile(native.ToPointer(), skipVTables);
            }

            internal static StrategySupportProfile __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (StrategySupportProfile)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static StrategySupportProfile __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new StrategySupportProfile(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private StrategySupportProfile(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected StrategySupportProfile(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            protected global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> MNfg
            {
                get
                {
                    return global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_nfg));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->m_nfg = *(global::gambit.Gambit.GameObjectPtr.__Internal*) value.__Instance;
                }
            }

            protected global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>> MSupport
            {
                get
                {
                    return global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_support));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->m_support = *(global::gambit.Gambit.Array.__Internal*) value.__Instance;
                }
            }

            /// <summary>The index into a strategy profile for a strategy (-1 if not in support)</summary>
            protected global::gambit.Gambit.Array<int> MProfileIndex
            {
                get
                {
                    return global::gambit.Gambit.Array<int>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_profileIndex));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->m_profileIndex = *(global::gambit.Gambit.Array.__Internal*) value.__Instance;
                }
            }
        }
    }

    namespace Gambit
    {
        namespace MixedBehaviorProfile
        {
            [StructLayout(LayoutKind.Sequential, Size = 280)]
            public unsafe partial struct __Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational
            {
                internal global::gambit.Gambit.DVector.__Internal m_probs;
                internal global::gambit.Gambit.BehaviorSupportProfile.__Internal m_support;
                internal uint m_gameversion;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_Gambit_S_Rational___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_ map_realizProbs;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_Gambit_S_Rational___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_ map_beliefs;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_Gambit_S_Rational___N_std_S_less__S3____N_std_S_allocator____N_std_S_pair__1S3__S5____N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_ map_nodeValues;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep___N_Gambit_S_Rational___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_ map_infosetValues;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep___N_Gambit_S_Rational___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_ map_actionValues;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep___N_Gambit_S_Rational___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_ map_regret;

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "c__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational_F__MixedBehaviorProfile", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtorc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational(__IntPtr __instance);
            }

            [StructLayout(LayoutKind.Sequential, Size = 280)]
            public unsafe partial struct __Internalc__N_Gambit_S_MixedBehaviorProfile__d
            {
                internal global::gambit.Gambit.DVector.__Internal m_probs;
                internal global::gambit.Gambit.BehaviorSupportProfile.__Internal m_support;
                internal uint m_gameversion;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep_d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__d map_realizProbs;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep_d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__d map_beliefs;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep_d___N_std_S_less__S3____N_std_S_allocator____N_std_S_pair__1S3__d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_ map_nodeValues;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep_d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__d map_infosetValues;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep_d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__d map_actionValues;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep_d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__d map_regret;

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "c__N_Gambit_S_MixedBehaviorProfile__d_F__MixedBehaviorProfile", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtorc__N_Gambit_S_MixedBehaviorProfile__d(__IntPtr __instance);
            }
        }

        /// <summary>
        /// <para>MixedBehaviorProfileimplements a randomized behavior profile on</para>
        /// <para>an extensive game.</para>
        /// </summary>
        public unsafe partial class MixedBehaviorProfile<T> : IDisposable
        {
            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.MixedBehaviorProfile<T>> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.MixedBehaviorProfile<T>>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.MixedBehaviorProfile<T> managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.MixedBehaviorProfile<T> managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static MixedBehaviorProfile<T> __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new MixedBehaviorProfile<T>(native.ToPointer(), skipVTables);
            }

            internal static MixedBehaviorProfile<T> __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (MixedBehaviorProfile<T>)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static MixedBehaviorProfile<T> __CreateInstance(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational native, bool skipVTables = false)
            {
                return new MixedBehaviorProfile<T>(native, skipVTables);
            }

            private static void* __CopyValue(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational));
                *(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational*) ret = native;
                return ret.ToPointer();
            }

            private MixedBehaviorProfile(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal static MixedBehaviorProfile<T> __CreateInstance(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d native, bool skipVTables = false)
            {
                return new MixedBehaviorProfile<T>(native, skipVTables);
            }

            private static void* __CopyValue(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d));
                *(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d*) ret = native;
                return ret.ToPointer();
            }

            private MixedBehaviorProfile(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected MixedBehaviorProfile(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public MixedBehaviorProfile(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method MixedBehaviorProfile_T_ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method MixedBehaviorProfile_T_ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public MixedBehaviorProfile(global::gambit.Gambit.BehaviorSupportProfile _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method MixedBehaviorProfile_T_ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method MixedBehaviorProfile_T_ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public MixedBehaviorProfile(global::gambit.Gambit.MixedBehaviorProfile<T> _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method MixedBehaviorProfile_T_ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method MixedBehaviorProfile_T_ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public MixedBehaviorProfile(global::gambit.Gambit.MixedStrategyProfile<T> _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method MixedBehaviorProfile_T_ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method MixedBehaviorProfile_T_ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            protected void ComputePass1_realizProbs(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> node)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method ComputePass1_realizProbs ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method ComputePass1_realizProbs ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            protected void ComputePass2_beliefs_nodeValues_actionValues(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> node)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method ComputePass2_beliefs_nodeValues_actionValues ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method ComputePass2_beliefs_nodeValues_actionValues ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            protected void ComputePass3_infosetValues_regret()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method ComputePass3_infosetValues_regret ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method ComputePass3_infosetValues_regret ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            protected void ComputeSolutionData()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method ComputeSolutionData ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method ComputeSolutionData ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Check underlying game has not changed; raise exception if it has</summary>
            protected void CheckVersion()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method CheckVersion ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method CheckVersion ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public static bool operator ==(global::gambit.Gambit.MixedBehaviorProfile<T> __op, global::gambit.Gambit.MixedBehaviorProfile<T> _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::gambit.Gambit.MixedBehaviorProfile<T>;
            }

            public override int GetHashCode()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d*) __Instance).GetHashCode();
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public static bool operator !=(global::gambit.Gambit.MixedBehaviorProfile<T> __op, global::gambit.Gambit.MixedBehaviorProfile<T> x)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public static bool operator ==(global::gambit.Gambit.MixedBehaviorProfile<T> __op, global::gambit.Gambit.DVector<T> x)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public static bool operator !=(global::gambit.Gambit.MixedBehaviorProfile<T> __op, global::gambit.Gambit.DVector<T> x)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public static implicit operator global::gambit.Gambit.Vector<T>(global::gambit.Gambit.MixedBehaviorProfile<T> __op)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator_const_Vector_type_parameter_0_0___ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator_const_Vector_type_parameter_0_0___ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>
            /// <para>Force recomputation of stored quantities</para>
            /// <para>The validity of all caches is determined by the existence of the root node in the</para>
            /// <para>primary cache (first to be computed) map_realizProbs</para>
            /// <para>We also clear</para>
            /// <para>map_nodeValues, map_actionValues</para>
            /// <para>as otherwise we would need to reset them to 0 while populating them</para>
            /// </summary>
            public void InvalidateCache()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method InvalidateCache ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method InvalidateCache ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Set the profile to the centroid</summary>
            public void SetCentroid()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method SetCentroid ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method SetCentroid ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Set the behavior at any undefined information set to the centroid</summary>
            public void UndefinedToCentroid()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method UndefinedToCentroid ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method UndefinedToCentroid ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>
            /// <para>Create a new behaviour strategy profile where strategies are played</para>
            /// <para>in the same proportions, but with probabilities for each player</para>
            /// <para>summing to one.</para>
            /// </summary>
            public global::gambit.Gambit.MixedBehaviorProfile<T> Normalize()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method Normalize ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method Normalize ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public bool IsDefinedAt(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> p_infoset)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method IsDefinedAt ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method IsDefinedAt ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T GetPayoff(int p_player)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T GetPayoff(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> p_player)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T GetInfosetProb(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> iset)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetInfosetProb ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetInfosetProb ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public global::gambit.Gambit.Vector<T> GetPayoff(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> node)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T GetActionProb(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> act)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetActionProb ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetActionProb ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Computes the regret at information set</summary>
            /// <param name="p_infoset">The information set to compute the regret at.</param>
            /// <remarks>
            /// <para>Computes the regret at the information set to the player of playing</para>
            /// <para>their mixed action as specified in the profile.  The regret is defined</para>
            /// <para>as the difference between the payoff of the best response action and</para>
            /// <para>the payoff to playing their specified mixed action.</para>
            /// <para>GetRegret(const GameAction&amp;) const;</para>
            /// <para>GetMaxRegret() const</para>
            /// </remarks>
            public T GetRegret(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> p_infoset)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetRegret ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetRegret ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T DiffActionValue(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> action, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> oppAction)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method DiffActionValue ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method DiffActionValue ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T DiffRealizProb(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> node, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> oppAction)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method DiffRealizProb ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method DiffRealizProb ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T DiffNodeValue(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> node, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> player, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> oppAction)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method DiffNodeValue ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method DiffNodeValue ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public global::gambit.Gambit.MixedStrategyProfile<T> ToMixedProfile()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method ToMixedProfile ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method ToMixedProfile ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public static explicit operator global::gambit.Gambit.MixedBehaviorProfile<T>(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> _0)
            {
                return new global::gambit.Gambit.MixedBehaviorProfile<T>(_0);
            }

            public static explicit operator global::gambit.Gambit.MixedBehaviorProfile<T>(global::gambit.Gambit.BehaviorSupportProfile _0)
            {
                return new global::gambit.Gambit.MixedBehaviorProfile<T>(_0);
            }

            public static explicit operator global::gambit.Gambit.MixedBehaviorProfile<T>(global::gambit.Gambit.MixedStrategyProfile<T> _0)
            {
                return new global::gambit.Gambit.MixedBehaviorProfile<T>(_0);
            }

            public T this[global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> p_action]
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public T this[int a]
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            protected global::gambit.Gambit.DVector<T> MProbs
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        return (global::gambit.Gambit.DVector<T>) (object) global::gambit.Gambit.DVector<global::gambit.Gambit.Rational>.__CreateInstance(new __IntPtr(&((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational*)__Instance)->m_probs));
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        return (global::gambit.Gambit.DVector<T>) (object) global::gambit.Gambit.DVector<double>.__CreateInstance(new __IntPtr(&((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d*)__Instance)->m_probs));
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational*)__Instance)->m_probs = *(global::gambit.Gambit.DVector.__Internal*) value.__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d*)__Instance)->m_probs = *(global::gambit.Gambit.DVector.__Internal*) value.__Instance;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            protected global::gambit.Gambit.BehaviorSupportProfile MSupport
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        return global::gambit.Gambit.BehaviorSupportProfile.__CreateInstance(new __IntPtr(&((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational*)__Instance)->m_support));
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        return global::gambit.Gambit.BehaviorSupportProfile.__CreateInstance(new __IntPtr(&((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d*)__Instance)->m_support));
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational*)__Instance)->m_support = *(global::gambit.Gambit.BehaviorSupportProfile.__Internal*) value.__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d*)__Instance)->m_support = *(global::gambit.Gambit.BehaviorSupportProfile.__Internal*) value.__Instance;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            protected uint MGameversion
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        return ((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational*)__Instance)->m_gameversion;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        return ((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d*)__Instance)->m_gameversion;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        ((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational*)__Instance)->m_gameversion = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        ((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d*)__Instance)->m_gameversion = value;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public ulong BehaviorProfileLength
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method BehaviorProfileLength missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method BehaviorProfileLength missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> Game
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Game missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Game missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public global::gambit.Gambit.BehaviorSupportProfile Support
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Support missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Support missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            /// <summary>Returns whether the profile has been invalidated by a subsequent revision to the game</summary>
            public bool IsInvalidated
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method IsInvalidated missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method IsInvalidated missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public T LiapValue
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method LiapValue missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method LiapValue missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            /// <summary>Computes the maximum regret at any information set in the profile</summary>
            /// <remarks>
            /// <para>Computes the maximum of the regrets of the information sets in the profile.</para>
            /// <para>GetRegret(const GameInfoset&amp;) const;</para>
            /// <para>GetRegret(const GameAction&amp;) const</para>
            /// </remarks>
            public T MaxRegret
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method MaxRegret missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method MaxRegret missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }
        }

        public unsafe static partial class MixedBehaviorProfileExtensions
        {
            public partial struct __Internal
            {
            }
        }
    }

    namespace Gambit
    {
        /// <summary>
        /// <para>This class represents a subset of the actions in an extensive game.</para>
        /// <para>It is enforced that each player has at least one action at each</para>
        /// <para>information set; thus, the actions in a support can be viewed as</para>
        /// <para>a restriction of a game to a subset of its actions.  This is useful</para>
        /// <para>for eliminating dominated strategies from consideration, and in</para>
        /// <para>computational approaches that enumerate possible equilibrium</para>
        /// <para>supports.</para>
        /// </summary>
        public unsafe partial class BehaviorSupportProfile : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 64)]
            public partial struct __Internal
            {
                internal global::gambit.Gambit.GameObjectPtr.__Internal m_efg;
                internal global::gambit.Gambit.Array.__Internal m_actions;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep_b___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__b m_infosetReachable;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep_b___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__b m_nonterminalReachable;

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "??1BehaviorSupportProfile@Gambit@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.BehaviorSupportProfile> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.BehaviorSupportProfile>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.BehaviorSupportProfile managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.BehaviorSupportProfile managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static BehaviorSupportProfile __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new BehaviorSupportProfile(native.ToPointer(), skipVTables);
            }

            internal static BehaviorSupportProfile __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (BehaviorSupportProfile)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static BehaviorSupportProfile __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new BehaviorSupportProfile(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private BehaviorSupportProfile(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected BehaviorSupportProfile(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            protected global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> MEfg
            {
                get
                {
                    return global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_efg));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->m_efg = *(global::gambit.Gambit.GameObjectPtr.__Internal*) value.__Instance;
                }
            }

            protected global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>> MActions
            {
                get
                {
                    return global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_actions));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->m_actions = *(global::gambit.Gambit.Array.__Internal*) value.__Instance;
                }
            }
        }
    }

    namespace Gambit
    {
        /// <summary>Abstract base class for objects that write games to various formats</summary>
        public unsafe abstract partial class GameWriter : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_GameWriter;
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.GameWriter> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.GameWriter>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.GameWriter managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.GameWriter managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static GameWriter __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameWriterInternal(native.ToPointer(), skipVTables);
            }

            internal static GameWriter __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameWriter)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static GameWriter __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GameWriter)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GameWriter __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameWriterInternal(native, skipVTables);
            }

            protected GameWriter(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Convert the game to a string-based representation</summary>
            public abstract string Write(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> _0);

            #region Virtual table interop

            // std::string Write(const Game &) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr _WriteDelegateInstance;

            private static void _WriteDelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameWriter.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__GetOrCreateInstance(_0, false);
                var ___ret = __target.Write(__result1);
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _WriteDelegateInstance += _WriteDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                                if (destructorOnly)
                                    return VTables;
                            }
                        }
                    }

                    *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Format the strategic representation of a game to HTML tables.</summary>
        public unsafe partial class HTMLGameWriter : global::gambit.Gambit.GameWriter, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_GameWriter;
            }

            internal static new HTMLGameWriter __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new HTMLGameWriter(native.ToPointer(), skipVTables);
            }

            internal static new HTMLGameWriter __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (HTMLGameWriter)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new HTMLGameWriter __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (HTMLGameWriter)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static HTMLGameWriter __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new HTMLGameWriter(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private HTMLGameWriter(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected HTMLGameWriter(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
            }

            /// <summary>
            /// <para>Convert the game to HTML, with player 1 on the rows and player 2</para>
            /// <para>on the columns.</para>
            /// </summary>
            public override string Write(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> p_game)
            {
                var ___WriteDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 0);
                if (ReferenceEquals(p_game, null))
                    throw new global::System.ArgumentNullException("p_game", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = p_game.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___WriteDelegate(__Instance, new IntPtr(&___ret), __arg0);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            #region Virtual table interop

            // std::string Write(const Game &p_game) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr _WriteDelegateInstance;

            private static void _WriteDelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr p_game)
            {
                var __target = global::gambit.Gambit.HTMLGameWriter.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__GetOrCreateInstance(p_game, false);
                var ___ret = __target.Write(__result1);
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _WriteDelegateInstance += _WriteDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                                if (destructorOnly)
                                    return VTables;
                            }
                        }
                    }

                    *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Format the strategic representation of a game to LaTeX sgame style</summary>
        public unsafe partial class LaTeXGameWriter : global::gambit.Gambit.GameWriter, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_GameWriter;
            }

            internal static new LaTeXGameWriter __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new LaTeXGameWriter(native.ToPointer(), skipVTables);
            }

            internal static new LaTeXGameWriter __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (LaTeXGameWriter)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new LaTeXGameWriter __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (LaTeXGameWriter)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static LaTeXGameWriter __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new LaTeXGameWriter(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private LaTeXGameWriter(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected LaTeXGameWriter(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
            }

            /// <summary>
            /// <para>Convert the game to LaTeX, with player 1 on the rows and player 2</para>
            /// <para>on the columns.</para>
            /// </summary>
            public override string Write(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> p_game)
            {
                var ___WriteDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 0);
                if (ReferenceEquals(p_game, null))
                    throw new global::System.ArgumentNullException("p_game", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = p_game.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___WriteDelegate(__Instance, new IntPtr(&___ret), __arg0);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            #region Virtual table interop

            // std::string Write(const Game &p_game) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr _WriteDelegateInstance;

            private static void _WriteDelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr p_game)
            {
                var __target = global::gambit.Gambit.LaTeXGameWriter.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__GetOrCreateInstance(p_game, false);
                var ___ret = __target.Write(__result1);
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _WriteDelegateInstance += _WriteDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                                if (destructorOnly)
                                    return VTables;
                            }
                        }
                    }

                    *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class GameWriterInternal : global::gambit.Gambit.GameWriter, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal GameWriterInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal GameWriterInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Convert the game to a string-based representation</summary>
            public override string Write(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> _0)
            {
                var ___WriteDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 0);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___WriteDelegate(__Instance, new IntPtr(&___ret), __arg0);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }
        }
    }

    namespace Gambit
    {
        /// <summary>
        /// <para>This class represents a behavior profile on an extensive game.</para>
        /// <para>It specifies exactly one strategy for each information set in the</para>
        /// <para>game.</para>
        /// </summary>
        public unsafe partial class PureBehaviorProfile : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public partial struct __Internal
            {
                internal global::gambit.Gambit.GameObjectPtr.__Internal m_efg;
                internal global::gambit.Gambit.Array.__Internal m_profile;

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "c__N_Gambit_S_PureBehaviorProfile__PureBehaviorProfile", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.PureBehaviorProfile> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.PureBehaviorProfile>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.PureBehaviorProfile managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.PureBehaviorProfile managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static PureBehaviorProfile __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PureBehaviorProfile(native.ToPointer(), skipVTables);
            }

            internal static PureBehaviorProfile __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PureBehaviorProfile)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static PureBehaviorProfile __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PureBehaviorProfile(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private PureBehaviorProfile(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected PureBehaviorProfile(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        public unsafe partial class BehaviorProfileIterator : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 216)]
            public partial struct __Internal
            {
                internal byte m_atEnd;
                internal global::gambit.Gambit.BehaviorSupportProfile.__Internal m_support;
                internal global::gambit.Gambit.PVector.__Internal m_currentBehav;
                internal global::gambit.Gambit.PureBehaviorProfile.__Internal m_profile;
                internal int m_frozenPlayer;
                internal int m_frozenInfoset;
                internal global::gambit.Gambit.Array.__Internal m_isActive;
                internal global::gambit.Gambit.Array.__Internal m_numActiveInfosets;

                [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "c__N_Gambit_S_BehaviorProfileIterator__BehaviorProfileIterator", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.BehaviorProfileIterator> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.BehaviorProfileIterator>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.BehaviorProfileIterator managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.BehaviorProfileIterator managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static BehaviorProfileIterator __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new BehaviorProfileIterator(native.ToPointer(), skipVTables);
            }

            internal static BehaviorProfileIterator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (BehaviorProfileIterator)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static BehaviorProfileIterator __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new BehaviorProfileIterator(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private BehaviorProfileIterator(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected BehaviorProfileIterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }
    }

    namespace Gambit
    {
        namespace Agg
        {
            public enum TypeEnum
            {
                P_SUM = 0,
                P_EXIST = 1,
                P_HIGH = 2,
                P_LOW = 3,
                P_SUM2 = 10,
                P_EXIST2 = 11,
                P_HIGH2 = 12,
                P_LOW2 = 13
            }

            public unsafe abstract partial class ProjFunc : IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public partial struct __Internal
                {
                    internal __IntPtr vfptr_proj_func;
                    internal global::gambit.Gambit.Agg.TypeEnum Type;
                    internal int Default;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I weights;
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Agg.ProjFunc> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Agg.ProjFunc>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.Agg.ProjFunc managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.Agg.ProjFunc managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static ProjFunc __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new ProjFuncInternal(native.ToPointer(), skipVTables);
                }

                internal static ProjFunc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (ProjFunc)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static ProjFunc __GetInstance(__IntPtr native)
                {
                    if (!__TryGetNativeToManagedMapping(native, out var managed))
                        throw new global::System.Exception("No managed instance was found");
                    var result = (ProjFunc)managed;
                    if (result.__ownsNativeInstance)
                        result.SetupVTables();
                    return result;
                }

                internal static ProjFunc __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new ProjFuncInternal(native, skipVTables);
                }

                protected ProjFunc(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                    if (!skipVTables)
                        SetupVTables(true);
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::gambit.Gambit.Agg.TypeEnum Type
                {
                    get
                    {
                        return ((__Internal*)__Instance)->Type;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->Type = value;
                    }
                }

                public int Default
                {
                    get
                    {
                        return ((__Internal*)__Instance)->Default;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->Default = value;
                    }
                }

                #region Virtual table interop

                // virtual ~proj_func() = default
                private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

                private static void _dtorDelegateHook(__IntPtr __instance, int delete)
                {
                    var __target = global::gambit.Gambit.Agg.ProjFunc.__GetInstance(__instance);
                    __target.Dispose(disposing: true, callNativeDtor: true);
                }

                internal static class VTableLoader
                {
                    private static volatile bool initialized;
                    private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                    private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                    private static readonly IntPtr[] Thunks = new IntPtr[1];
                    private static CppSharp.Runtime.VTables VTables;
                    private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                        SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                    static VTableLoader()
                    {
                        _dtorDelegateInstance += _dtorDelegateHook;
                        Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    }

                    public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                    {
                        if (!initialized)
                        {
                            lock (ManagedVTables)
                            {
                                if (!initialized)
                                {
                                    initialized = true;
                                    VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                    VTables.Methods = new Delegate[1][];
                                    ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                    ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTables[0][0] = Thunks[0];
                                    VTables.Methods[0] = new Delegate[4];
                                }
                            }
                        }

                        if (destructorOnly)
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        }
                        else
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        }
                        return VTables;
                    }
                }

                protected CppSharp.Runtime.VTables __vtables;
                internal virtual CppSharp.Runtime.VTables __VTables
                {
                    get {
                        if (__vtables.IsEmpty)
                            __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                        return __vtables;
                    }

                    set {
                        __vtables = value;
                    }
                }
                internal virtual void SetupVTables(bool destructorOnly = false)
                {
                    if (__VTables.IsTransient)
                        __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
                }
                #endregion
            }

            public unsafe partial class ProjFuncSUM : global::gambit.Gambit.Agg.ProjFunc, IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public new partial struct __Internal
                {
                    internal __IntPtr vfptr_proj_func;
                    internal global::gambit.Gambit.Agg.TypeEnum Type;
                    internal int Default;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I weights;
                }

                internal static new ProjFuncSUM __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new ProjFuncSUM(native.ToPointer(), skipVTables);
                }

                internal static new ProjFuncSUM __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (ProjFuncSUM)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static new ProjFuncSUM __GetInstance(__IntPtr native)
                {
                    if (!__TryGetNativeToManagedMapping(native, out var managed))
                        throw new global::System.Exception("No managed instance was found");
                    var result = (ProjFuncSUM)managed;
                    if (result.__ownsNativeInstance)
                        result.SetupVTables();
                    return result;
                }

                internal static ProjFuncSUM __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new ProjFuncSUM(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ProjFuncSUM(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected ProjFuncSUM(void* native, bool skipVTables = false)
                    : base((void*) native)
                {
                    if (native == null)
                        return;
                    if (!skipVTables)
                        SetupVTables(true);
                }

                partial void DisposePartial(bool disposing);

                internal protected override void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                #region Virtual table interop

                // proj_func_SUM
                private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

                private static void _dtorDelegateHook(__IntPtr __instance, int delete)
                {
                    var __target = global::gambit.Gambit.Agg.ProjFuncSUM.__GetInstance(__instance);
                    __target.Dispose(disposing: true, callNativeDtor: true);
                }

                internal static new class VTableLoader
                {
                    private static volatile bool initialized;
                    private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                    private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                    private static readonly IntPtr[] Thunks = new IntPtr[1];
                    private static CppSharp.Runtime.VTables VTables;
                    private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                        SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                    static VTableLoader()
                    {
                        _dtorDelegateInstance += _dtorDelegateHook;
                        Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    }

                    public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                    {
                        if (!initialized)
                        {
                            lock (ManagedVTables)
                            {
                                if (!initialized)
                                {
                                    initialized = true;
                                    VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                    VTables.Methods = new Delegate[1][];
                                    ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                    ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTables[0][0] = Thunks[0];
                                    VTables.Methods[0] = new Delegate[4];
                                }
                            }
                        }

                        if (destructorOnly)
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        }
                        else
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        }
                        return VTables;
                    }
                }

                internal override CppSharp.Runtime.VTables __VTables
                {
                    get {
                        if (__vtables.IsEmpty)
                            __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                        return __vtables;
                    }

                    set {
                        __vtables = value;
                    }
                }
                internal override void SetupVTables(bool destructorOnly = false)
                {
                    if (__VTables.IsTransient)
                        __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
                }
                #endregion
            }

            public unsafe partial class ProjFuncSUM2 : global::gambit.Gambit.Agg.ProjFunc, IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public new partial struct __Internal
                {
                    internal __IntPtr vfptr_proj_func;
                    internal global::gambit.Gambit.Agg.TypeEnum Type;
                    internal int Default;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I weights;
                }

                internal static new ProjFuncSUM2 __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new ProjFuncSUM2(native.ToPointer(), skipVTables);
                }

                internal static new ProjFuncSUM2 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (ProjFuncSUM2)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static new ProjFuncSUM2 __GetInstance(__IntPtr native)
                {
                    if (!__TryGetNativeToManagedMapping(native, out var managed))
                        throw new global::System.Exception("No managed instance was found");
                    var result = (ProjFuncSUM2)managed;
                    if (result.__ownsNativeInstance)
                        result.SetupVTables();
                    return result;
                }

                internal static ProjFuncSUM2 __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new ProjFuncSUM2(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ProjFuncSUM2(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected ProjFuncSUM2(void* native, bool skipVTables = false)
                    : base((void*) native)
                {
                    if (native == null)
                        return;
                    if (!skipVTables)
                        SetupVTables(true);
                }

                partial void DisposePartial(bool disposing);

                internal protected override void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                #region Virtual table interop

                // proj_func_SUM2
                private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

                private static void _dtorDelegateHook(__IntPtr __instance, int delete)
                {
                    var __target = global::gambit.Gambit.Agg.ProjFuncSUM2.__GetInstance(__instance);
                    __target.Dispose(disposing: true, callNativeDtor: true);
                }

                internal static new class VTableLoader
                {
                    private static volatile bool initialized;
                    private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                    private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                    private static readonly IntPtr[] Thunks = new IntPtr[1];
                    private static CppSharp.Runtime.VTables VTables;
                    private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                        SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                    static VTableLoader()
                    {
                        _dtorDelegateInstance += _dtorDelegateHook;
                        Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    }

                    public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                    {
                        if (!initialized)
                        {
                            lock (ManagedVTables)
                            {
                                if (!initialized)
                                {
                                    initialized = true;
                                    VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                    VTables.Methods = new Delegate[1][];
                                    ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                    ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTables[0][0] = Thunks[0];
                                    VTables.Methods[0] = new Delegate[4];
                                }
                            }
                        }

                        if (destructorOnly)
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        }
                        else
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        }
                        return VTables;
                    }
                }

                internal override CppSharp.Runtime.VTables __VTables
                {
                    get {
                        if (__vtables.IsEmpty)
                            __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                        return __vtables;
                    }

                    set {
                        __vtables = value;
                    }
                }
                internal override void SetupVTables(bool destructorOnly = false)
                {
                    if (__VTables.IsTransient)
                        __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
                }
                #endregion
            }

            public unsafe partial class ProjFuncEXIST : global::gambit.Gambit.Agg.ProjFunc, IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public new partial struct __Internal
                {
                    internal __IntPtr vfptr_proj_func;
                    internal global::gambit.Gambit.Agg.TypeEnum Type;
                    internal int Default;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I weights;
                }

                internal static new ProjFuncEXIST __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new ProjFuncEXIST(native.ToPointer(), skipVTables);
                }

                internal static new ProjFuncEXIST __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (ProjFuncEXIST)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static new ProjFuncEXIST __GetInstance(__IntPtr native)
                {
                    if (!__TryGetNativeToManagedMapping(native, out var managed))
                        throw new global::System.Exception("No managed instance was found");
                    var result = (ProjFuncEXIST)managed;
                    if (result.__ownsNativeInstance)
                        result.SetupVTables();
                    return result;
                }

                internal static ProjFuncEXIST __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new ProjFuncEXIST(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ProjFuncEXIST(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected ProjFuncEXIST(void* native, bool skipVTables = false)
                    : base((void*) native)
                {
                    if (native == null)
                        return;
                    if (!skipVTables)
                        SetupVTables(true);
                }

                partial void DisposePartial(bool disposing);

                internal protected override void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                #region Virtual table interop

                // proj_func_EXIST
                private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

                private static void _dtorDelegateHook(__IntPtr __instance, int delete)
                {
                    var __target = global::gambit.Gambit.Agg.ProjFuncEXIST.__GetInstance(__instance);
                    __target.Dispose(disposing: true, callNativeDtor: true);
                }

                internal static new class VTableLoader
                {
                    private static volatile bool initialized;
                    private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                    private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                    private static readonly IntPtr[] Thunks = new IntPtr[1];
                    private static CppSharp.Runtime.VTables VTables;
                    private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                        SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                    static VTableLoader()
                    {
                        _dtorDelegateInstance += _dtorDelegateHook;
                        Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    }

                    public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                    {
                        if (!initialized)
                        {
                            lock (ManagedVTables)
                            {
                                if (!initialized)
                                {
                                    initialized = true;
                                    VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                    VTables.Methods = new Delegate[1][];
                                    ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                    ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTables[0][0] = Thunks[0];
                                    VTables.Methods[0] = new Delegate[4];
                                }
                            }
                        }

                        if (destructorOnly)
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        }
                        else
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        }
                        return VTables;
                    }
                }

                internal override CppSharp.Runtime.VTables __VTables
                {
                    get {
                        if (__vtables.IsEmpty)
                            __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                        return __vtables;
                    }

                    set {
                        __vtables = value;
                    }
                }
                internal override void SetupVTables(bool destructorOnly = false)
                {
                    if (__VTables.IsTransient)
                        __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
                }
                #endregion
            }

            public unsafe partial class ProjFuncEXIST2 : global::gambit.Gambit.Agg.ProjFunc, IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public new partial struct __Internal
                {
                    internal __IntPtr vfptr_proj_func;
                    internal global::gambit.Gambit.Agg.TypeEnum Type;
                    internal int Default;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I weights;
                }

                internal static new ProjFuncEXIST2 __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new ProjFuncEXIST2(native.ToPointer(), skipVTables);
                }

                internal static new ProjFuncEXIST2 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (ProjFuncEXIST2)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static new ProjFuncEXIST2 __GetInstance(__IntPtr native)
                {
                    if (!__TryGetNativeToManagedMapping(native, out var managed))
                        throw new global::System.Exception("No managed instance was found");
                    var result = (ProjFuncEXIST2)managed;
                    if (result.__ownsNativeInstance)
                        result.SetupVTables();
                    return result;
                }

                internal static ProjFuncEXIST2 __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new ProjFuncEXIST2(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ProjFuncEXIST2(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected ProjFuncEXIST2(void* native, bool skipVTables = false)
                    : base((void*) native)
                {
                    if (native == null)
                        return;
                    if (!skipVTables)
                        SetupVTables(true);
                }

                partial void DisposePartial(bool disposing);

                internal protected override void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                #region Virtual table interop

                // proj_func_EXIST2
                private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

                private static void _dtorDelegateHook(__IntPtr __instance, int delete)
                {
                    var __target = global::gambit.Gambit.Agg.ProjFuncEXIST2.__GetInstance(__instance);
                    __target.Dispose(disposing: true, callNativeDtor: true);
                }

                internal static new class VTableLoader
                {
                    private static volatile bool initialized;
                    private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                    private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                    private static readonly IntPtr[] Thunks = new IntPtr[1];
                    private static CppSharp.Runtime.VTables VTables;
                    private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                        SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                    static VTableLoader()
                    {
                        _dtorDelegateInstance += _dtorDelegateHook;
                        Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    }

                    public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                    {
                        if (!initialized)
                        {
                            lock (ManagedVTables)
                            {
                                if (!initialized)
                                {
                                    initialized = true;
                                    VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                    VTables.Methods = new Delegate[1][];
                                    ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                    ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTables[0][0] = Thunks[0];
                                    VTables.Methods[0] = new Delegate[4];
                                }
                            }
                        }

                        if (destructorOnly)
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        }
                        else
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        }
                        return VTables;
                    }
                }

                internal override CppSharp.Runtime.VTables __VTables
                {
                    get {
                        if (__vtables.IsEmpty)
                            __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                        return __vtables;
                    }

                    set {
                        __vtables = value;
                    }
                }
                internal override void SetupVTables(bool destructorOnly = false)
                {
                    if (__VTables.IsTransient)
                        __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
                }
                #endregion
            }

            public unsafe partial class ProjFuncHIGH : global::gambit.Gambit.Agg.ProjFunc, IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public new partial struct __Internal
                {
                    internal __IntPtr vfptr_proj_func;
                    internal global::gambit.Gambit.Agg.TypeEnum Type;
                    internal int Default;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I weights;
                }

                internal static new ProjFuncHIGH __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new ProjFuncHIGH(native.ToPointer(), skipVTables);
                }

                internal static new ProjFuncHIGH __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (ProjFuncHIGH)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static new ProjFuncHIGH __GetInstance(__IntPtr native)
                {
                    if (!__TryGetNativeToManagedMapping(native, out var managed))
                        throw new global::System.Exception("No managed instance was found");
                    var result = (ProjFuncHIGH)managed;
                    if (result.__ownsNativeInstance)
                        result.SetupVTables();
                    return result;
                }

                internal static ProjFuncHIGH __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new ProjFuncHIGH(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ProjFuncHIGH(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected ProjFuncHIGH(void* native, bool skipVTables = false)
                    : base((void*) native)
                {
                    if (native == null)
                        return;
                    if (!skipVTables)
                        SetupVTables(true);
                }

                partial void DisposePartial(bool disposing);

                internal protected override void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                #region Virtual table interop

                // proj_func_HIGH
                private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

                private static void _dtorDelegateHook(__IntPtr __instance, int delete)
                {
                    var __target = global::gambit.Gambit.Agg.ProjFuncHIGH.__GetInstance(__instance);
                    __target.Dispose(disposing: true, callNativeDtor: true);
                }

                internal static new class VTableLoader
                {
                    private static volatile bool initialized;
                    private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                    private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                    private static readonly IntPtr[] Thunks = new IntPtr[1];
                    private static CppSharp.Runtime.VTables VTables;
                    private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                        SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                    static VTableLoader()
                    {
                        _dtorDelegateInstance += _dtorDelegateHook;
                        Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    }

                    public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                    {
                        if (!initialized)
                        {
                            lock (ManagedVTables)
                            {
                                if (!initialized)
                                {
                                    initialized = true;
                                    VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                    VTables.Methods = new Delegate[1][];
                                    ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                    ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTables[0][0] = Thunks[0];
                                    VTables.Methods[0] = new Delegate[4];
                                }
                            }
                        }

                        if (destructorOnly)
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        }
                        else
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        }
                        return VTables;
                    }
                }

                internal override CppSharp.Runtime.VTables __VTables
                {
                    get {
                        if (__vtables.IsEmpty)
                            __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                        return __vtables;
                    }

                    set {
                        __vtables = value;
                    }
                }
                internal override void SetupVTables(bool destructorOnly = false)
                {
                    if (__VTables.IsTransient)
                        __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
                }
                #endregion
            }

            public unsafe partial class ProjFuncHIGH2 : global::gambit.Gambit.Agg.ProjFunc, IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public new partial struct __Internal
                {
                    internal __IntPtr vfptr_proj_func;
                    internal global::gambit.Gambit.Agg.TypeEnum Type;
                    internal int Default;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I weights;
                }

                internal static new ProjFuncHIGH2 __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new ProjFuncHIGH2(native.ToPointer(), skipVTables);
                }

                internal static new ProjFuncHIGH2 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (ProjFuncHIGH2)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static new ProjFuncHIGH2 __GetInstance(__IntPtr native)
                {
                    if (!__TryGetNativeToManagedMapping(native, out var managed))
                        throw new global::System.Exception("No managed instance was found");
                    var result = (ProjFuncHIGH2)managed;
                    if (result.__ownsNativeInstance)
                        result.SetupVTables();
                    return result;
                }

                internal static ProjFuncHIGH2 __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new ProjFuncHIGH2(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ProjFuncHIGH2(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected ProjFuncHIGH2(void* native, bool skipVTables = false)
                    : base((void*) native)
                {
                    if (native == null)
                        return;
                    if (!skipVTables)
                        SetupVTables(true);
                }

                partial void DisposePartial(bool disposing);

                internal protected override void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                #region Virtual table interop

                // proj_func_HIGH2
                private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

                private static void _dtorDelegateHook(__IntPtr __instance, int delete)
                {
                    var __target = global::gambit.Gambit.Agg.ProjFuncHIGH2.__GetInstance(__instance);
                    __target.Dispose(disposing: true, callNativeDtor: true);
                }

                internal static new class VTableLoader
                {
                    private static volatile bool initialized;
                    private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                    private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                    private static readonly IntPtr[] Thunks = new IntPtr[1];
                    private static CppSharp.Runtime.VTables VTables;
                    private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                        SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                    static VTableLoader()
                    {
                        _dtorDelegateInstance += _dtorDelegateHook;
                        Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    }

                    public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                    {
                        if (!initialized)
                        {
                            lock (ManagedVTables)
                            {
                                if (!initialized)
                                {
                                    initialized = true;
                                    VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                    VTables.Methods = new Delegate[1][];
                                    ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                    ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTables[0][0] = Thunks[0];
                                    VTables.Methods[0] = new Delegate[4];
                                }
                            }
                        }

                        if (destructorOnly)
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        }
                        else
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        }
                        return VTables;
                    }
                }

                internal override CppSharp.Runtime.VTables __VTables
                {
                    get {
                        if (__vtables.IsEmpty)
                            __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                        return __vtables;
                    }

                    set {
                        __vtables = value;
                    }
                }
                internal override void SetupVTables(bool destructorOnly = false)
                {
                    if (__VTables.IsTransient)
                        __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
                }
                #endregion
            }

            public unsafe partial class ProjFuncLOW : global::gambit.Gambit.Agg.ProjFunc, IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public new partial struct __Internal
                {
                    internal __IntPtr vfptr_proj_func;
                    internal global::gambit.Gambit.Agg.TypeEnum Type;
                    internal int Default;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I weights;
                }

                internal static new ProjFuncLOW __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new ProjFuncLOW(native.ToPointer(), skipVTables);
                }

                internal static new ProjFuncLOW __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (ProjFuncLOW)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static new ProjFuncLOW __GetInstance(__IntPtr native)
                {
                    if (!__TryGetNativeToManagedMapping(native, out var managed))
                        throw new global::System.Exception("No managed instance was found");
                    var result = (ProjFuncLOW)managed;
                    if (result.__ownsNativeInstance)
                        result.SetupVTables();
                    return result;
                }

                internal static ProjFuncLOW __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new ProjFuncLOW(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ProjFuncLOW(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected ProjFuncLOW(void* native, bool skipVTables = false)
                    : base((void*) native)
                {
                    if (native == null)
                        return;
                    if (!skipVTables)
                        SetupVTables(true);
                }

                partial void DisposePartial(bool disposing);

                internal protected override void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                #region Virtual table interop

                // proj_func_LOW
                private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

                private static void _dtorDelegateHook(__IntPtr __instance, int delete)
                {
                    var __target = global::gambit.Gambit.Agg.ProjFuncLOW.__GetInstance(__instance);
                    __target.Dispose(disposing: true, callNativeDtor: true);
                }

                internal static new class VTableLoader
                {
                    private static volatile bool initialized;
                    private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                    private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                    private static readonly IntPtr[] Thunks = new IntPtr[1];
                    private static CppSharp.Runtime.VTables VTables;
                    private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                        SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                    static VTableLoader()
                    {
                        _dtorDelegateInstance += _dtorDelegateHook;
                        Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    }

                    public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                    {
                        if (!initialized)
                        {
                            lock (ManagedVTables)
                            {
                                if (!initialized)
                                {
                                    initialized = true;
                                    VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                    VTables.Methods = new Delegate[1][];
                                    ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                    ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTables[0][0] = Thunks[0];
                                    VTables.Methods[0] = new Delegate[4];
                                }
                            }
                        }

                        if (destructorOnly)
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        }
                        else
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        }
                        return VTables;
                    }
                }

                internal override CppSharp.Runtime.VTables __VTables
                {
                    get {
                        if (__vtables.IsEmpty)
                            __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                        return __vtables;
                    }

                    set {
                        __vtables = value;
                    }
                }
                internal override void SetupVTables(bool destructorOnly = false)
                {
                    if (__VTables.IsTransient)
                        __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
                }
                #endregion
            }

            public unsafe partial class ProjFuncLOW2 : global::gambit.Gambit.Agg.ProjFunc, IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public new partial struct __Internal
                {
                    internal __IntPtr vfptr_proj_func;
                    internal global::gambit.Gambit.Agg.TypeEnum Type;
                    internal int Default;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I weights;
                }

                internal static new ProjFuncLOW2 __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new ProjFuncLOW2(native.ToPointer(), skipVTables);
                }

                internal static new ProjFuncLOW2 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (ProjFuncLOW2)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static new ProjFuncLOW2 __GetInstance(__IntPtr native)
                {
                    if (!__TryGetNativeToManagedMapping(native, out var managed))
                        throw new global::System.Exception("No managed instance was found");
                    var result = (ProjFuncLOW2)managed;
                    if (result.__ownsNativeInstance)
                        result.SetupVTables();
                    return result;
                }

                internal static ProjFuncLOW2 __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new ProjFuncLOW2(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ProjFuncLOW2(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected ProjFuncLOW2(void* native, bool skipVTables = false)
                    : base((void*) native)
                {
                    if (native == null)
                        return;
                    if (!skipVTables)
                        SetupVTables(true);
                }

                partial void DisposePartial(bool disposing);

                internal protected override void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                #region Virtual table interop

                // proj_func_LOW2
                private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

                private static void _dtorDelegateHook(__IntPtr __instance, int delete)
                {
                    var __target = global::gambit.Gambit.Agg.ProjFuncLOW2.__GetInstance(__instance);
                    __target.Dispose(disposing: true, callNativeDtor: true);
                }

                internal static new class VTableLoader
                {
                    private static volatile bool initialized;
                    private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                    private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                    private static readonly IntPtr[] Thunks = new IntPtr[1];
                    private static CppSharp.Runtime.VTables VTables;
                    private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                        SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                    static VTableLoader()
                    {
                        _dtorDelegateInstance += _dtorDelegateHook;
                        Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    }

                    public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                    {
                        if (!initialized)
                        {
                            lock (ManagedVTables)
                            {
                                if (!initialized)
                                {
                                    initialized = true;
                                    VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                    VTables.Methods = new Delegate[1][];
                                    ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                    ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTables[0][0] = Thunks[0];
                                    VTables.Methods[0] = new Delegate[4];
                                }
                            }
                        }

                        if (destructorOnly)
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        }
                        else
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        }
                        return VTables;
                    }
                }

                internal override CppSharp.Runtime.VTables __VTables
                {
                    get {
                        if (__vtables.IsEmpty)
                            __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                        return __vtables;
                    }

                    set {
                        __vtables = value;
                    }
                }
                internal override void SetupVTables(bool destructorOnly = false)
                {
                    if (__VTables.IsTransient)
                        __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
                }
                #endregion
            }

            public unsafe partial class ProjFuncInternal : global::gambit.Gambit.Agg.ProjFunc, IDisposable
            {
                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                internal ProjFuncInternal(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                internal ProjFuncInternal(void* native, bool skipVTables = false)
                    : base((void*) native)
                {
                }
            }
        }
    }

    namespace Gambit
    {
        namespace Agg
        {
            namespace TrieMap
            {
                [StructLayout(LayoutKind.Sequential, Size = 56)]
                public unsafe partial struct __Internalc__N_Gambit_N_agg_S_trie_map__d
                {
                    internal global::Std.List.__Internalc__N_std_S_list____N_std_S_pair____N_std_S_vector__I___N_std_S_allocator__I_d___N_std_S_allocator__S0_ data;
                    internal uint initBranches;
                    internal __IntPtr root;
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_Gambit_N_agg_S_TrieNode__d___N_std_S_allocator__S0_ leaves;

                    [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "??1?$trie_map@N@agg@Gambit@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern void dtorc__N_Gambit_N_agg_S_trie_map__d(__IntPtr __instance);
                }
            }

            public unsafe partial class TrieMap<V> : IDisposable
            {
                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Agg.TrieMap<V>> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Agg.TrieMap<V>>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.Agg.TrieMap<V> managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.Agg.TrieMap<V> managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static TrieMap<V> __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new TrieMap<V>(native.ToPointer(), skipVTables);
                }

                internal static TrieMap<V> __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (TrieMap<V>)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static TrieMap<V> __CreateInstance(global::gambit.Gambit.Agg.TrieMap.__Internalc__N_Gambit_N_agg_S_trie_map__d native, bool skipVTables = false)
                {
                    return new TrieMap<V>(native, skipVTables);
                }

                private static void* __CopyValue(global::gambit.Gambit.Agg.TrieMap.__Internalc__N_Gambit_N_agg_S_trie_map__d native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.Agg.TrieMap.__Internalc__N_Gambit_N_agg_S_trie_map__d));
                    *(global::gambit.Gambit.Agg.TrieMap.__Internalc__N_Gambit_N_agg_S_trie_map__d*) ret = native;
                    return ret.ToPointer();
                }

                private TrieMap(global::gambit.Gambit.Agg.TrieMap.__Internalc__N_Gambit_N_agg_S_trie_map__d native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected TrieMap(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public TrieMap()
                {
                    var __V = typeof(V);
                    if (__V.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method trie_map_V_ ignored in specialization global::gambit.Gambit.Agg.TrieMap<double>.");
                    }
                    throw new ArgumentOutOfRangeException("V", string.Join(", ", new[] { typeof(V).FullName }), "global::gambit.Gambit.Agg.TrieMap<V> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <double>.");
                }

                public TrieMap(int branches)
                {
                    var __V = typeof(V);
                    if (__V.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method trie_map_V_ ignored in specialization global::gambit.Gambit.Agg.TrieMap<double>.");
                    }
                    throw new ArgumentOutOfRangeException("V", string.Join(", ", new[] { typeof(V).FullName }), "global::gambit.Gambit.Agg.TrieMap<V> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <double>.");
                }

                public TrieMap(global::gambit.Gambit.Agg.TrieMap<V> other)
                {
                    var __V = typeof(V);
                    if (__V.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method trie_map_V_ ignored in specialization global::gambit.Gambit.Agg.TrieMap<double>.");
                    }
                    throw new ArgumentOutOfRangeException("V", string.Join(", ", new[] { typeof(V).FullName }), "global::gambit.Gambit.Agg.TrieMap<V> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <double>.");
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public void Swap(global::gambit.Gambit.Agg.TrieMap<V> other)
                {
                    var __V = typeof(V);
                    if (__V.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Swap ignored in specialization global::gambit.Gambit.Agg.TrieMap<double>.");
                    }
                    throw new ArgumentOutOfRangeException("V", string.Join(", ", new[] { typeof(V).FullName }), "global::gambit.Gambit.Agg.TrieMap<V> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <double>.");
                }

                public void Clear()
                {
                    var __V = typeof(V);
                    if (__V.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Agg.TrieMap<double>.");
                    }
                    throw new ArgumentOutOfRangeException("V", string.Join(", ", new[] { typeof(V).FullName }), "global::gambit.Gambit.Agg.TrieMap<V> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <double>.");
                }

                public void Reset()
                {
                    var __V = typeof(V);
                    if (__V.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Reset ignored in specialization global::gambit.Gambit.Agg.TrieMap<double>.");
                    }
                    throw new ArgumentOutOfRangeException("V", string.Join(", ", new[] { typeof(V).FullName }), "global::gambit.Gambit.Agg.TrieMap<V> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <double>.");
                }

                public V InnerProd(global::gambit.Gambit.Agg.TrieMap<V> other, V init)
                {
                    var __V = typeof(V);
                    if (__V.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method InnerProd ignored in specialization global::gambit.Gambit.Agg.TrieMap<double>.");
                    }
                    throw new ArgumentOutOfRangeException("V", string.Join(", ", new[] { typeof(V).FullName }), "global::gambit.Gambit.Agg.TrieMap<V> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <double>.");
                }

                public static explicit operator global::gambit.Gambit.Agg.TrieMap<V>(int branches)
                {
                    return new global::gambit.Gambit.Agg.TrieMap<V>(branches);
                }

                public uint Size
                {
                    get
                    {
                        var __V = typeof(V);
                        if (__V.IsAssignableFrom(typeof(double)))
                        {
                            throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Agg.TrieMap<double>.");
                        }
                        throw new ArgumentOutOfRangeException("V", string.Join(", ", new[] { typeof(V).FullName }), "global::gambit.Gambit.Agg.TrieMap<V> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <double>.");
                    }
                }

                public bool Empty
                {
                    get
                    {
                        var __V = typeof(V);
                        if (__V.IsAssignableFrom(typeof(double)))
                        {
                            throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Agg.TrieMap<double>.");
                        }
                        throw new ArgumentOutOfRangeException("V", string.Join(", ", new[] { typeof(V).FullName }), "global::gambit.Gambit.Agg.TrieMap<V> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <double>.");
                    }
                }
            }

            namespace TrieNode
            {
                [StructLayout(LayoutKind.Sequential, Size = 32)]
                public unsafe partial struct __Internalc__N_Gambit_N_agg_S_TrieNode__d
                {
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_Gambit_N_agg_S_TrieNode__d___N_std_S_allocator__S0_ children;
                    internal global::Std.ListIterator.__Internal val;
                }
            }
        }
    }

    namespace Gambit
    {
        namespace Gametracer
        {
            public unsafe partial class Aggame
            {
                public partial struct __Internal
                {
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Gametracer.Aggame> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Gametracer.Aggame>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.Gametracer.Aggame managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.Gametracer.Aggame managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static Aggame __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new Aggame(native.ToPointer(), skipVTables);
                }

                internal static Aggame __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (Aggame)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static Aggame __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new Aggame(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Aggame(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected Aggame(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }
            }
        }

        namespace Agg
        {
            public enum Payofftype
            {
                COMPLETE = 0,
                MAPPING = 1,
                ADDITIVE = 2
            }

            public unsafe partial class AGG : IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 528)]
                public partial struct __Internal
                {
                    internal int numPlayers;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I actions;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I strategyOffset;
                    internal int totalActions;
                    internal int maxActions;
                    internal int numActionNodes;
                    internal int numPNodes;
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_vector__I___N_std_S_allocator__I___N_std_S_allocator__S0_ actionSets;
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_vector__I___N_std_S_allocator__I___N_std_S_allocator__S0_ neighbors;
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_shared_ptr____N_Gambit_N_agg_S_proj_func___N_std_S_allocator__S0_ projectionTypes;
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_Gambit_N_agg_S_trie_map__d___N_std_S_allocator__S0_ payoffs;
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_vector____N_std_S_vector____N_std_S_vector__I___N_std_S_allocator__I___N_std_S_allocator__S2____N_std_S_allocator__S1____N_std_S_allocator__S0_ projection;
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_vector____N_Gambit_N_agg_S_trie_map__d___N_std_S_allocator__S1____N_std_S_allocator__S0_ projectedStrat;
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_vector____N_Gambit_N_agg_S_trie_map__d___N_std_S_allocator__S1____N_std_S_allocator__S0_ fullProjectedStrat;
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_vector____N_std_S_shared_ptr____N_Gambit_N_agg_S_proj_func___N_std_S_allocator__S1____N_std_S_allocator__S0_ projFunctions;
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_vector____N_std_S_vector__I___N_std_S_allocator__I___N_std_S_allocator__S1____N_std_S_allocator__S0_ Porder;
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_Gambit_N_agg_S_trie_map__d___N_std_S_allocator__S0_ Pr;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__b___N_std_S_allocator__b isPure;
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_vector__I___N_std_S_allocator__I___N_std_S_allocator__S0_ node2Action;
                    internal global::gambit.Gambit.Agg.TrieMap.__Internalc__N_Gambit_N_agg_S_trie_map__d cache;
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_vector__I___N_std_S_allocator__I___N_std_S_allocator__S0_ uniqueActionSets;
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_vector__I___N_std_S_allocator__I___N_std_S_allocator__S0_ playerClasses;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I player2Class;
                    internal int numKSymActions;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I kSymStrategyOffset;

                    [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "??1AGG@agg@Gambit@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern void dtor(__IntPtr __instance);
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Agg.AGG> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Agg.AGG>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.Agg.AGG managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.Agg.AGG managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static AGG __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new AGG(native.ToPointer(), skipVTables);
                }

                internal static AGG __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (AGG)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static AGG __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new AGG(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private AGG(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected AGG(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public const char COMMENT_CHAR = '#';
                public const char LBRACKET = '[';
                public const char RBRACKET = ']';            }
        }
    }

    namespace Gambit
    {
        public unsafe partial class GameAGGRep : global::gambit.Gambit.GameRep, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 128)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_BaseGameRep;
                internal int m_refCount;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_title;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_comment;
                internal uint m_version;
                internal global::Std.SharedPtr.__Internal aggPtr;
                internal global::gambit.Gambit.Array.__Internal m_players;
            }

            internal static new GameAGGRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameAGGRep(native.ToPointer(), skipVTables);
            }

            internal static new GameAGGRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameAGGRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GameAGGRep __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GameAGGRep)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GameAGGRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameAGGRep(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GameAGGRep(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GameAGGRep(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Gets the i'th strategy in the game, numbered globally</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> GetStrategy(int p_index)
            {
                var ___GetStrategyDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 19);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetStrategyDelegate(__Instance, new IntPtr(&___ret), p_index);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.PureStrategyProfile NewPureStrategyProfile()
            {
                var ___NewPureStrategyProfileDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 23);
                var ___ret = new global::gambit.Gambit.PureStrategyProfile.__Internal();
                ___NewPureStrategyProfileDelegate(__Instance, new IntPtr(&___ret));
                var _____ret = global::gambit.Gambit.PureStrategyProfile.__CreateInstance(___ret);
                global::gambit.Gambit.PureStrategyProfile.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.MixedStrategyProfile<double> NewMixedStrategyProfile(double _0)
            {
                var ___NewMixedStrategyProfileDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_double>(0, 27);
                var ___ret = new global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d();
                ___NewMixedStrategyProfileDelegate(__Instance, new IntPtr(&___ret), _0);
                var _____ret = global::gambit.Gambit.MixedStrategyProfile<double>.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            public override global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational> NewMixedStrategyProfile(global::gambit.Gambit.Rational _0)
            {
                var ___NewMixedStrategyProfile_1Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 26);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = new global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational();
                ___NewMixedStrategyProfile_1Delegate(__Instance, new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            public override global::gambit.Gambit.MixedStrategyProfile<double> NewMixedStrategyProfile(double _0, global::gambit.Gambit.StrategySupportProfile _1)
            {
                var ___NewMixedStrategyProfile_2Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_double___IntPtr>(0, 25);
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = new global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d();
                ___NewMixedStrategyProfile_2Delegate(__Instance, new IntPtr(&___ret), _0, __arg1);
                var _____ret = global::gambit.Gambit.MixedStrategyProfile<double>.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            public override global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational> NewMixedStrategyProfile(global::gambit.Gambit.Rational _0, global::gambit.Gambit.StrategySupportProfile _1)
            {
                var ___NewMixedStrategyProfile_3Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr>(0, 24);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = new global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational();
                ___NewMixedStrategyProfile_3Delegate(__Instance, new IntPtr(&___ret), __arg0, __arg1);
                var _____ret = global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            /// <summary>Returns the pl'th player in the game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> GetPlayer(int pl)
            {
                var ___GetPlayerDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 29);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetPlayerDelegate(__Instance, new IntPtr(&___ret), pl);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Creates a new player in the game, with no moves</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> NewPlayer()
            {
                var ___NewPlayerDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 32);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___NewPlayerDelegate(__Instance, new IntPtr(&___ret));
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the iset'th information set in the game (numbered globally)</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> GetInfoset(int iset)
            {
                var ___GetInfosetDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 33);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetInfosetDelegate(__Instance, new IntPtr(&___ret), iset);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the act'th action in the game (numbered globally)</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> GetAction(int act)
            {
                var ___GetActionDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 36);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetActionDelegate(__Instance, new IntPtr(&___ret), act);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the index'th outcome defined in the game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> GetOutcome(int index)
            {
                var ___GetOutcomeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 38);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetOutcomeDelegate(__Instance, new IntPtr(&___ret), index);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameOutcomeRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Creates a new outcome in the game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> NewOutcome()
            {
                var ___NewOutcomeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 39);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___NewOutcomeDelegate(__Instance, new IntPtr(&___ret));
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameOutcomeRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Deletes the specified outcome from the game</summary>
            public override void DeleteOutcome(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> _0)
            {
                var ___DeleteOutcomeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 40);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                ___DeleteOutcomeDelegate(__Instance, __arg0);
            }

            public override bool IsPerfectRecall(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> _0, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> _1)
            {
                var ___IsPerfectRecallDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr___IntPtr___IntPtr>(0, 12);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = ___IsPerfectRecallDelegate(__Instance, __arg0, __arg1);
                return ___ret;
            }

            /// <summary>Returns the smallest payoff in any outcome of the game</summary>
            public override global::gambit.Gambit.Rational GetMinPayoff(int _0)
            {
                var ___GetMinPayoffDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 10);
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                ___GetMinPayoffDelegate(__Instance, new IntPtr(&___ret), _0);
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the largest payoff in any outcome of the game</summary>
            public override global::gambit.Gambit.Rational GetMaxPayoff(int _0)
            {
                var ___GetMaxPayoffDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 11);
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                ___GetMaxPayoffDelegate(__Instance, new IntPtr(&___ret), _0);
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> SetChanceProbs(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> _0, global::gambit.Gambit.Array<global::gambit.Gambit.Number> _1)
            {
                var ___SetChanceProbsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr>(0, 43);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___SetChanceProbsDelegate(__Instance, new IntPtr(&___ret), __arg0, __arg1);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Create a copy of the game, as a new game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 2);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___CopyDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>The number of actions in each information set</summary>
            public override global::gambit.Gambit.PVector<int> NumActions
            {
                get
                {
                    var ___NumActionsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 16);
                    var ___ret = new global::gambit.Gambit.PVector.__Internal();
                    ___NumActionsDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.PVector<int>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>The number of members in each information set</summary>
            public override global::gambit.Gambit.PVector<int> NumMembers
            {
                get
                {
                    var ___NumMembersDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 17);
                    var ___ret = new global::gambit.Gambit.PVector.__Internal();
                    ___NumMembersDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.PVector<int>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>The number of strategies for each player</summary>
            public override global::gambit.Gambit.Array<int> NumStrategies
            {
                get
                {
                    var ___NumStrategiesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 18);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___NumStrategiesDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<int>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>Returns the total number of actions in the game</summary>
            public override int BehavProfileLength
            {
                get
                {
                    var ___BehavProfileLengthDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 21);
                    var ___ret = ___BehavProfileLengthDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the total number of strategies in the game</summary>
            public override int MixedProfileLength
            {
                get
                {
                    var ___MixedProfileLengthDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 22);
                    var ___ret = ___MixedProfileLengthDelegate(__Instance);
                    return ___ret;
                }
            }

            public override int NumStrategyContingencies
            {
                get
                {
                    var ___NumStrategyContingenciesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 20);
                    var ___ret = ___NumStrategyContingenciesDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the number of players in the game</summary>
            public override int NumPlayers
            {
                get
                {
                    var ___NumPlayersDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 28);
                    var ___ret = ___NumPlayersDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the chance (nature) player</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> Chance
            {
                get
                {
                    var ___GetChanceDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 31);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetChanceDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Returns the set of information sets in the game</summary>
            public override global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>> Infosets
            {
                get
                {
                    var ___GetInfosetsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 34);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___GetInfosetsDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>Returns an array with the number of information sets per personal player</summary>
            public override global::gambit.Gambit.Array<int> NumInfosets
            {
                get
                {
                    var ___NumInfosetsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 35);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___NumInfosetsDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<int>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>Returns the number of outcomes defined in the game</summary>
            public override int NumOutcomes
            {
                get
                {
                    var ___NumOutcomesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 37);
                    var ___ret = ___NumOutcomesDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the root node of the game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> Root
            {
                get
                {
                    var ___GetRootDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 41);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetRootDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Returns the number of nodes in the game</summary>
            public override int NumNodes
            {
                get
                {
                    var ___NumNodesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 42);
                    var ___ret = ___NumNodesDelegate(__Instance);
                    return ___ret;
                }
            }

            public override bool IsTree
            {
                get
                {
                    var ___IsTreeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr>(0, 3);
                    var ___ret = ___IsTreeDelegate(__Instance);
                    return ___ret;
                }
            }

            public override bool IsAgg
            {
                get
                {
                    return base.IsAgg;
                }
            }

            public override bool IsConstSum
            {
                get
                {
                    var ___IsConstSumDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr>(0, 9);
                    var ___ret = ___IsConstSumDelegate(__Instance);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // ~GameAGGRep() override
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // void BuildComputedValues()
            private static global::gambit.Delegates.Action___IntPtr _BuildComputedValuesDelegateInstance;

            private static void _BuildComputedValuesDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                __target.BuildComputedValues();
            }

            // Game Copy() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _CopyDelegateInstance;

            private static void _CopyDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.Copy;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // bool IsTree() const override
            private static global::gambit.Delegates.Func_bool___IntPtr _IsTreeDelegateInstance;

            private static bool _IsTreeDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.IsTree;
                return ___ret;
            }

            // bool IsAgg() const override
            private static global::gambit.Delegates.Func_bool___IntPtr _IsAggDelegateInstance;

            private static bool _IsAggDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.IsAgg;
                return ___ret;
            }

            // std::string &GetTitle() const
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _GetTitleDelegateInstance;

            private static __IntPtr _GetTitleDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.Title;
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                return __basicString0.__Instance;
            }

            // void SetTitle(const std::string &p_title)
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetTitleDelegateInstance;

            private static void _SetTitleDelegateHook(__IntPtr __instance, __IntPtr p_title)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(p_title);
                __target.Title = global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            // std::string &GetComment() const
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _GetCommentDelegateInstance;

            private static __IntPtr _GetCommentDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.Comment;
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                return __basicString0.__Instance;
            }

            // void SetComment(const std::string &p_comment)
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetCommentDelegateInstance;

            private static void _SetCommentDelegateHook(__IntPtr __instance, __IntPtr p_comment)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(p_comment);
                __target.Comment = global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            // bool IsConstSum() const override
            private static global::gambit.Delegates.Func_bool___IntPtr _IsConstSumDelegateInstance;

            private static bool _IsConstSumDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.IsConstSum;
                return ___ret;
            }

            // Rational GetMinPayoff(int) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetMinPayoffDelegateInstance;

            private static void _GetMinPayoffDelegateHook(__IntPtr __instance, __IntPtr @return, int _0)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.GetMinPayoff(_0);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Rational.__Internal*) @return = *(global::gambit.Gambit.Rational.__Internal*) ___ret.__Instance;
            }

            // Rational GetMaxPayoff(int) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetMaxPayoffDelegateInstance;

            private static void _GetMaxPayoffDelegateHook(__IntPtr __instance, __IntPtr @return, int _0)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.GetMaxPayoff(_0);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Rational.__Internal*) @return = *(global::gambit.Gambit.Rational.__Internal*) ___ret.__Instance;
            }

            // bool IsPerfectRecall(GameInfoset &, GameInfoset &) const override
            private static global::gambit.Delegates.Func_bool___IntPtr___IntPtr___IntPtr _IsPerfectRecallDelegateInstance;

            private static bool _IsPerfectRecallDelegateHook(__IntPtr __instance, __IntPtr _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(_0, false);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(_1, false);
                var ___ret = __target.IsPerfectRecall(__result0, __result1);
                return ___ret;
            }

            // PVector<int> NumActions() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NumActionsDelegateInstance;

            private static void _NumActionsDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumActions;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.PVector.__Internal*) @return = *(global::gambit.Gambit.PVector.__Internal*) ___ret.__Instance;
            }

            // PVector<int> NumMembers() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NumMembersDelegateInstance;

            private static void _NumMembersDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumMembers;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.PVector.__Internal*) @return = *(global::gambit.Gambit.PVector.__Internal*) ___ret.__Instance;
            }

            // Array<int> NumStrategies() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NumStrategiesDelegateInstance;

            private static void _NumStrategiesDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumStrategies;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // GameStrategy GetStrategy(int p_index) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetStrategyDelegateInstance;

            private static void _GetStrategyDelegateHook(__IntPtr __instance, __IntPtr @return, int p_index)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.GetStrategy(p_index);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // int NumStrategyContingencies() const override
            private static global::gambit.Delegates.Func_int___IntPtr _NumStrategyContingenciesDelegateInstance;

            private static int _NumStrategyContingenciesDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumStrategyContingencies;
                return ___ret;
            }

            // int BehavProfileLength() const override
            private static global::gambit.Delegates.Func_int___IntPtr _BehavProfileLengthDelegateInstance;

            private static int _BehavProfileLengthDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.BehavProfileLength;
                return ___ret;
            }

            // int MixedProfileLength() const override
            private static global::gambit.Delegates.Func_int___IntPtr _MixedProfileLengthDelegateInstance;

            private static int _MixedProfileLengthDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.MixedProfileLength;
                return ___ret;
            }

            // PureStrategyProfile NewPureStrategyProfile() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NewPureStrategyProfileDelegateInstance;

            private static void _NewPureStrategyProfileDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.NewPureStrategyProfile();
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.PureStrategyProfile.__Internal*) @return = *(global::gambit.Gambit.PureStrategyProfile.__Internal*) ___ret.__Instance;
            }

            // MixedStrategyProfile<Rational> NewMixedStrategyProfile(const Rational &, const StrategySupportProfile &) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr _NewMixedStrategyProfile_3DelegateInstance;

            private static void _NewMixedStrategyProfile_3DelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.Rational.__GetOrCreateInstance(_0, false);
                var __result2 = global::gambit.Gambit.StrategySupportProfile.__GetOrCreateInstance(_1, false);
                var ___ret = __target.NewMixedStrategyProfile(__result1, __result2);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) @return = *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) ___ret.__Instance;
            }

            // MixedStrategyProfile<double> NewMixedStrategyProfile(double, const StrategySupportProfile &) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_double___IntPtr _NewMixedStrategyProfile_2DelegateInstance;

            private static void _NewMixedStrategyProfile_2DelegateHook(__IntPtr __instance, __IntPtr @return, double _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var __result2 = global::gambit.Gambit.StrategySupportProfile.__GetOrCreateInstance(_1, false);
                var ___ret = __target.NewMixedStrategyProfile(_0, __result2);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) @return = *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) ___ret.__Instance;
            }

            // MixedStrategyProfile<Rational> NewMixedStrategyProfile(const Rational &) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr _NewMixedStrategyProfile_1DelegateInstance;

            private static void _NewMixedStrategyProfile_1DelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.Rational.__GetOrCreateInstance(_0, false);
                var ___ret = __target.NewMixedStrategyProfile(__result1);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) @return = *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) ___ret.__Instance;
            }

            // MixedStrategyProfile<double> NewMixedStrategyProfile(double) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_double _NewMixedStrategyProfileDelegateInstance;

            private static void _NewMixedStrategyProfileDelegateHook(__IntPtr __instance, __IntPtr @return, double _0)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.NewMixedStrategyProfile(_0);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) @return = *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) ___ret.__Instance;
            }

            // int NumPlayers() const override
            private static global::gambit.Delegates.Func_int___IntPtr _NumPlayersDelegateInstance;

            private static int _NumPlayersDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumPlayers;
                return ___ret;
            }

            // GamePlayer GetPlayer(int pl) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetPlayerDelegateInstance;

            private static void _GetPlayerDelegateHook(__IntPtr __instance, __IntPtr @return, int pl)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.GetPlayer(pl);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // Array<GamePlayer> GetPlayers() const
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetPlayersDelegateInstance;

            private static void _GetPlayersDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.Players;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // GamePlayer GetChance() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetChanceDelegateInstance;

            private static void _GetChanceDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.Chance;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GamePlayer NewPlayer() override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NewPlayerDelegateInstance;

            private static void _NewPlayerDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.NewPlayer();
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameInfoset GetInfoset(int iset) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetInfosetDelegateInstance;

            private static void _GetInfosetDelegateHook(__IntPtr __instance, __IntPtr @return, int iset)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.GetInfoset(iset);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // Array<GameInfoset> GetInfosets() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetInfosetsDelegateInstance;

            private static void _GetInfosetsDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.Infosets;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // Array<int> NumInfosets() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NumInfosetsDelegateInstance;

            private static void _NumInfosetsDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumInfosets;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // GameAction GetAction(int act) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetActionDelegateInstance;

            private static void _GetActionDelegateHook(__IntPtr __instance, __IntPtr @return, int act)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.GetAction(act);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // int NumOutcomes() const override
            private static global::gambit.Delegates.Func_int___IntPtr _NumOutcomesDelegateInstance;

            private static int _NumOutcomesDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumOutcomes;
                return ___ret;
            }

            // GameOutcome GetOutcome(int index) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetOutcomeDelegateInstance;

            private static void _GetOutcomeDelegateHook(__IntPtr __instance, __IntPtr @return, int index)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.GetOutcome(index);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameOutcome NewOutcome() override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NewOutcomeDelegateInstance;

            private static void _NewOutcomeDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.NewOutcome();
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // void DeleteOutcome(const GameOutcome &) override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _DeleteOutcomeDelegateInstance;

            private static void _DeleteOutcomeDelegateHook(__IntPtr __instance, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.__GetOrCreateInstance(_0, false);
                __target.DeleteOutcome(__result0);
            }

            // GameNode GetRoot() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetRootDelegateInstance;

            private static void _GetRootDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.Root;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // int NumNodes() const override
            private static global::gambit.Delegates.Func_int___IntPtr _NumNodesDelegateInstance;

            private static int _NumNodesDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumNodes;
                return ___ret;
            }

            // Game SetChanceProbs(const GameInfoset &, const Array<Number> &) override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr _SetChanceProbsDelegateInstance;

            private static void _SetChanceProbsDelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.GameAGGRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(_0, false);
                var __result2 = global::gambit.Gambit.Array<global::gambit.Gambit.Number>.__GetOrCreateInstance(_1, false, skipVTables: true);
                var ___ret = __target.SetChanceProbs(__result1, __result2);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[41];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _BuildComputedValuesDelegateInstance += _BuildComputedValuesDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    _IsTreeDelegateInstance += _IsTreeDelegateHook;
                    _IsAggDelegateInstance += _IsAggDelegateHook;
                    _GetTitleDelegateInstance += _GetTitleDelegateHook;
                    _SetTitleDelegateInstance += _SetTitleDelegateHook;
                    _GetCommentDelegateInstance += _GetCommentDelegateHook;
                    _SetCommentDelegateInstance += _SetCommentDelegateHook;
                    _IsConstSumDelegateInstance += _IsConstSumDelegateHook;
                    _GetMinPayoffDelegateInstance += _GetMinPayoffDelegateHook;
                    _GetMaxPayoffDelegateInstance += _GetMaxPayoffDelegateHook;
                    _IsPerfectRecallDelegateInstance += _IsPerfectRecallDelegateHook;
                    _NumActionsDelegateInstance += _NumActionsDelegateHook;
                    _NumMembersDelegateInstance += _NumMembersDelegateHook;
                    _NumStrategiesDelegateInstance += _NumStrategiesDelegateHook;
                    _GetStrategyDelegateInstance += _GetStrategyDelegateHook;
                    _NumStrategyContingenciesDelegateInstance += _NumStrategyContingenciesDelegateHook;
                    _BehavProfileLengthDelegateInstance += _BehavProfileLengthDelegateHook;
                    _MixedProfileLengthDelegateInstance += _MixedProfileLengthDelegateHook;
                    _NewPureStrategyProfileDelegateInstance += _NewPureStrategyProfileDelegateHook;
                    _NewMixedStrategyProfile_3DelegateInstance += _NewMixedStrategyProfile_3DelegateHook;
                    _NewMixedStrategyProfile_2DelegateInstance += _NewMixedStrategyProfile_2DelegateHook;
                    _NewMixedStrategyProfile_1DelegateInstance += _NewMixedStrategyProfile_1DelegateHook;
                    _NewMixedStrategyProfileDelegateInstance += _NewMixedStrategyProfileDelegateHook;
                    _NumPlayersDelegateInstance += _NumPlayersDelegateHook;
                    _GetPlayerDelegateInstance += _GetPlayerDelegateHook;
                    _GetPlayersDelegateInstance += _GetPlayersDelegateHook;
                    _GetChanceDelegateInstance += _GetChanceDelegateHook;
                    _NewPlayerDelegateInstance += _NewPlayerDelegateHook;
                    _GetInfosetDelegateInstance += _GetInfosetDelegateHook;
                    _GetInfosetsDelegateInstance += _GetInfosetsDelegateHook;
                    _NumInfosetsDelegateInstance += _NumInfosetsDelegateHook;
                    _GetActionDelegateInstance += _GetActionDelegateHook;
                    _NumOutcomesDelegateInstance += _NumOutcomesDelegateHook;
                    _GetOutcomeDelegateInstance += _GetOutcomeDelegateHook;
                    _NewOutcomeDelegateInstance += _NewOutcomeDelegateHook;
                    _DeleteOutcomeDelegateInstance += _DeleteOutcomeDelegateHook;
                    _GetRootDelegateInstance += _GetRootDelegateHook;
                    _NumNodesDelegateInstance += _NumNodesDelegateHook;
                    _SetChanceProbsDelegateInstance += _SetChanceProbsDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_BuildComputedValuesDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_IsTreeDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_IsAggDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetTitleDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_SetTitleDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetCommentDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_SetCommentDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_IsConstSumDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_GetMinPayoffDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_GetMaxPayoffDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_IsPerfectRecallDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_NumActionsDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_NumMembersDelegateInstance);
                    Thunks[15] = Marshal.GetFunctionPointerForDelegate(_NumStrategiesDelegateInstance);
                    Thunks[16] = Marshal.GetFunctionPointerForDelegate(_GetStrategyDelegateInstance);
                    Thunks[17] = Marshal.GetFunctionPointerForDelegate(_NumStrategyContingenciesDelegateInstance);
                    Thunks[18] = Marshal.GetFunctionPointerForDelegate(_BehavProfileLengthDelegateInstance);
                    Thunks[19] = Marshal.GetFunctionPointerForDelegate(_MixedProfileLengthDelegateInstance);
                    Thunks[20] = Marshal.GetFunctionPointerForDelegate(_NewPureStrategyProfileDelegateInstance);
                    Thunks[21] = Marshal.GetFunctionPointerForDelegate(_NewMixedStrategyProfile_3DelegateInstance);
                    Thunks[22] = Marshal.GetFunctionPointerForDelegate(_NewMixedStrategyProfile_2DelegateInstance);
                    Thunks[23] = Marshal.GetFunctionPointerForDelegate(_NewMixedStrategyProfile_1DelegateInstance);
                    Thunks[24] = Marshal.GetFunctionPointerForDelegate(_NewMixedStrategyProfileDelegateInstance);
                    Thunks[25] = Marshal.GetFunctionPointerForDelegate(_NumPlayersDelegateInstance);
                    Thunks[26] = Marshal.GetFunctionPointerForDelegate(_GetPlayerDelegateInstance);
                    Thunks[27] = Marshal.GetFunctionPointerForDelegate(_GetPlayersDelegateInstance);
                    Thunks[28] = Marshal.GetFunctionPointerForDelegate(_GetChanceDelegateInstance);
                    Thunks[29] = Marshal.GetFunctionPointerForDelegate(_NewPlayerDelegateInstance);
                    Thunks[30] = Marshal.GetFunctionPointerForDelegate(_GetInfosetDelegateInstance);
                    Thunks[31] = Marshal.GetFunctionPointerForDelegate(_GetInfosetsDelegateInstance);
                    Thunks[32] = Marshal.GetFunctionPointerForDelegate(_NumInfosetsDelegateInstance);
                    Thunks[33] = Marshal.GetFunctionPointerForDelegate(_GetActionDelegateInstance);
                    Thunks[34] = Marshal.GetFunctionPointerForDelegate(_NumOutcomesDelegateInstance);
                    Thunks[35] = Marshal.GetFunctionPointerForDelegate(_GetOutcomeDelegateInstance);
                    Thunks[36] = Marshal.GetFunctionPointerForDelegate(_NewOutcomeDelegateInstance);
                    Thunks[37] = Marshal.GetFunctionPointerForDelegate(_DeleteOutcomeDelegateInstance);
                    Thunks[38] = Marshal.GetFunctionPointerForDelegate(_GetRootDelegateInstance);
                    Thunks[39] = Marshal.GetFunctionPointerForDelegate(_NumNodesDelegateInstance);
                    Thunks[40] = Marshal.GetFunctionPointerForDelegate(_SetChanceProbsDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 45, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 45, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                ManagedVTables[0][7] = Thunks[7];
                                ManagedVTables[0][8] = Thunks[8];
                                ManagedVTables[0][9] = Thunks[9];
                                ManagedVTables[0][10] = Thunks[10];
                                ManagedVTables[0][11] = Thunks[11];
                                ManagedVTables[0][12] = Thunks[12];
                                ManagedVTables[0][16] = Thunks[13];
                                ManagedVTables[0][17] = Thunks[14];
                                ManagedVTables[0][18] = Thunks[15];
                                ManagedVTables[0][19] = Thunks[16];
                                ManagedVTables[0][20] = Thunks[17];
                                ManagedVTables[0][21] = Thunks[18];
                                ManagedVTables[0][22] = Thunks[19];
                                ManagedVTables[0][23] = Thunks[20];
                                ManagedVTables[0][24] = Thunks[21];
                                ManagedVTables[0][25] = Thunks[22];
                                ManagedVTables[0][26] = Thunks[23];
                                ManagedVTables[0][27] = Thunks[24];
                                ManagedVTables[0][28] = Thunks[25];
                                ManagedVTables[0][29] = Thunks[26];
                                ManagedVTables[0][30] = Thunks[27];
                                ManagedVTables[0][31] = Thunks[28];
                                ManagedVTables[0][32] = Thunks[29];
                                ManagedVTables[0][33] = Thunks[30];
                                ManagedVTables[0][34] = Thunks[31];
                                ManagedVTables[0][35] = Thunks[32];
                                ManagedVTables[0][36] = Thunks[33];
                                ManagedVTables[0][37] = Thunks[34];
                                ManagedVTables[0][38] = Thunks[35];
                                ManagedVTables[0][39] = Thunks[36];
                                ManagedVTables[0][40] = Thunks[37];
                                ManagedVTables[0][41] = Thunks[38];
                                ManagedVTables[0][42] = Thunks[39];
                                ManagedVTables[0][43] = Thunks[40];
                                VTables.Methods[0] = new Delegate[45];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Gambit
    {
        public unsafe partial class BAGGPureStrategyProfileRep
        {
            public partial struct __Internal
            {
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.BAGGPureStrategyProfileRep> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.BAGGPureStrategyProfileRep>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.BAGGPureStrategyProfileRep managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.BAGGPureStrategyProfileRep managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static BAGGPureStrategyProfileRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new BAGGPureStrategyProfileRep(native.ToPointer(), skipVTables);
            }

            internal static BAGGPureStrategyProfileRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (BAGGPureStrategyProfileRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static BAGGPureStrategyProfileRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new BAGGPureStrategyProfileRep(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private BAGGPureStrategyProfileRep(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected BAGGPureStrategyProfileRep(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }
        }

        namespace Agg
        {
            public unsafe partial class BAGG : IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 176)]
                public partial struct __Internal
                {
                    internal int numPlayers;
                    internal int numActionNodes;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I numTypes;
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_vector__d___N_std_S_allocator__d___N_std_S_allocator__S0_ indepTypeDist;
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_vector____N_std_S_vector__I___N_std_S_allocator__I___N_std_S_allocator__S1____N_std_S_allocator__S0_ typeActionSets;
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_vector____N_std_S_vector__I___N_std_S_allocator__I___N_std_S_allocator__S1____N_std_S_allocator__S0_ typeAction2ActionIndex;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I typeOffset;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I strategyOffset;
                    internal global::Std.SharedPtr.__Internal aggPtr;
                    internal byte symmetric;

                    [SuppressUnmanagedCodeSecurity, DllImport("gambit", EntryPoint = "??1BAGG@agg@Gambit@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern void dtor(__IntPtr __instance);
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Agg.BAGG> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Agg.BAGG>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.Agg.BAGG managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.Agg.BAGG managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static BAGG __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new BAGG(native.ToPointer(), skipVTables);
                }

                internal static BAGG __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (BAGG)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static BAGG __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new BAGG(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private BAGG(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected BAGG(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }
        }
    }

    namespace Gambit
    {
        public unsafe partial class GameBAGGRep : global::gambit.Gambit.GameRep, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 152)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_BaseGameRep;
                internal int m_refCount;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_title;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_comment;
                internal uint m_version;
                internal global::Std.SharedPtr.__Internal baggPtr;
                internal global::gambit.Gambit.Array.__Internal agent2baggPlayer;
                internal global::gambit.Gambit.Array.__Internal m_players;
            }

            internal static new GameBAGGRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameBAGGRep(native.ToPointer(), skipVTables);
            }

            internal static new GameBAGGRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameBAGGRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GameBAGGRep __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GameBAGGRep)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GameBAGGRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameBAGGRep(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GameBAGGRep(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GameBAGGRep(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Gets the i'th strategy in the game, numbered globally</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> GetStrategy(int p_index)
            {
                var ___GetStrategyDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 19);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetStrategyDelegate(__Instance, new IntPtr(&___ret), p_index);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.PureStrategyProfile NewPureStrategyProfile()
            {
                var ___NewPureStrategyProfileDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 23);
                var ___ret = new global::gambit.Gambit.PureStrategyProfile.__Internal();
                ___NewPureStrategyProfileDelegate(__Instance, new IntPtr(&___ret));
                var _____ret = global::gambit.Gambit.PureStrategyProfile.__CreateInstance(___ret);
                global::gambit.Gambit.PureStrategyProfile.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.MixedStrategyProfile<double> NewMixedStrategyProfile(double _0)
            {
                var ___NewMixedStrategyProfileDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_double>(0, 27);
                var ___ret = new global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d();
                ___NewMixedStrategyProfileDelegate(__Instance, new IntPtr(&___ret), _0);
                var _____ret = global::gambit.Gambit.MixedStrategyProfile<double>.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            public override global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational> NewMixedStrategyProfile(global::gambit.Gambit.Rational _0)
            {
                var ___NewMixedStrategyProfile_1Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 26);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = new global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational();
                ___NewMixedStrategyProfile_1Delegate(__Instance, new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            public override global::gambit.Gambit.MixedStrategyProfile<double> NewMixedStrategyProfile(double _0, global::gambit.Gambit.StrategySupportProfile _1)
            {
                var ___NewMixedStrategyProfile_2Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_double___IntPtr>(0, 25);
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = new global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d();
                ___NewMixedStrategyProfile_2Delegate(__Instance, new IntPtr(&___ret), _0, __arg1);
                var _____ret = global::gambit.Gambit.MixedStrategyProfile<double>.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            public override global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational> NewMixedStrategyProfile(global::gambit.Gambit.Rational _0, global::gambit.Gambit.StrategySupportProfile _1)
            {
                var ___NewMixedStrategyProfile_3Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr>(0, 24);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = new global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational();
                ___NewMixedStrategyProfile_3Delegate(__Instance, new IntPtr(&___ret), __arg0, __arg1);
                var _____ret = global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            /// <summary>Returns the pl'th player in the game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> GetPlayer(int pl)
            {
                var ___GetPlayerDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 29);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetPlayerDelegate(__Instance, new IntPtr(&___ret), pl);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Creates a new player in the game, with no moves</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> NewPlayer()
            {
                var ___NewPlayerDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 32);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___NewPlayerDelegate(__Instance, new IntPtr(&___ret));
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the iset'th information set in the game (numbered globally)</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> GetInfoset(int iset)
            {
                var ___GetInfosetDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 33);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetInfosetDelegate(__Instance, new IntPtr(&___ret), iset);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the act'th action in the game (numbered globally)</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> GetAction(int act)
            {
                var ___GetActionDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 36);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetActionDelegate(__Instance, new IntPtr(&___ret), act);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the index'th outcome defined in the game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> GetOutcome(int index)
            {
                var ___GetOutcomeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 38);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetOutcomeDelegate(__Instance, new IntPtr(&___ret), index);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameOutcomeRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Creates a new outcome in the game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> NewOutcome()
            {
                var ___NewOutcomeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 39);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___NewOutcomeDelegate(__Instance, new IntPtr(&___ret));
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameOutcomeRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Deletes the specified outcome from the game</summary>
            public override void DeleteOutcome(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> _0)
            {
                var ___DeleteOutcomeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 40);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                ___DeleteOutcomeDelegate(__Instance, __arg0);
            }

            public override bool IsPerfectRecall(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> _0, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> _1)
            {
                var ___IsPerfectRecallDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr___IntPtr___IntPtr>(0, 12);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = ___IsPerfectRecallDelegate(__Instance, __arg0, __arg1);
                return ___ret;
            }

            /// <summary>Returns the smallest payoff in any outcome of the game</summary>
            public override global::gambit.Gambit.Rational GetMinPayoff(int _0)
            {
                var ___GetMinPayoffDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 10);
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                ___GetMinPayoffDelegate(__Instance, new IntPtr(&___ret), _0);
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the largest payoff in any outcome of the game</summary>
            public override global::gambit.Gambit.Rational GetMaxPayoff(int _0)
            {
                var ___GetMaxPayoffDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 11);
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                ___GetMaxPayoffDelegate(__Instance, new IntPtr(&___ret), _0);
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> SetChanceProbs(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> _0, global::gambit.Gambit.Array<global::gambit.Gambit.Number> _1)
            {
                var ___SetChanceProbsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr>(0, 43);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___SetChanceProbsDelegate(__Instance, new IntPtr(&___ret), __arg0, __arg1);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Create a copy of the game, as a new game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 2);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___CopyDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>The number of actions in each information set</summary>
            public override global::gambit.Gambit.PVector<int> NumActions
            {
                get
                {
                    var ___NumActionsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 16);
                    var ___ret = new global::gambit.Gambit.PVector.__Internal();
                    ___NumActionsDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.PVector<int>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>The number of members in each information set</summary>
            public override global::gambit.Gambit.PVector<int> NumMembers
            {
                get
                {
                    var ___NumMembersDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 17);
                    var ___ret = new global::gambit.Gambit.PVector.__Internal();
                    ___NumMembersDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.PVector<int>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>The number of strategies for each player</summary>
            public override global::gambit.Gambit.Array<int> NumStrategies
            {
                get
                {
                    var ___NumStrategiesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 18);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___NumStrategiesDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<int>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>Returns the number of strategy contingencies in the game</summary>
            public override int NumStrategyContingencies
            {
                get
                {
                    var ___NumStrategyContingenciesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 20);
                    var ___ret = ___NumStrategyContingenciesDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the total number of actions in the game</summary>
            public override int BehavProfileLength
            {
                get
                {
                    var ___BehavProfileLengthDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 21);
                    var ___ret = ___BehavProfileLengthDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the total number of strategies in the game</summary>
            public override int MixedProfileLength
            {
                get
                {
                    var ___MixedProfileLengthDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 22);
                    var ___ret = ___MixedProfileLengthDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the number of players in the game</summary>
            public override int NumPlayers
            {
                get
                {
                    var ___NumPlayersDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 28);
                    var ___ret = ___NumPlayersDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the chance (nature) player</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> Chance
            {
                get
                {
                    var ___GetChanceDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 31);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetChanceDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Returns the set of information sets in the game</summary>
            public override global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>> Infosets
            {
                get
                {
                    var ___GetInfosetsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 34);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___GetInfosetsDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>Returns an array with the number of information sets per personal player</summary>
            public override global::gambit.Gambit.Array<int> NumInfosets
            {
                get
                {
                    var ___NumInfosetsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 35);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___NumInfosetsDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<int>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>Returns the number of outcomes defined in the game</summary>
            public override int NumOutcomes
            {
                get
                {
                    var ___NumOutcomesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 37);
                    var ___ret = ___NumOutcomesDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the root node of the game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> Root
            {
                get
                {
                    var ___GetRootDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 41);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetRootDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Returns the number of nodes in the game</summary>
            public override int NumNodes
            {
                get
                {
                    var ___NumNodesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 42);
                    var ___ret = ___NumNodesDelegate(__Instance);
                    return ___ret;
                }
            }

            public override bool IsTree
            {
                get
                {
                    var ___IsTreeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr>(0, 3);
                    var ___ret = ___IsTreeDelegate(__Instance);
                    return ___ret;
                }
            }

            public virtual bool IsBagg
            {
                get
                {
                    var ___IsBaggDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr>(0, 44);
                    var ___ret = ___IsBaggDelegate(__Instance);
                    return ___ret;
                }
            }

            public override bool IsConstSum
            {
                get
                {
                    var ___IsConstSumDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr>(0, 9);
                    var ___ret = ___IsConstSumDelegate(__Instance);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // ~GameBAGGRep() override
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // void BuildComputedValues()
            private static global::gambit.Delegates.Action___IntPtr _BuildComputedValuesDelegateInstance;

            private static void _BuildComputedValuesDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                __target.BuildComputedValues();
            }

            // Game Copy() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _CopyDelegateInstance;

            private static void _CopyDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.Copy;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // bool IsTree() const override
            private static global::gambit.Delegates.Func_bool___IntPtr _IsTreeDelegateInstance;

            private static bool _IsTreeDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.IsTree;
                return ___ret;
            }

            // bool IsAgg() const
            private static global::gambit.Delegates.Func_bool___IntPtr _IsAggDelegateInstance;

            private static bool _IsAggDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.IsAgg;
                return ___ret;
            }

            // std::string &GetTitle() const
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _GetTitleDelegateInstance;

            private static __IntPtr _GetTitleDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.Title;
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                return __basicString0.__Instance;
            }

            // void SetTitle(const std::string &p_title)
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetTitleDelegateInstance;

            private static void _SetTitleDelegateHook(__IntPtr __instance, __IntPtr p_title)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(p_title);
                __target.Title = global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            // std::string &GetComment() const
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _GetCommentDelegateInstance;

            private static __IntPtr _GetCommentDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.Comment;
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                return __basicString0.__Instance;
            }

            // void SetComment(const std::string &p_comment)
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetCommentDelegateInstance;

            private static void _SetCommentDelegateHook(__IntPtr __instance, __IntPtr p_comment)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(p_comment);
                __target.Comment = global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            // bool IsConstSum() const override
            private static global::gambit.Delegates.Func_bool___IntPtr _IsConstSumDelegateInstance;

            private static bool _IsConstSumDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.IsConstSum;
                return ___ret;
            }

            // Rational GetMinPayoff(int) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetMinPayoffDelegateInstance;

            private static void _GetMinPayoffDelegateHook(__IntPtr __instance, __IntPtr @return, int _0)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.GetMinPayoff(_0);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Rational.__Internal*) @return = *(global::gambit.Gambit.Rational.__Internal*) ___ret.__Instance;
            }

            // Rational GetMaxPayoff(int) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetMaxPayoffDelegateInstance;

            private static void _GetMaxPayoffDelegateHook(__IntPtr __instance, __IntPtr @return, int _0)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.GetMaxPayoff(_0);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Rational.__Internal*) @return = *(global::gambit.Gambit.Rational.__Internal*) ___ret.__Instance;
            }

            // bool IsPerfectRecall(GameInfoset &, GameInfoset &) const override
            private static global::gambit.Delegates.Func_bool___IntPtr___IntPtr___IntPtr _IsPerfectRecallDelegateInstance;

            private static bool _IsPerfectRecallDelegateHook(__IntPtr __instance, __IntPtr _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(_0, false);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(_1, false);
                var ___ret = __target.IsPerfectRecall(__result0, __result1);
                return ___ret;
            }

            // PVector<int> NumActions() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NumActionsDelegateInstance;

            private static void _NumActionsDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumActions;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.PVector.__Internal*) @return = *(global::gambit.Gambit.PVector.__Internal*) ___ret.__Instance;
            }

            // PVector<int> NumMembers() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NumMembersDelegateInstance;

            private static void _NumMembersDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumMembers;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.PVector.__Internal*) @return = *(global::gambit.Gambit.PVector.__Internal*) ___ret.__Instance;
            }

            // Array<int> NumStrategies() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NumStrategiesDelegateInstance;

            private static void _NumStrategiesDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumStrategies;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // GameStrategy GetStrategy(int p_index) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetStrategyDelegateInstance;

            private static void _GetStrategyDelegateHook(__IntPtr __instance, __IntPtr @return, int p_index)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.GetStrategy(p_index);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // int NumStrategyContingencies() const override
            private static global::gambit.Delegates.Func_int___IntPtr _NumStrategyContingenciesDelegateInstance;

            private static int _NumStrategyContingenciesDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumStrategyContingencies;
                return ___ret;
            }

            // int BehavProfileLength() const override
            private static global::gambit.Delegates.Func_int___IntPtr _BehavProfileLengthDelegateInstance;

            private static int _BehavProfileLengthDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.BehavProfileLength;
                return ___ret;
            }

            // int MixedProfileLength() const override
            private static global::gambit.Delegates.Func_int___IntPtr _MixedProfileLengthDelegateInstance;

            private static int _MixedProfileLengthDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.MixedProfileLength;
                return ___ret;
            }

            // PureStrategyProfile NewPureStrategyProfile() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NewPureStrategyProfileDelegateInstance;

            private static void _NewPureStrategyProfileDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NewPureStrategyProfile();
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.PureStrategyProfile.__Internal*) @return = *(global::gambit.Gambit.PureStrategyProfile.__Internal*) ___ret.__Instance;
            }

            // MixedStrategyProfile<Rational> NewMixedStrategyProfile(const Rational &, const StrategySupportProfile &) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr _NewMixedStrategyProfile_3DelegateInstance;

            private static void _NewMixedStrategyProfile_3DelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.Rational.__GetOrCreateInstance(_0, false);
                var __result2 = global::gambit.Gambit.StrategySupportProfile.__GetOrCreateInstance(_1, false);
                var ___ret = __target.NewMixedStrategyProfile(__result1, __result2);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) @return = *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) ___ret.__Instance;
            }

            // MixedStrategyProfile<double> NewMixedStrategyProfile(double, const StrategySupportProfile &) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_double___IntPtr _NewMixedStrategyProfile_2DelegateInstance;

            private static void _NewMixedStrategyProfile_2DelegateHook(__IntPtr __instance, __IntPtr @return, double _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var __result2 = global::gambit.Gambit.StrategySupportProfile.__GetOrCreateInstance(_1, false);
                var ___ret = __target.NewMixedStrategyProfile(_0, __result2);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) @return = *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) ___ret.__Instance;
            }

            // MixedStrategyProfile<Rational> NewMixedStrategyProfile(const Rational &) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr _NewMixedStrategyProfile_1DelegateInstance;

            private static void _NewMixedStrategyProfile_1DelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.Rational.__GetOrCreateInstance(_0, false);
                var ___ret = __target.NewMixedStrategyProfile(__result1);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) @return = *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) ___ret.__Instance;
            }

            // MixedStrategyProfile<double> NewMixedStrategyProfile(double) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_double _NewMixedStrategyProfileDelegateInstance;

            private static void _NewMixedStrategyProfileDelegateHook(__IntPtr __instance, __IntPtr @return, double _0)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NewMixedStrategyProfile(_0);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) @return = *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) ___ret.__Instance;
            }

            // int NumPlayers() const override
            private static global::gambit.Delegates.Func_int___IntPtr _NumPlayersDelegateInstance;

            private static int _NumPlayersDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumPlayers;
                return ___ret;
            }

            // GamePlayer GetPlayer(int pl) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetPlayerDelegateInstance;

            private static void _GetPlayerDelegateHook(__IntPtr __instance, __IntPtr @return, int pl)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.GetPlayer(pl);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // Array<GamePlayer> GetPlayers() const
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetPlayersDelegateInstance;

            private static void _GetPlayersDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.Players;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // GamePlayer GetChance() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetChanceDelegateInstance;

            private static void _GetChanceDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.Chance;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GamePlayer NewPlayer() override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NewPlayerDelegateInstance;

            private static void _NewPlayerDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NewPlayer();
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameInfoset GetInfoset(int iset) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetInfosetDelegateInstance;

            private static void _GetInfosetDelegateHook(__IntPtr __instance, __IntPtr @return, int iset)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.GetInfoset(iset);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // Array<GameInfoset> GetInfosets() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetInfosetsDelegateInstance;

            private static void _GetInfosetsDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.Infosets;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // Array<int> NumInfosets() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NumInfosetsDelegateInstance;

            private static void _NumInfosetsDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumInfosets;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // GameAction GetAction(int act) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetActionDelegateInstance;

            private static void _GetActionDelegateHook(__IntPtr __instance, __IntPtr @return, int act)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.GetAction(act);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // int NumOutcomes() const override
            private static global::gambit.Delegates.Func_int___IntPtr _NumOutcomesDelegateInstance;

            private static int _NumOutcomesDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumOutcomes;
                return ___ret;
            }

            // GameOutcome GetOutcome(int index) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetOutcomeDelegateInstance;

            private static void _GetOutcomeDelegateHook(__IntPtr __instance, __IntPtr @return, int index)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.GetOutcome(index);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameOutcome NewOutcome() override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NewOutcomeDelegateInstance;

            private static void _NewOutcomeDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NewOutcome();
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // void DeleteOutcome(const GameOutcome &) override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _DeleteOutcomeDelegateInstance;

            private static void _DeleteOutcomeDelegateHook(__IntPtr __instance, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.__GetOrCreateInstance(_0, false);
                __target.DeleteOutcome(__result0);
            }

            // GameNode GetRoot() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetRootDelegateInstance;

            private static void _GetRootDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.Root;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // int NumNodes() const override
            private static global::gambit.Delegates.Func_int___IntPtr _NumNodesDelegateInstance;

            private static int _NumNodesDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumNodes;
                return ___ret;
            }

            // Game SetChanceProbs(const GameInfoset &, const Array<Number> &) override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr _SetChanceProbsDelegateInstance;

            private static void _SetChanceProbsDelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(_0, false);
                var __result2 = global::gambit.Gambit.Array<global::gambit.Gambit.Number>.__GetOrCreateInstance(_1, false, skipVTables: true);
                var ___ret = __target.SetChanceProbs(__result1, __result2);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // bool IsBagg() const
            private static global::gambit.Delegates.Func_bool___IntPtr _IsBaggDelegateInstance;

            private static bool _IsBaggDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.IsBagg;
                return ___ret;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[42];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _BuildComputedValuesDelegateInstance += _BuildComputedValuesDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    _IsTreeDelegateInstance += _IsTreeDelegateHook;
                    _IsAggDelegateInstance += _IsAggDelegateHook;
                    _GetTitleDelegateInstance += _GetTitleDelegateHook;
                    _SetTitleDelegateInstance += _SetTitleDelegateHook;
                    _GetCommentDelegateInstance += _GetCommentDelegateHook;
                    _SetCommentDelegateInstance += _SetCommentDelegateHook;
                    _IsConstSumDelegateInstance += _IsConstSumDelegateHook;
                    _GetMinPayoffDelegateInstance += _GetMinPayoffDelegateHook;
                    _GetMaxPayoffDelegateInstance += _GetMaxPayoffDelegateHook;
                    _IsPerfectRecallDelegateInstance += _IsPerfectRecallDelegateHook;
                    _NumActionsDelegateInstance += _NumActionsDelegateHook;
                    _NumMembersDelegateInstance += _NumMembersDelegateHook;
                    _NumStrategiesDelegateInstance += _NumStrategiesDelegateHook;
                    _GetStrategyDelegateInstance += _GetStrategyDelegateHook;
                    _NumStrategyContingenciesDelegateInstance += _NumStrategyContingenciesDelegateHook;
                    _BehavProfileLengthDelegateInstance += _BehavProfileLengthDelegateHook;
                    _MixedProfileLengthDelegateInstance += _MixedProfileLengthDelegateHook;
                    _NewPureStrategyProfileDelegateInstance += _NewPureStrategyProfileDelegateHook;
                    _NewMixedStrategyProfile_3DelegateInstance += _NewMixedStrategyProfile_3DelegateHook;
                    _NewMixedStrategyProfile_2DelegateInstance += _NewMixedStrategyProfile_2DelegateHook;
                    _NewMixedStrategyProfile_1DelegateInstance += _NewMixedStrategyProfile_1DelegateHook;
                    _NewMixedStrategyProfileDelegateInstance += _NewMixedStrategyProfileDelegateHook;
                    _NumPlayersDelegateInstance += _NumPlayersDelegateHook;
                    _GetPlayerDelegateInstance += _GetPlayerDelegateHook;
                    _GetPlayersDelegateInstance += _GetPlayersDelegateHook;
                    _GetChanceDelegateInstance += _GetChanceDelegateHook;
                    _NewPlayerDelegateInstance += _NewPlayerDelegateHook;
                    _GetInfosetDelegateInstance += _GetInfosetDelegateHook;
                    _GetInfosetsDelegateInstance += _GetInfosetsDelegateHook;
                    _NumInfosetsDelegateInstance += _NumInfosetsDelegateHook;
                    _GetActionDelegateInstance += _GetActionDelegateHook;
                    _NumOutcomesDelegateInstance += _NumOutcomesDelegateHook;
                    _GetOutcomeDelegateInstance += _GetOutcomeDelegateHook;
                    _NewOutcomeDelegateInstance += _NewOutcomeDelegateHook;
                    _DeleteOutcomeDelegateInstance += _DeleteOutcomeDelegateHook;
                    _GetRootDelegateInstance += _GetRootDelegateHook;
                    _NumNodesDelegateInstance += _NumNodesDelegateHook;
                    _SetChanceProbsDelegateInstance += _SetChanceProbsDelegateHook;
                    _IsBaggDelegateInstance += _IsBaggDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_BuildComputedValuesDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_IsTreeDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_IsAggDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetTitleDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_SetTitleDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetCommentDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_SetCommentDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_IsConstSumDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_GetMinPayoffDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_GetMaxPayoffDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_IsPerfectRecallDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_NumActionsDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_NumMembersDelegateInstance);
                    Thunks[15] = Marshal.GetFunctionPointerForDelegate(_NumStrategiesDelegateInstance);
                    Thunks[16] = Marshal.GetFunctionPointerForDelegate(_GetStrategyDelegateInstance);
                    Thunks[17] = Marshal.GetFunctionPointerForDelegate(_NumStrategyContingenciesDelegateInstance);
                    Thunks[18] = Marshal.GetFunctionPointerForDelegate(_BehavProfileLengthDelegateInstance);
                    Thunks[19] = Marshal.GetFunctionPointerForDelegate(_MixedProfileLengthDelegateInstance);
                    Thunks[20] = Marshal.GetFunctionPointerForDelegate(_NewPureStrategyProfileDelegateInstance);
                    Thunks[21] = Marshal.GetFunctionPointerForDelegate(_NewMixedStrategyProfile_3DelegateInstance);
                    Thunks[22] = Marshal.GetFunctionPointerForDelegate(_NewMixedStrategyProfile_2DelegateInstance);
                    Thunks[23] = Marshal.GetFunctionPointerForDelegate(_NewMixedStrategyProfile_1DelegateInstance);
                    Thunks[24] = Marshal.GetFunctionPointerForDelegate(_NewMixedStrategyProfileDelegateInstance);
                    Thunks[25] = Marshal.GetFunctionPointerForDelegate(_NumPlayersDelegateInstance);
                    Thunks[26] = Marshal.GetFunctionPointerForDelegate(_GetPlayerDelegateInstance);
                    Thunks[27] = Marshal.GetFunctionPointerForDelegate(_GetPlayersDelegateInstance);
                    Thunks[28] = Marshal.GetFunctionPointerForDelegate(_GetChanceDelegateInstance);
                    Thunks[29] = Marshal.GetFunctionPointerForDelegate(_NewPlayerDelegateInstance);
                    Thunks[30] = Marshal.GetFunctionPointerForDelegate(_GetInfosetDelegateInstance);
                    Thunks[31] = Marshal.GetFunctionPointerForDelegate(_GetInfosetsDelegateInstance);
                    Thunks[32] = Marshal.GetFunctionPointerForDelegate(_NumInfosetsDelegateInstance);
                    Thunks[33] = Marshal.GetFunctionPointerForDelegate(_GetActionDelegateInstance);
                    Thunks[34] = Marshal.GetFunctionPointerForDelegate(_NumOutcomesDelegateInstance);
                    Thunks[35] = Marshal.GetFunctionPointerForDelegate(_GetOutcomeDelegateInstance);
                    Thunks[36] = Marshal.GetFunctionPointerForDelegate(_NewOutcomeDelegateInstance);
                    Thunks[37] = Marshal.GetFunctionPointerForDelegate(_DeleteOutcomeDelegateInstance);
                    Thunks[38] = Marshal.GetFunctionPointerForDelegate(_GetRootDelegateInstance);
                    Thunks[39] = Marshal.GetFunctionPointerForDelegate(_NumNodesDelegateInstance);
                    Thunks[40] = Marshal.GetFunctionPointerForDelegate(_SetChanceProbsDelegateInstance);
                    Thunks[41] = Marshal.GetFunctionPointerForDelegate(_IsBaggDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 46, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 46, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                ManagedVTables[0][7] = Thunks[7];
                                ManagedVTables[0][8] = Thunks[8];
                                ManagedVTables[0][9] = Thunks[9];
                                ManagedVTables[0][10] = Thunks[10];
                                ManagedVTables[0][11] = Thunks[11];
                                ManagedVTables[0][12] = Thunks[12];
                                ManagedVTables[0][16] = Thunks[13];
                                ManagedVTables[0][17] = Thunks[14];
                                ManagedVTables[0][18] = Thunks[15];
                                ManagedVTables[0][19] = Thunks[16];
                                ManagedVTables[0][20] = Thunks[17];
                                ManagedVTables[0][21] = Thunks[18];
                                ManagedVTables[0][22] = Thunks[19];
                                ManagedVTables[0][23] = Thunks[20];
                                ManagedVTables[0][24] = Thunks[21];
                                ManagedVTables[0][25] = Thunks[22];
                                ManagedVTables[0][26] = Thunks[23];
                                ManagedVTables[0][27] = Thunks[24];
                                ManagedVTables[0][28] = Thunks[25];
                                ManagedVTables[0][29] = Thunks[26];
                                ManagedVTables[0][30] = Thunks[27];
                                ManagedVTables[0][31] = Thunks[28];
                                ManagedVTables[0][32] = Thunks[29];
                                ManagedVTables[0][33] = Thunks[30];
                                ManagedVTables[0][34] = Thunks[31];
                                ManagedVTables[0][35] = Thunks[32];
                                ManagedVTables[0][36] = Thunks[33];
                                ManagedVTables[0][37] = Thunks[34];
                                ManagedVTables[0][38] = Thunks[35];
                                ManagedVTables[0][39] = Thunks[36];
                                ManagedVTables[0][40] = Thunks[37];
                                ManagedVTables[0][41] = Thunks[38];
                                ManagedVTables[0][42] = Thunks[39];
                                ManagedVTables[0][43] = Thunks[40];
                                ManagedVTables[0][44] = Thunks[41];
                                VTables.Methods[0] = new Delegate[46];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_int(__IntPtr __instance, int arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr_int(__IntPtr __instance, __IntPtr arg1, int arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool___IntPtr___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate int Func_int___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr_double(__IntPtr __instance, __IntPtr arg1, double arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr_double___IntPtr(__IntPtr __instance, __IntPtr arg1, double arg2, __IntPtr arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2, __IntPtr arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_int(__IntPtr __instance, int arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr___IntPtr_int(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2, int arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr_int___IntPtr(__IntPtr __instance, __IntPtr arg1, int arg2, __IntPtr arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr_int___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1, int arg2, __IntPtr arg3, __IntPtr arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate double Func_double___IntPtr_int(__IntPtr __instance, int arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate double Func_double___IntPtr_int___IntPtr(__IntPtr __instance, int arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate double Func_double___IntPtr_int___IntPtr___IntPtr(__IntPtr __instance, int arg1, __IntPtr arg2, __IntPtr arg3);
    }
}

namespace Std
{
    namespace CompressedPair
    {
        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S_vector____N_std_S_shared_ptr____N_Gambit_N_agg_S_proj_func___N_std_S_allocator__S2____N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1
        {
            internal global::Std.VectorVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S_vector____N_Gambit_N_agg_S_trie_map__d___N_std_S_allocator__S2____N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1
        {
            internal global::Std.VectorVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_Gambit_N_agg_S_trie_map__d___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1
        {
            internal global::Std.VectorVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator_____N_Gambit_N_agg_S_TrieNode__d___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1
        {
            internal global::Std.VectorVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S_shared_ptr____N_Gambit_N_agg_S_proj_func___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1
        {
            internal global::Std.VectorVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep_d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1
        {
            internal global::Std.TreeVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1__d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep_d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1 _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep_d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1
        {
            internal global::Std.TreeVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1__d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep_d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1 _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep_d___N_std_S_less__S6____N_std_S_allocator____N_std_S_pair__1S6__d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1
        {
            internal global::Std.TreeVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1____N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep_d___N_std_S_less__S8____N_std_S_allocator____N_std_S_pair__1S8__d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep_d___N_std_S_less__S6____N_std_S_allocator____N_std_S_pair__1S6__d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1 _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep_d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1
        {
            internal global::Std.TreeVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1__d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep_d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1 _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep_d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1
        {
            internal global::Std.TreeVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1__d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep_d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1 _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep_d___N_std_S_less__S6____N_std_S_allocator____N_std_S_pair__1S6__d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1
        {
            internal global::Std.TreeVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1____N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep_d___N_std_S_less__S8____N_std_S_allocator____N_std_S_pair__1S8__d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep_d___N_std_S_less__S6____N_std_S_allocator____N_std_S_pair__1S6__d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1 _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep___N_Gambit_S_Rational__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1
        {
            internal global::Std.TreeVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1____N_Gambit_S_Rational__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep___N_Gambit_S_Rational__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1 _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep___N_Gambit_S_Rational__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1
        {
            internal global::Std.TreeVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1____N_Gambit_S_Rational__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep___N_Gambit_S_Rational__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1 _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_Gambit_S_Rational___N_std_S_less__S6____N_std_S_allocator____N_std_S_pair__1S6__S8___v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1
        {
            internal global::Std.TreeVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1____N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_Gambit_S_Rational___N_std_S_less__S8____N_std_S_allocator____N_std_S_pair__1S8__S10___v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_Gambit_S_Rational___N_std_S_less__S6____N_std_S_allocator____N_std_S_pair__1S6__S8___v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1 _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_Gambit_S_Rational__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1
        {
            internal global::Std.TreeVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1____N_Gambit_S_Rational__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_Gambit_S_Rational__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1 _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_Gambit_S_Rational__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1
        {
            internal global::Std.TreeVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1____N_Gambit_S_Rational__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_Gambit_S_Rational__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1 _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep___N_Gambit_S_Rational___N_std_S_less__S6____N_std_S_allocator____N_std_S_pair__1S6__S8___v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1
        {
            internal global::Std.TreeVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1____N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep___N_Gambit_S_Rational___N_std_S_less__S8____N_std_S_allocator____N_std_S_pair__1S8__S10___v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep___N_Gambit_S_Rational___N_std_S_less__S6____N_std_S_allocator____N_std_S_pair__1S6__S8___v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1 _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep_b__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1
        {
            internal global::Std.TreeVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1__b__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep_b__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1 _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep_b__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1
        {
            internal global::Std.TreeVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1__b__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep_b__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S2__Vb1 _Myval2;
        }
    }

}
namespace Std
{
    namespace Map
    {
        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep_d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__d
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1__d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep_d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__d
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1__d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep_d___N_std_S_less__S3____N_std_S_allocator____N_std_S_pair__1S3__d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1____N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep_d___N_std_S_less__S8____N_std_S_allocator____N_std_S_pair__1S8__d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep_d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__d
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1__d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep_d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__d
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1__d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep_d___N_std_S_less__S3____N_std_S_allocator____N_std_S_pair__1S3__d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1____N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep_d___N_std_S_less__S8____N_std_S_allocator____N_std_S_pair__1S8__d__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep___N_Gambit_S_Rational___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1____N_Gambit_S_Rational__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep___N_Gambit_S_Rational___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1____N_Gambit_S_Rational__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_Gambit_S_Rational___N_std_S_less__S3____N_std_S_allocator____N_std_S_pair__1S3__S5____N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1____N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_Gambit_S_Rational___N_std_S_less__S8____N_std_S_allocator____N_std_S_pair__1S8__S10___v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_Gambit_S_Rational___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1____N_Gambit_S_Rational__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_Gambit_S_Rational___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1____N_Gambit_S_Rational__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep___N_Gambit_S_Rational___N_std_S_less__S3____N_std_S_allocator____N_std_S_pair__1S3__S5____N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1____N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep___N_Gambit_S_Rational___N_std_S_less__S8____N_std_S_allocator____N_std_S_pair__1S8__S10___v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep_b___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__b
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1__b__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep_b___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__b
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_less____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep___N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__Tree_node____N_std_S_pair__1S1__b__v___N_std_S__Tree_val____N_std_S__Tree_simple_types__S6__Vb1_Vb1 _Mypair;
        }
    }

}
namespace Std
{
    namespace Vector
    {
        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_vector____N_std_S_vector____N_std_S_shared_ptr____N_Gambit_N_agg_S_proj_func___N_std_S_allocator__S1____N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S_vector____N_std_S_shared_ptr____N_Gambit_N_agg_S_proj_func___N_std_S_allocator__S2____N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_vector____N_std_S_vector____N_Gambit_N_agg_S_trie_map__d___N_std_S_allocator__S1____N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S_vector____N_Gambit_N_agg_S_trie_map__d___N_std_S_allocator__S2____N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_vector____N_Gambit_N_agg_S_trie_map__d___N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_Gambit_N_agg_S_trie_map__d___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_vector_____N_Gambit_N_agg_S_TrieNode__d___N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator_____N_Gambit_N_agg_S_TrieNode__d___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_vector____N_std_S_shared_ptr____N_Gambit_N_agg_S_proj_func___N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S_shared_ptr____N_Gambit_N_agg_S_proj_func___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1 _Mypair;
        }
    }
}
