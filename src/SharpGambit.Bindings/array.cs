// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace gambit
{
    namespace Gambit
    {
        namespace Array
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public unsafe partial struct __Internal
            {
                internal __IntPtr vfptr_Array;
                internal int mindex;
                internal int maxdex;
                internal __IntPtr data;
            }

            namespace Iterator
            {
                [StructLayout(LayoutKind.Sequential, Size = 16)]
                public unsafe partial struct __Internal
                {
                    internal __IntPtr m_array;
                    internal int m_index;
                }
            }

        }

        /// <summary>A basic bounds-checked array</summary>
        public unsafe partial class Array<T> : IDisposable
        {
            public unsafe partial class Iterator : IDisposable
            {
                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Array<T>.Iterator> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Array<T>.Iterator>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.Array<T>.Iterator managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.Array<T>.Iterator managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static Iterator __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new Iterator(native.ToPointer(), skipVTables);
                }

                internal static Iterator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (Iterator)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                protected Iterator(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public Iterator(global::gambit.Gambit.Array<T> p_array, int p_index)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.Array<T>.Iterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public static global::gambit.Gambit.Array<T>.Iterator operator ++(global::gambit.Gambit.Array<T>.Iterator __op)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.Array<T>.Iterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public static bool operator ==(global::gambit.Gambit.Array<T>.Iterator __op, global::gambit.Gambit.Array<T>.Iterator it)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.Array<T>.Iterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public override bool Equals(object obj)
                {
                    return this == obj as global::gambit.Gambit.Array<T>.Iterator;
                }

                public override int GetHashCode()
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.Array<T>.Iterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public static bool operator !=(global::gambit.Gambit.Array<T>.Iterator __op, global::gambit.Gambit.Array<T>.Iterator it)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.Array<T>.Iterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }
            }

            public unsafe partial class ConstIterator : IDisposable
            {
                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Array<T>.ConstIterator> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Array<T>.ConstIterator>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.Array<T>.ConstIterator managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.Array<T>.ConstIterator managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static ConstIterator __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new ConstIterator(native.ToPointer(), skipVTables);
                }

                internal static ConstIterator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (ConstIterator)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                protected ConstIterator(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public ConstIterator(global::gambit.Gambit.Array<T> p_array, int p_index)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.Array<T>.ConstIterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public static global::gambit.Gambit.Array<T>.ConstIterator operator ++(global::gambit.Gambit.Array<T>.ConstIterator __op)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.Array<T>.ConstIterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public static bool operator ==(global::gambit.Gambit.Array<T>.ConstIterator __op, global::gambit.Gambit.Array<T>.ConstIterator it)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.Array<T>.ConstIterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public override bool Equals(object obj)
                {
                    return this == obj as global::gambit.Gambit.Array<T>.ConstIterator;
                }

                public override int GetHashCode()
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.Array<T>.ConstIterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }

                public static bool operator !=(global::gambit.Gambit.Array<T>.ConstIterator __op, global::gambit.Gambit.Array<T>.ConstIterator it)
                {
                    throw new ArgumentOutOfRangeException("", "", "global::gambit.Gambit.Array<T>.ConstIterator maps a C++ template class and therefore it only supports a limited set of types and their subclasses: .");
                }
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Array<T>> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Array<T>>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.Array<T> managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.Array<T> managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Array<T> __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Array<T>(native.ToPointer(), skipVTables);
            }

            internal static Array<T> __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Array<T>)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Array<T> __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (Array<T>)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static Array<T> __CreateInstance(global::gambit.Gambit.Array.__Internal native, bool skipVTables = false)
            {
                return new Array<T>(native, skipVTables);
            }

            private static void* __CopyValue(global::gambit.Gambit.Array.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.Array.__Internal));
                *(global::gambit.Gambit.Array.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Array(global::gambit.Gambit.Array.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Array(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            /// <summary>Constructs an array of length 'len', starting at '1'</summary>
            public Array(uint len = 0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<bool>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
            }

            /// <summary>Constructs an array starting at lo and ending at hi</summary>
            public Array(int lo, int hi)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<bool>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
            }

            /// <summary>Copy the contents of another array</summary>
            public Array(global::gambit.Gambit.Array<T> a)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    throw new MissingMethodException("Method Array_T_ ignored in specialization global::gambit.Gambit.Array<bool>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Test the equality of two arrays</summary>
            public static bool operator ==(global::gambit.Gambit.Array<T> __op, global::gambit.Gambit.Array<T> a)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<bool>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::gambit.Gambit.Array<T>;
            }

            public override int GetHashCode()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Array.__Internal*) __Instance).GetHashCode();
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
            }

            /// <summary>Test the inequality of two arrays</summary>
            public static bool operator !=(global::gambit.Gambit.Array<T> __op, global::gambit.Gambit.Array<T> a)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Array<bool>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
            }

            /// <summary>Return a forward iterator starting at the beginning of the array</summary>
            public global::gambit.Gambit.Array<T>.Iterator Begin()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    throw new MissingMethodException("Method Begin ignored in specialization global::gambit.Gambit.Array<bool>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
            }

            /// <summary>Return a forward iterator past the end of the array</summary>
            public global::gambit.Gambit.Array<T>.Iterator End()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    throw new MissingMethodException("Method End ignored in specialization global::gambit.Gambit.Array<bool>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
            }

            /// <summary>Remove an element from the array.</summary>
            /// <remarks>
            /// <para>Remove the element at a given index from the array.  Returns the value</para>
            /// <para>of the element removed.</para>
            /// </remarks>
            public T Remove(int n)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    throw new MissingMethodException("Method Remove ignored in specialization global::gambit.Gambit.Array<bool>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
            }

            /// <summary>
            /// <para>Removes all elements from the array container (which are destroyed),</para>
            /// <para>leaving the container with a size of 0.</para>
            /// </summary>
            public void Clear()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                }
                if (__T.IsAssignableFrom(typeof(bool)))
                {
                    throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Array<bool>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
            }

            public static explicit operator global::gambit.Gambit.Array<T>(uint len)
            {
                return new global::gambit.Gambit.Array<T>(len);
            }

            public T this[int index]
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<int>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<bool>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<int>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.Array<bool>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            protected int Mindex
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->mindex = value;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            protected int Maxdex
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        return ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->maxdex = value;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            public T Data
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        return (T) (object) ((global::gambit.Gambit.Array.__Internal*)__Instance)->data;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(((global::gambit.Gambit.Array.__Internal*)__Instance)->data, false);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.__GetOrCreateInstance(((global::gambit.Gambit.Array.__Internal*)__Instance)->data, false);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__GetOrCreateInstance(((global::gambit.Gambit.Array.__Internal*)__Instance)->data, false);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__GetOrCreateInstance(((global::gambit.Gambit.Array.__Internal*)__Instance)->data, false);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        var __result0 = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.__GetOrCreateInstance(((global::gambit.Gambit.Array.__Internal*)__Instance)->data, true);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__GetOrCreateInstance(((global::gambit.Gambit.Array.__Internal*)__Instance)->data, false);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        var __result0 = global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.__GetOrCreateInstance(((global::gambit.Gambit.Array.__Internal*)__Instance)->data, true);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        var __result0 = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.__GetOrCreateInstance(((global::gambit.Gambit.Array.__Internal*)__Instance)->data, true);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        var __result0 = global::gambit.Gambit.Number.__GetOrCreateInstance(((global::gambit.Gambit.Array.__Internal*)__Instance)->data, false);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        return (T) (object) ((global::gambit.Gambit.Array.__Internal*)__Instance)->data;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        var __value0 = (int) (object) value;
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = (__IntPtr) (object) __value0;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = ((global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = ((global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = ((global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = ((global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = ((global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = ((global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = ((global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = ((global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = ((global::gambit.Gambit.Number) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.Number) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        //var __value0 = (bool) (object) (byte) (value ? 1 : 0);
                        var __value0 = Convert.ToBoolean(value);
                        ((global::gambit.Gambit.Array.__Internal*)__Instance)->data = (__IntPtr) (object) __value0;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            /// <summary>Return the length of the array</summary>
            public int Length
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<int>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        throw new MissingMethodException("Method Length missing from explicit specialization global::gambit.Gambit.Array<bool>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            /// <summary>Return the first index</summary>
            public int First
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<int>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        throw new MissingMethodException("Method First missing from explicit specialization global::gambit.Gambit.Array<bool>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            /// <summary>Return the last index</summary>
            public int Last
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<int>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        throw new MissingMethodException("Method Last missing from explicit specialization global::gambit.Gambit.Array<bool>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            /// <summary>Return a const forward iterator starting at the beginning of the array</summary>
            public global::gambit.Gambit.Array<T>.ConstIterator Cbegin
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<int>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        throw new MissingMethodException("Method Cbegin missing from explicit specialization global::gambit.Gambit.Array<bool>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            /// <summary>Return a const forward iterator past the end of the array</summary>
            public global::gambit.Gambit.Array<T>.ConstIterator Cend
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<int>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        throw new MissingMethodException("Method Cend missing from explicit specialization global::gambit.Gambit.Array<bool>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            /// <summary>
            /// <para>These operations are a partial implementation of operations on</para>
            /// <para>STL-style list containers.  It is suggested that future code be</para>
            /// <para>written to use these, and existing code ported to use them as</para>
            /// <para>possible.</para>
            /// <para>@{</para>
            /// <para>Return whether the array container is empty (has size 0).</para>
            /// </summary>
            public bool Empty
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<int>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Array<bool>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            /// <summary>Return the number of elements in the array container.</summary>
            public ulong Size
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<int>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Number)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<global::gambit.Gambit.Number>.");
                    }
                    if (__T.IsAssignableFrom(typeof(bool)))
                    {
                        throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Array<bool>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Array<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.GameTreeInfosetRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>>, <global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>, <global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>>, <global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>, <global::gambit.Gambit.Number>, <global::gambit.Gambit.Array<bool>>, <bool>, <global::gambit.Gambit.GamePlayerRep>.");
                }
            }

            #region Virtual table interop

            // virtual ~Array()
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.Array<T>.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe static partial class ArrayExtensions
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?front@?$Array@H@Gambit@@QEAAAEAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int* Front(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?back@?$Array@H@Gambit@@QEAAAEAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int* Back(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?front@?$Array@V?$GameObjectPtr@VGameInfosetRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGameInfosetRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Front_1(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?back@?$Array@V?$GameObjectPtr@VGameInfosetRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGameInfosetRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Back_1(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?front@?$Array@V?$GameObjectPtr@VGameStrategyRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGameStrategyRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Front_2(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?back@?$Array@V?$GameObjectPtr@VGameStrategyRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGameStrategyRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Back_2(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?front@?$Array@V?$GameObjectPtr@VGameNodeRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGameNodeRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Front_3(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?back@?$Array@V?$GameObjectPtr@VGameNodeRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGameNodeRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Back_3(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?front@?$Array@V?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGameActionRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Front_4(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?back@?$Array@V?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGameActionRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Back_4(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?front@?$Array@V?$Array@V?$GameObjectPtr@VGameStrategyRep@Gambit@@@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$Array@V?$GameObjectPtr@VGameStrategyRep@Gambit@@@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Front_5(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?back@?$Array@V?$Array@V?$GameObjectPtr@VGameStrategyRep@Gambit@@@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$Array@V?$GameObjectPtr@VGameStrategyRep@Gambit@@@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Back_5(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?front@?$Array@V?$GameObjectPtr@VGamePlayerRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGamePlayerRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Front_6(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?back@?$Array@V?$GameObjectPtr@VGamePlayerRep@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$GameObjectPtr@VGamePlayerRep@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Back_6(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?front@?$Array@V?$Array@V?$Array@V?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$Array@V?$Array@V?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Front_7(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?back@?$Array@V?$Array@V?$Array@V?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$Array@V?$Array@V?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Back_7(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?front@?$Array@V?$Array@V?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$Array@V?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Front_8(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?back@?$Array@V?$Array@V?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@@Gambit@@@Gambit@@QEAAAEAV?$Array@V?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Back_8(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?front@?$Array@VNumber@Gambit@@@Gambit@@QEAAAEAVNumber@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Front_9(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?back@?$Array@VNumber@Gambit@@@Gambit@@QEAAAEAVNumber@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Back_9(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?front@?$Array@_N@Gambit@@QEAAAEA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern bool* Front_10(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?back@?$Array@_N@Gambit@@QEAAAEA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern bool* Back_10(__IntPtr __instance);
            }

            /// <summary>Access first element.</summary>
            public static int* Front(this global::gambit.Gambit.Array<int> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front(__arg0);
                return ___ret;
            }

            /// <summary>Access last element.</summary>
            public static int* Back(this global::gambit.Gambit.Array<int> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back(__arg0);
                return ___ret;
            }

            /// <summary>Access first element.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> Front(this global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front_1(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access last element.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> Back(this global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back_1(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access first element.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> Front(this global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front_2(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access last element.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> Back(this global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back_2(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access first element.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> Front(this global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front_3(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access last element.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> Back(this global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back_3(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access first element.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> Front(this global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front_4(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access last element.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> Back(this global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back_4(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access first element.</summary>
            public static global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>> Front(this global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front_5(__arg0);
                var __result0 = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Access last element.</summary>
            public static global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>> Back(this global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back_5(__arg0);
                var __result0 = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>>.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Access first element.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> Front(this global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front_6(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access last element.</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> Back(this global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back_6(__arg0);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access first element.</summary>
            public static global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>> Front(this global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front_7(__arg0);
                var __result0 = global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Access last element.</summary>
            public static global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>> Back(this global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back_7(__arg0);
                var __result0 = global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>>.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Access first element.</summary>
            public static global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>> Front(this global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front_8(__arg0);
                var __result0 = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Access last element.</summary>
            public static global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>> Back(this global::gambit.Gambit.Array<global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back_8(__arg0);
                var __result0 = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.__GetOrCreateInstance(___ret, true);
                return __result0;
            }

            /// <summary>Access first element.</summary>
            public static global::gambit.Gambit.Number Front(this global::gambit.Gambit.Array<global::gambit.Gambit.Number> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front_9(__arg0);
                var __result0 = global::gambit.Gambit.Number.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access last element.</summary>
            public static global::gambit.Gambit.Number Back(this global::gambit.Gambit.Array<global::gambit.Gambit.Number> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back_9(__arg0);
                var __result0 = global::gambit.Gambit.Number.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Access first element.</summary>
            public static bool* Front(this global::gambit.Gambit.Array<bool> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Front_10(__arg0);
                return ___ret;
            }

            /// <summary>Access last element.</summary>
            public static bool* Back(this global::gambit.Gambit.Array<bool> @this)
            {
                var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
                var ___ret = __Internal.Back_10(__arg0);
                return ___ret;
            }
        }
    }
}
