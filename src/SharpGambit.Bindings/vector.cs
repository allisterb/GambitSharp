// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace gambit
{
    namespace Gambit
    {
        namespace Vector
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public unsafe partial struct __Internal
            {
                internal __IntPtr vfptr_Array;
                internal int mindex;
                internal int maxdex;
                internal __IntPtr data;
            }
        }

        /// <summary>A mathematical vector: a list of numbers with the standard math operators</summary>
        public unsafe partial class Vector<T> : global::gambit.Gambit.Array<T>, IDisposable
        {
            internal static new Vector<T> __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Vector<T>(native.ToPointer(), skipVTables);
            }

            internal static new Vector<T> __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Vector<T>)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Vector<T> __CreateInstance(global::gambit.Gambit.Vector.__Internal native, bool skipVTables = false)
            {
                return new Vector<T>(native, skipVTables);
            }

            private static void* __CopyValue(global::gambit.Gambit.Vector.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.Vector.__Internal));
                *(global::gambit.Gambit.Vector.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Vector(global::gambit.Gambit.Vector.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Vector(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Create a vector of length len, starting at 1</summary>
            public Vector(uint len = 0)
                : this((void*) null)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method Vector_T_ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method Vector_T_ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method Vector_T_ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Create a vector indexed from low to high</summary>
            public Vector(int low, int high)
                : this((void*) null)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method Vector_T_ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method Vector_T_ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method Vector_T_ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Copy constructor</summary>
            public Vector(global::gambit.Gambit.Vector<T> _0)
                : this((void*) null)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method Vector_T_ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method Vector_T_ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method Vector_T_ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::gambit.Gambit.Vector<T> operator +(global::gambit.Gambit.Vector<T> __op, global::gambit.Gambit.Vector<T> V)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            public static global::gambit.Gambit.Vector<T> operator -(global::gambit.Gambit.Vector<T> __op, global::gambit.Gambit.Vector<T> V)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            public static global::gambit.Gambit.Vector<T> operator *(global::gambit.Gambit.Vector<T> __op, T c)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            public static T operator *(global::gambit.Gambit.Vector<T> __op, global::gambit.Gambit.Vector<T> V)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            public static global::gambit.Gambit.Vector<T> operator /(global::gambit.Gambit.Vector<T> __op, T c)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            public static bool operator ==(global::gambit.Gambit.Vector<T> __op, global::gambit.Gambit.Vector<T> V)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::gambit.Gambit.Vector<T>;
            }

            public override int GetHashCode()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Vector.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Vector.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.Vector.__Internal*) __Instance).GetHashCode();
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            public static bool operator !=(global::gambit.Gambit.Vector<T> __op, global::gambit.Gambit.Vector<T> V)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Tests if all components of the vector are equal to a constant c</summary>
            public static bool operator ==(global::gambit.Gambit.Vector<T> __op, T c)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            public static bool operator !=(global::gambit.Gambit.Vector<T> __op, T c)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            public bool Check(global::gambit.Gambit.Vector<T> v)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(int)))
                {
                    throw new MissingMethodException("Method Check ignored in specialization global::gambit.Gambit.Vector<int>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method Check ignored in specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method Check ignored in specialization global::gambit.Gambit.Vector<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
            }

            public static explicit operator global::gambit.Gambit.Vector<T>(uint len)
            {
                return new global::gambit.Gambit.Vector<T>(len);
            }

            public T NormSquared
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(int)))
                    {
                        throw new MissingMethodException("Method NormSquared missing from explicit specialization global::gambit.Gambit.Vector<int>.");
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method NormSquared missing from explicit specialization global::gambit.Gambit.Vector<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method NormSquared missing from explicit specialization global::gambit.Gambit.Vector<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.Vector<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <int>, <global::gambit.Gambit.Rational>, <double>.");
                }
            }
        }
    }
}
