// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace gambit
{
    namespace Gambit
    {
        /// <summary>Exception thrown when an operation that is undefined is attempted</summary>
        public unsafe partial class UndefinedException : global::gambit.Gambit.Exception, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;
            }

            internal static new UndefinedException __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new UndefinedException(native.ToPointer(), skipVTables);
            }

            internal static new UndefinedException __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (UndefinedException)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new UndefinedException __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (UndefinedException)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static UndefinedException __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new UndefinedException(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private UndefinedException(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected UndefinedException(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // ~UndefinedException() noexcept override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.UndefinedException.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Exception thrown on an operation between incompatible objects</summary>
        public unsafe partial class MismatchException : global::gambit.Gambit.Exception, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;
            }

            internal static new MismatchException __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new MismatchException(native.ToPointer(), skipVTables);
            }

            internal static new MismatchException __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (MismatchException)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new MismatchException __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (MismatchException)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static MismatchException __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new MismatchException(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private MismatchException(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected MismatchException(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public virtual string What()
            {
                var ___WhatDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr>(0, 1);
                var ___ret = ___WhatDelegate(__Instance);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            #region Virtual table interop

            // ~MismatchException() noexcept override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.MismatchException.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // char *what() const noexcept override
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _WhatDelegateInstance;

            private static __IntPtr _WhatDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.MismatchException.__GetInstance(__instance);
                var ___ret = __target.What();
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _WhatDelegateInstance += _WhatDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_WhatDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Exception thrown when comparing different versions of a game</summary>
        public unsafe partial class GameStructureChangedException : global::gambit.Gambit.Exception, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;
            }

            internal static new GameStructureChangedException __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameStructureChangedException(native.ToPointer(), skipVTables);
            }

            internal static new GameStructureChangedException __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameStructureChangedException)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GameStructureChangedException __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GameStructureChangedException)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GameStructureChangedException __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameStructureChangedException(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GameStructureChangedException(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GameStructureChangedException(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public virtual string What()
            {
                var ___WhatDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr>(0, 1);
                var ___ret = ___WhatDelegate(__Instance);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            #region Virtual table interop

            // ~GameStructureChangedException() noexcept override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.GameStructureChangedException.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // char *what() const noexcept override
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _WhatDelegateInstance;

            private static __IntPtr _WhatDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameStructureChangedException.__GetInstance(__instance);
                var ___ret = __target.What();
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _WhatDelegateInstance += _WhatDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_WhatDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Exception thrown on a parse error when reading a game savefile</summary>
        public unsafe partial class InvalidFileException : global::gambit.Gambit.Exception, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;
            }

            internal static new InvalidFileException __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new InvalidFileException(native.ToPointer(), skipVTables);
            }

            internal static new InvalidFileException __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (InvalidFileException)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new InvalidFileException __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (InvalidFileException)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static InvalidFileException __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new InvalidFileException(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private InvalidFileException(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected InvalidFileException(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // ~InvalidFileException() noexcept override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.InvalidFileException.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>
        /// <para>This class represents an outcome in a game.  An outcome</para>
        /// <para>specifies a vector of payoffs to players.</para>
        /// </summary>
        public unsafe partial class GameOutcomeRep : global::gambit.Gambit.GameObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 88)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_GameObject;
                internal int m_refCount;
                internal byte m_valid;
                internal __IntPtr m_game;
                internal int m_number;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_label;
                internal global::gambit.Gambit.Array.__Internal m_payoffs;
            }

            internal static new GameOutcomeRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameOutcomeRep(native.ToPointer(), skipVTables);
            }

            internal static new GameOutcomeRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameOutcomeRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GameOutcomeRep __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GameOutcomeRep)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GameOutcomeRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameOutcomeRep(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GameOutcomeRep(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GameOutcomeRep(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // ~GameOutcomeRep() override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.GameOutcomeRep.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>An action at an information set in an extensive game</summary>
        public unsafe abstract partial class GameActionRep : global::gambit.Gambit.GameObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_GameObject;
                internal int m_refCount;
                internal byte m_valid;
            }

            internal static new GameActionRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameActionRepInternal(native.ToPointer(), skipVTables);
            }

            internal static new GameActionRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameActionRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GameActionRep __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GameActionRep)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GameActionRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameActionRepInternal(native, skipVTables);
            }

            protected GameActionRep(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public abstract bool Precedes(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> _0);

            public abstract void DeleteAction();

            public abstract int Number
            {
                get;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> Infoset
            {
                get;
            }

            public abstract string Label
            {
                get;

                set;
            }

            #region Virtual table interop

            // ~GameActionRep() override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.GameActionRep.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // int GetNumber() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _GetNumberDelegateInstance;

            private static int _GetNumberDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameActionRep.__GetInstance(__instance);
                var ___ret = __target.Number;
                return ___ret;
            }

            // GameInfoset GetInfoset() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetInfosetDelegateInstance;

            private static void _GetInfosetDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameActionRep.__GetInstance(__instance);
                var ___ret = __target.Infoset;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // std::string &GetLabel() const = 0
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _GetLabelDelegateInstance;

            private static __IntPtr _GetLabelDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameActionRep.__GetInstance(__instance);
                var ___ret = __target.Label;
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                return __basicString0.__Instance;
            }

            // void SetLabel(const std::string &p_label) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetLabelDelegateInstance;

            private static void _SetLabelDelegateHook(__IntPtr __instance, __IntPtr p_label)
            {
                var __target = global::gambit.Gambit.GameActionRep.__GetInstance(__instance);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(p_label);
                __target.Label = global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            // bool Precedes(const GameNode &) const = 0
            private static global::gambit.Delegates.Func_bool___IntPtr___IntPtr _PrecedesDelegateInstance;

            private static bool _PrecedesDelegateHook(__IntPtr __instance, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameActionRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__GetOrCreateInstance(_0, false);
                var ___ret = __target.Precedes(__result0);
                return ___ret;
            }

            // void DeleteAction() = 0
            private static global::gambit.Delegates.Action___IntPtr _DeleteActionDelegateInstance;

            private static void _DeleteActionDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameActionRep.__GetInstance(__instance);
                __target.DeleteAction();
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[7];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetNumberDelegateInstance += _GetNumberDelegateHook;
                    _GetInfosetDelegateInstance += _GetInfosetDelegateHook;
                    _GetLabelDelegateInstance += _GetLabelDelegateHook;
                    _SetLabelDelegateInstance += _SetLabelDelegateHook;
                    _PrecedesDelegateInstance += _PrecedesDelegateHook;
                    _DeleteActionDelegateInstance += _DeleteActionDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetNumberDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetInfosetDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetLabelDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetLabelDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_PrecedesDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_DeleteActionDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 7, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 7, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                VTables.Methods[0] = new Delegate[7];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>An information set in an extensive game</summary>
        public unsafe abstract partial class GameInfosetRep : global::gambit.Gambit.GameObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_GameObject;
                internal int m_refCount;
                internal byte m_valid;
            }

            internal static new GameInfosetRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameInfosetRepInternal(native.ToPointer(), skipVTables);
            }

            internal static new GameInfosetRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameInfosetRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GameInfosetRep __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GameInfosetRep)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GameInfosetRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameInfosetRepInternal(native, skipVTables);
            }

            protected GameInfosetRep(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> InsertAction(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> p_where);

            /// <summary>Returns the p_index'th action at the information set</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> GetAction(int p_index);

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> GetMember(int p_index);

            public abstract bool Precedes(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> _0);

            public abstract global::gambit.Gambit.Number GetActionProb(int i);

            public abstract global::gambit.Gambit.Number GetActionProb(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> _0);

            public abstract void Reveal(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> _0);

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> InsertAction();

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> Game
            {
                get;
            }

            public abstract int Number
            {
                get;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> Player
            {
                get;

                set;
            }

            public abstract bool IsChanceInfoset
            {
                get;
            }

            public abstract string Label
            {
                get;

                set;
            }

            /// <summary>Returns the number of actions available at the information set</summary>
            public abstract int NumActions
            {
                get;
            }

            /// <summary>Returns the actions available at the information set</summary>
            public abstract global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>> Actions
            {
                get;
            }

            public abstract int NumMembers
            {
                get;
            }

            public abstract global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>> Members
            {
                get;
            }

            #region Virtual table interop

            // ~GameInfosetRep() override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // Game GetGame() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetGameDelegateInstance;

            private static void _GetGameDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.Game;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // int GetNumber() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _GetNumberDelegateInstance;

            private static int _GetNumberDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.Number;
                return ___ret;
            }

            // GamePlayer GetPlayer() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetPlayerDelegateInstance;

            private static void _GetPlayerDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.Player;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // void SetPlayer(GamePlayer p) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetPlayerDelegateInstance;

            private static void _SetPlayerDelegateHook(__IntPtr __instance, __IntPtr p)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__GetOrCreateInstance(p, false);
                __target.Player = __result0;
            }

            // bool IsChanceInfoset() const = 0
            private static global::gambit.Delegates.Func_bool___IntPtr _IsChanceInfosetDelegateInstance;

            private static bool _IsChanceInfosetDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.IsChanceInfoset;
                return ___ret;
            }

            // void SetLabel(const std::string &p_label) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetLabelDelegateInstance;

            private static void _SetLabelDelegateHook(__IntPtr __instance, __IntPtr p_label)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(p_label);
                __target.Label = global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            // std::string &GetLabel() const = 0
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _GetLabelDelegateInstance;

            private static __IntPtr _GetLabelDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.Label;
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                return __basicString0.__Instance;
            }

            // GameAction InsertAction(GameAction p_where = nullptr) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr _InsertActionDelegateInstance;

            private static void _InsertActionDelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr p_where)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__GetOrCreateInstance(p_where, false);
                var ___ret = __target.InsertAction(__result1);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // int NumActions() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _NumActionsDelegateInstance;

            private static int _NumActionsDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.NumActions;
                return ___ret;
            }

            // GameAction GetAction(int p_index) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetActionDelegateInstance;

            private static void _GetActionDelegateHook(__IntPtr __instance, __IntPtr @return, int p_index)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.GetAction(p_index);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // Array<GameAction> GetActions() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetActionsDelegateInstance;

            private static void _GetActionsDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.Actions;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // int NumMembers() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _NumMembersDelegateInstance;

            private static int _NumMembersDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.NumMembers;
                return ___ret;
            }

            // GameNode GetMember(int p_index) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetMemberDelegateInstance;

            private static void _GetMemberDelegateHook(__IntPtr __instance, __IntPtr @return, int p_index)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.GetMember(p_index);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // Array<GameNode> GetMembers() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetMembersDelegateInstance;

            private static void _GetMembersDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.Members;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // bool Precedes(GameNode) const = 0
            private static global::gambit.Delegates.Func_bool___IntPtr___IntPtr _PrecedesDelegateInstance;

            private static bool _PrecedesDelegateHook(__IntPtr __instance, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__GetOrCreateInstance(_0, false);
                var ___ret = __target.Precedes(__result0);
                return ___ret;
            }

            // Number &GetActionProb(const GameAction &) const = 0
            private static global::gambit.Delegates.Func___IntPtr___IntPtr___IntPtr _GetActionProb_1DelegateInstance;

            private static __IntPtr _GetActionProb_1DelegateHook(__IntPtr __instance, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__GetOrCreateInstance(_0, false);
                var ___ret = __target.GetActionProb(__result0);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // Number &GetActionProb(int i) const = 0
            private static global::gambit.Delegates.Func___IntPtr___IntPtr_int _GetActionProbDelegateInstance;

            private static __IntPtr _GetActionProbDelegateHook(__IntPtr __instance, int i)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var ___ret = __target.GetActionProb(i);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is a C++ reference (&).");
                return ___ret.__Instance;
            }

            // void Reveal(GamePlayer) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _RevealDelegateInstance;

            private static void _RevealDelegateHook(__IntPtr __instance, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameInfosetRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__GetOrCreateInstance(_0, false);
                __target.Reveal(__result0);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[19];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetGameDelegateInstance += _GetGameDelegateHook;
                    _GetNumberDelegateInstance += _GetNumberDelegateHook;
                    _GetPlayerDelegateInstance += _GetPlayerDelegateHook;
                    _SetPlayerDelegateInstance += _SetPlayerDelegateHook;
                    _IsChanceInfosetDelegateInstance += _IsChanceInfosetDelegateHook;
                    _SetLabelDelegateInstance += _SetLabelDelegateHook;
                    _GetLabelDelegateInstance += _GetLabelDelegateHook;
                    _InsertActionDelegateInstance += _InsertActionDelegateHook;
                    _NumActionsDelegateInstance += _NumActionsDelegateHook;
                    _GetActionDelegateInstance += _GetActionDelegateHook;
                    _GetActionsDelegateInstance += _GetActionsDelegateHook;
                    _NumMembersDelegateInstance += _NumMembersDelegateHook;
                    _GetMemberDelegateInstance += _GetMemberDelegateHook;
                    _GetMembersDelegateInstance += _GetMembersDelegateHook;
                    _PrecedesDelegateInstance += _PrecedesDelegateHook;
                    _GetActionProb_1DelegateInstance += _GetActionProb_1DelegateHook;
                    _GetActionProbDelegateInstance += _GetActionProbDelegateHook;
                    _RevealDelegateInstance += _RevealDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetGameDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetNumberDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetPlayerDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetPlayerDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_IsChanceInfosetDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_SetLabelDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetLabelDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_InsertActionDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_NumActionsDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_GetActionDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_GetActionsDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_NumMembersDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_GetMemberDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_GetMembersDelegateInstance);
                    Thunks[15] = Marshal.GetFunctionPointerForDelegate(_PrecedesDelegateInstance);
                    Thunks[16] = Marshal.GetFunctionPointerForDelegate(_GetActionProb_1DelegateInstance);
                    Thunks[17] = Marshal.GetFunctionPointerForDelegate(_GetActionProbDelegateInstance);
                    Thunks[18] = Marshal.GetFunctionPointerForDelegate(_RevealDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 19, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 19, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                ManagedVTables[0][7] = Thunks[7];
                                ManagedVTables[0][8] = Thunks[8];
                                ManagedVTables[0][9] = Thunks[9];
                                ManagedVTables[0][10] = Thunks[10];
                                ManagedVTables[0][11] = Thunks[11];
                                ManagedVTables[0][12] = Thunks[12];
                                ManagedVTables[0][13] = Thunks[13];
                                ManagedVTables[0][14] = Thunks[14];
                                ManagedVTables[0][15] = Thunks[15];
                                ManagedVTables[0][16] = Thunks[16];
                                ManagedVTables[0][17] = Thunks[17];
                                ManagedVTables[0][18] = Thunks[18];
                                VTables.Methods[0] = new Delegate[19];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>A strategy in a game.</summary>
        /// <remarks>
        /// <para>This class represents a strategy in a game.</para>
        /// <para>For strategic games, this object internally stores an offset.</para>
        /// <para>This offset has the</para>
        /// <para>property that, for a strategy profile, adding the offsets of the</para>
        /// <para>strategies gives the index into the strategic game's table to</para>
        /// <para>find the outcome for that strategy profile, making payoff computation</para>
        /// <para>relatively efficient.</para>
        /// </remarks>
        public unsafe partial class GameStrategyRep : global::gambit.Gambit.GameObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 96)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_GameObject;
                internal int m_refCount;
                internal byte m_valid;
                internal int m_number;
                internal int m_id;
                internal __IntPtr m_player;
                internal int m_offset;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_label;
                internal global::gambit.Gambit.Array.__Internal m_behav;
            }

            internal static new GameStrategyRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameStrategyRep(native.ToPointer(), skipVTables);
            }

            internal static new GameStrategyRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameStrategyRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GameStrategyRep __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GameStrategyRep)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GameStrategyRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameStrategyRep(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GameStrategyRep(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GameStrategyRep(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // GameStrategyRep
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.GameStrategyRep.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>A player in a game</summary>
        public unsafe partial class GamePlayerRep : global::gambit.Gambit.GameObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 112)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_GameObject;
                internal int m_refCount;
                internal byte m_valid;
                internal __IntPtr m_game;
                internal int m_number;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_label;
                internal global::gambit.Gambit.Array.__Internal m_infosets;
                internal global::gambit.Gambit.Array.__Internal m_strategies;
            }

            internal static new GamePlayerRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GamePlayerRep(native.ToPointer(), skipVTables);
            }

            internal static new GamePlayerRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GamePlayerRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GamePlayerRep __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GamePlayerRep)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GamePlayerRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GamePlayerRep(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GamePlayerRep(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GamePlayerRep(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // ~GamePlayerRep() override
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.GamePlayerRep.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>A node in an extensive game</summary>
        public unsafe abstract partial class GameNodeRep : global::gambit.Gambit.GameObject, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_GameObject;
                internal int m_refCount;
                internal byte m_valid;
            }

            internal static new GameNodeRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameNodeRepInternal(native.ToPointer(), skipVTables);
            }

            internal static new GameNodeRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameNodeRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GameNodeRep __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GameNodeRep)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GameNodeRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameNodeRepInternal(native, skipVTables);
            }

            protected GameNodeRep(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> GetChild(int i);

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> GetChild(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> _0);

            public abstract bool IsSuccessorOf(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> from);

            public abstract void DeleteParent();

            public abstract void DeleteTree();

            public abstract void CopyTree(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> src);

            public abstract void MoveTree(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> src);

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> AppendMove(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> p_player, int p_actions);

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> AppendMove(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> p_infoset);

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> InsertMove(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> p_player, int p_actions);

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> InsertMove(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> p_infoset);

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> Game
            {
                get;
            }

            public abstract string Label
            {
                get;

                set;
            }

            public abstract int Number
            {
                get;
            }

            public abstract int NumberInInfoset
            {
                get;
            }

            public abstract int NumChildren
            {
                get;
            }

            public abstract global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>> Children
            {
                get;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> Infoset
            {
                get;

                set;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> LeaveInfoset
            {
                get;
            }

            public abstract bool IsTerminal
            {
                get;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> Player
            {
                get;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> PriorAction
            {
                get;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> Parent
            {
                get;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> NextSibling
            {
                get;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> PriorSibling
            {
                get;
            }

            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> Outcome
            {
                get;

                set;
            }

            public abstract bool IsSubgameRoot
            {
                get;
            }

            /// <summary>Create a separate Game object containing the subgame rooted at the node</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> CopySubgame
            {
                get;
            }

            #region Virtual table interop

            // ~GameNodeRep() override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // Game GetGame() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetGameDelegateInstance;

            private static void _GetGameDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.Game;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // std::string &GetLabel() const = 0
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _GetLabelDelegateInstance;

            private static __IntPtr _GetLabelDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.Label;
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                return __basicString0.__Instance;
            }

            // void SetLabel(const std::string &p_label) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetLabelDelegateInstance;

            private static void _SetLabelDelegateHook(__IntPtr __instance, __IntPtr p_label)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(p_label);
                __target.Label = global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            // int GetNumber() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _GetNumberDelegateInstance;

            private static int _GetNumberDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.Number;
                return ___ret;
            }

            // int NumberInInfoset() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _NumberInInfosetDelegateInstance;

            private static int _NumberInInfosetDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.NumberInInfoset;
                return ___ret;
            }

            // int NumChildren() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _NumChildrenDelegateInstance;

            private static int _NumChildrenDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.NumChildren;
                return ___ret;
            }

            // GameNode GetChild(const GameAction &) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr _GetChild_1DelegateInstance;

            private static void _GetChild_1DelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__GetOrCreateInstance(_0, false);
                var ___ret = __target.GetChild(__result1);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameNode GetChild(int i) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetChildDelegateInstance;

            private static void _GetChildDelegateHook(__IntPtr __instance, __IntPtr @return, int i)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.GetChild(i);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // Array<GameNode> GetChildren() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetChildrenDelegateInstance;

            private static void _GetChildrenDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.Children;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // GameInfoset GetInfoset() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetInfosetDelegateInstance;

            private static void _GetInfosetDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.Infoset;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // void SetInfoset(GameInfoset) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetInfosetDelegateInstance;

            private static void _SetInfosetDelegateHook(__IntPtr __instance, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(_0, false);
                __target.Infoset = __result0;
            }

            // GameInfoset LeaveInfoset() = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _LeaveInfosetDelegateInstance;

            private static void _LeaveInfosetDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.LeaveInfoset;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // bool IsTerminal() const = 0
            private static global::gambit.Delegates.Func_bool___IntPtr _IsTerminalDelegateInstance;

            private static bool _IsTerminalDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.IsTerminal;
                return ___ret;
            }

            // GamePlayer GetPlayer() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetPlayerDelegateInstance;

            private static void _GetPlayerDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.Player;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameAction GetPriorAction() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetPriorActionDelegateInstance;

            private static void _GetPriorActionDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.PriorAction;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameNode GetParent() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetParentDelegateInstance;

            private static void _GetParentDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.Parent;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameNode GetNextSibling() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetNextSiblingDelegateInstance;

            private static void _GetNextSiblingDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.NextSibling;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameNode GetPriorSibling() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetPriorSiblingDelegateInstance;

            private static void _GetPriorSiblingDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.PriorSibling;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameOutcome GetOutcome() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetOutcomeDelegateInstance;

            private static void _GetOutcomeDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.Outcome;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // void SetOutcome(const GameOutcome &p_outcome) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetOutcomeDelegateInstance;

            private static void _SetOutcomeDelegateHook(__IntPtr __instance, __IntPtr p_outcome)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.__GetOrCreateInstance(p_outcome, false);
                __target.Outcome = __result0;
            }

            // bool IsSuccessorOf(GameNode from) const = 0
            private static global::gambit.Delegates.Func_bool___IntPtr___IntPtr _IsSuccessorOfDelegateInstance;

            private static bool _IsSuccessorOfDelegateHook(__IntPtr __instance, __IntPtr from)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__GetOrCreateInstance(from, false);
                var ___ret = __target.IsSuccessorOf(__result0);
                return ___ret;
            }

            // bool IsSubgameRoot() const = 0
            private static global::gambit.Delegates.Func_bool___IntPtr _IsSubgameRootDelegateInstance;

            private static bool _IsSubgameRootDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.IsSubgameRoot;
                return ___ret;
            }

            // void DeleteParent() = 0
            private static global::gambit.Delegates.Action___IntPtr _DeleteParentDelegateInstance;

            private static void _DeleteParentDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                __target.DeleteParent();
            }

            // void DeleteTree() = 0
            private static global::gambit.Delegates.Action___IntPtr _DeleteTreeDelegateInstance;

            private static void _DeleteTreeDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                __target.DeleteTree();
            }

            // void CopyTree(GameNode src) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _CopyTreeDelegateInstance;

            private static void _CopyTreeDelegateHook(__IntPtr __instance, __IntPtr src)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__GetOrCreateInstance(src, false);
                __target.CopyTree(__result0);
            }

            // void MoveTree(GameNode src) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _MoveTreeDelegateInstance;

            private static void _MoveTreeDelegateHook(__IntPtr __instance, __IntPtr src)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__GetOrCreateInstance(src, false);
                __target.MoveTree(__result0);
            }

            // Game CopySubgame() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _CopySubgameDelegateInstance;

            private static void _CopySubgameDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var ___ret = __target.CopySubgame;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameInfoset AppendMove(GameInfoset p_infoset) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr _AppendMove_1DelegateInstance;

            private static void _AppendMove_1DelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr p_infoset)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(p_infoset, false);
                var ___ret = __target.AppendMove(__result1);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameInfoset AppendMove(GamePlayer p_player, int p_actions) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr_int _AppendMoveDelegateInstance;

            private static void _AppendMoveDelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr p_player, int p_actions)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__GetOrCreateInstance(p_player, false);
                var ___ret = __target.AppendMove(__result1, p_actions);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameInfoset InsertMove(GameInfoset p_infoset) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr _InsertMove_1DelegateInstance;

            private static void _InsertMove_1DelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr p_infoset)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(p_infoset, false);
                var ___ret = __target.InsertMove(__result1);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameInfoset InsertMove(GamePlayer p_player, int p_actions) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr_int _InsertMoveDelegateInstance;

            private static void _InsertMoveDelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr p_player, int p_actions)
            {
                var __target = global::gambit.Gambit.GameNodeRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__GetOrCreateInstance(p_player, false);
                var ___ret = __target.InsertMove(__result1, p_actions);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[32];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _GetGameDelegateInstance += _GetGameDelegateHook;
                    _GetLabelDelegateInstance += _GetLabelDelegateHook;
                    _SetLabelDelegateInstance += _SetLabelDelegateHook;
                    _GetNumberDelegateInstance += _GetNumberDelegateHook;
                    _NumberInInfosetDelegateInstance += _NumberInInfosetDelegateHook;
                    _NumChildrenDelegateInstance += _NumChildrenDelegateHook;
                    _GetChild_1DelegateInstance += _GetChild_1DelegateHook;
                    _GetChildDelegateInstance += _GetChildDelegateHook;
                    _GetChildrenDelegateInstance += _GetChildrenDelegateHook;
                    _GetInfosetDelegateInstance += _GetInfosetDelegateHook;
                    _SetInfosetDelegateInstance += _SetInfosetDelegateHook;
                    _LeaveInfosetDelegateInstance += _LeaveInfosetDelegateHook;
                    _IsTerminalDelegateInstance += _IsTerminalDelegateHook;
                    _GetPlayerDelegateInstance += _GetPlayerDelegateHook;
                    _GetPriorActionDelegateInstance += _GetPriorActionDelegateHook;
                    _GetParentDelegateInstance += _GetParentDelegateHook;
                    _GetNextSiblingDelegateInstance += _GetNextSiblingDelegateHook;
                    _GetPriorSiblingDelegateInstance += _GetPriorSiblingDelegateHook;
                    _GetOutcomeDelegateInstance += _GetOutcomeDelegateHook;
                    _SetOutcomeDelegateInstance += _SetOutcomeDelegateHook;
                    _IsSuccessorOfDelegateInstance += _IsSuccessorOfDelegateHook;
                    _IsSubgameRootDelegateInstance += _IsSubgameRootDelegateHook;
                    _DeleteParentDelegateInstance += _DeleteParentDelegateHook;
                    _DeleteTreeDelegateInstance += _DeleteTreeDelegateHook;
                    _CopyTreeDelegateInstance += _CopyTreeDelegateHook;
                    _MoveTreeDelegateInstance += _MoveTreeDelegateHook;
                    _CopySubgameDelegateInstance += _CopySubgameDelegateHook;
                    _AppendMove_1DelegateInstance += _AppendMove_1DelegateHook;
                    _AppendMoveDelegateInstance += _AppendMoveDelegateHook;
                    _InsertMove_1DelegateInstance += _InsertMove_1DelegateHook;
                    _InsertMoveDelegateInstance += _InsertMoveDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetGameDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetLabelDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_SetLabelDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNumberDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_NumberInInfosetDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_NumChildrenDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetChild_1DelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_GetChildDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetChildrenDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_GetInfosetDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_SetInfosetDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_LeaveInfosetDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_IsTerminalDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_GetPlayerDelegateInstance);
                    Thunks[15] = Marshal.GetFunctionPointerForDelegate(_GetPriorActionDelegateInstance);
                    Thunks[16] = Marshal.GetFunctionPointerForDelegate(_GetParentDelegateInstance);
                    Thunks[17] = Marshal.GetFunctionPointerForDelegate(_GetNextSiblingDelegateInstance);
                    Thunks[18] = Marshal.GetFunctionPointerForDelegate(_GetPriorSiblingDelegateInstance);
                    Thunks[19] = Marshal.GetFunctionPointerForDelegate(_GetOutcomeDelegateInstance);
                    Thunks[20] = Marshal.GetFunctionPointerForDelegate(_SetOutcomeDelegateInstance);
                    Thunks[21] = Marshal.GetFunctionPointerForDelegate(_IsSuccessorOfDelegateInstance);
                    Thunks[22] = Marshal.GetFunctionPointerForDelegate(_IsSubgameRootDelegateInstance);
                    Thunks[23] = Marshal.GetFunctionPointerForDelegate(_DeleteParentDelegateInstance);
                    Thunks[24] = Marshal.GetFunctionPointerForDelegate(_DeleteTreeDelegateInstance);
                    Thunks[25] = Marshal.GetFunctionPointerForDelegate(_CopyTreeDelegateInstance);
                    Thunks[26] = Marshal.GetFunctionPointerForDelegate(_MoveTreeDelegateInstance);
                    Thunks[27] = Marshal.GetFunctionPointerForDelegate(_CopySubgameDelegateInstance);
                    Thunks[28] = Marshal.GetFunctionPointerForDelegate(_AppendMove_1DelegateInstance);
                    Thunks[29] = Marshal.GetFunctionPointerForDelegate(_AppendMoveDelegateInstance);
                    Thunks[30] = Marshal.GetFunctionPointerForDelegate(_InsertMove_1DelegateInstance);
                    Thunks[31] = Marshal.GetFunctionPointerForDelegate(_InsertMoveDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 32, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 32, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                ManagedVTables[0][7] = Thunks[7];
                                ManagedVTables[0][8] = Thunks[8];
                                ManagedVTables[0][9] = Thunks[9];
                                ManagedVTables[0][10] = Thunks[10];
                                ManagedVTables[0][11] = Thunks[11];
                                ManagedVTables[0][12] = Thunks[12];
                                ManagedVTables[0][13] = Thunks[13];
                                ManagedVTables[0][14] = Thunks[14];
                                ManagedVTables[0][15] = Thunks[15];
                                ManagedVTables[0][16] = Thunks[16];
                                ManagedVTables[0][17] = Thunks[17];
                                ManagedVTables[0][18] = Thunks[18];
                                ManagedVTables[0][19] = Thunks[19];
                                ManagedVTables[0][20] = Thunks[20];
                                ManagedVTables[0][21] = Thunks[21];
                                ManagedVTables[0][22] = Thunks[22];
                                ManagedVTables[0][23] = Thunks[23];
                                ManagedVTables[0][24] = Thunks[24];
                                ManagedVTables[0][25] = Thunks[25];
                                ManagedVTables[0][26] = Thunks[26];
                                ManagedVTables[0][27] = Thunks[27];
                                ManagedVTables[0][28] = Thunks[28];
                                ManagedVTables[0][29] = Thunks[29];
                                ManagedVTables[0][30] = Thunks[30];
                                ManagedVTables[0][31] = Thunks[31];
                                VTables.Methods[0] = new Delegate[32];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>This is the class for representing an arbitrary finite game.</summary>
        public unsafe abstract partial class GameRep : global::gambit.Gambit.BaseGameRep, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 88)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_BaseGameRep;
                internal int m_refCount;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_title;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_comment;
                internal uint m_version;
            }

            internal static new GameRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameRepInternal(native.ToPointer(), skipVTables);
            }

            internal static new GameRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GameRep __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GameRep)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GameRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameRepInternal(native, skipVTables);
            }

            protected GameRep(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Build any computed values anew</summary>
            protected virtual void BuildComputedValues()
            {
                var ___BuildComputedValuesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr>(0, 1);
                ___BuildComputedValuesDelegate(__Instance);
            }

            /// <summary>Returns the smallest payoff in any outcome of the game</summary>
            public abstract global::gambit.Gambit.Rational GetMinPayoff(int pl = 0);

            /// <summary>Returns the largest payoff in any outcome of the game</summary>
            public abstract global::gambit.Gambit.Rational GetMaxPayoff(int pl = 0);

            /// <summary>
            /// <para>Returns true if the game is perfect recall.  If not,</para>
            /// <para>a pair of violating information sets is returned in the parameters.</para>
            /// </summary>
            public abstract bool IsPerfectRecall(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> _0, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> _1);

            /// <summary>Gets the i'th strategy in the game, numbered globally</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> GetStrategy(int p_index);

            public abstract global::gambit.Gambit.PureStrategyProfile NewPureStrategyProfile();

            public abstract global::gambit.Gambit.MixedStrategyProfile<double> NewMixedStrategyProfile(double _0);

            public abstract global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational> NewMixedStrategyProfile(global::gambit.Gambit.Rational _0);

            public abstract global::gambit.Gambit.MixedStrategyProfile<double> NewMixedStrategyProfile(double _0, global::gambit.Gambit.StrategySupportProfile _1);

            public abstract global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational> NewMixedStrategyProfile(global::gambit.Gambit.Rational _0, global::gambit.Gambit.StrategySupportProfile _1);

            /// <summary>Returns the pl'th player in the game</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> GetPlayer(int pl);

            /// <summary>Creates a new player in the game, with no moves</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> NewPlayer();

            /// <summary>Returns the iset'th information set in the game (numbered globally)</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> GetInfoset(int iset);

            /// <summary>Returns the act'th action in the game (numbered globally)</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> GetAction(int act);

            /// <summary>Returns the index'th outcome defined in the game</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> GetOutcome(int index);

            /// <summary>Creates a new outcome in the game</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> NewOutcome();

            /// <summary>Deletes the specified outcome from the game</summary>
            public abstract void DeleteOutcome(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> _0);

            /// <summary>Set the probability distribution of actions at a chance node</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> SetChanceProbs(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> _0, global::gambit.Gambit.Array<global::gambit.Gambit.Number> _1);

            protected string MTitle
            {
                get
                {
                    var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_title));
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }

                set
                {
                    global::Std.BasicStringExtensions.__Internal.Assign(new __IntPtr(&((__Internal*)__Instance)->m_title), value);
                }
            }

            protected string MComment
            {
                get
                {
                    var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_comment));
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }

                set
                {
                    global::Std.BasicStringExtensions.__Internal.Assign(new __IntPtr(&((__Internal*)__Instance)->m_comment), value);
                }
            }

            protected uint MVersion
            {
                get
                {
                    return ((__Internal*)__Instance)->m_version;
                }

                set
                {
                    ((__Internal*)__Instance)->m_version = value;
                }
            }

            /// <summary>Create a copy of the game, as a new game</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> Copy
            {
                get;
            }

            /// <summary>Returns true if the game has a game tree representation</summary>
            public abstract bool IsTree
            {
                get;
            }

            /// <summary>Returns true if the game has a action-graph game representation</summary>
            public virtual bool IsAgg
            {
                get
                {
                    var ___IsAggDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr>(0, 4);
                    var ___ret = ___IsAggDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the text label associated with the game</summary>
            /// <remarks>Set the text label associated with the game</remarks>
            public virtual string Title
            {
                get
                {
                    var ___GetTitleDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr>(0, 5);
                    var ___ret = ___GetTitleDelegate(__Instance);
                    var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(___ret);
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }

                set
                {
                    var ___SetTitleDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 6);
                    var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, value);
                    var __arg0 = __basicString0.__Instance;
                    ___SetTitleDelegate(__Instance, __arg0);
                    __basicString0.Dispose();
                }
            }

            /// <summary>Get the text comment associated with the game</summary>
            /// <remarks>Set the text comment associated with the game</remarks>
            public virtual string Comment
            {
                get
                {
                    var ___GetCommentDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr>(0, 7);
                    var ___ret = ___GetCommentDelegate(__Instance);
                    var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(___ret);
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }

                set
                {
                    var ___SetCommentDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 8);
                    var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, value);
                    var __arg0 = __basicString0.__Instance;
                    ___SetCommentDelegate(__Instance, __arg0);
                    __basicString0.Dispose();
                }
            }

            /// <summary>Returns true if the game is constant-sum</summary>
            public abstract bool IsConstSum
            {
                get;
            }

            /// <summary>The number of actions in each information set</summary>
            public abstract global::gambit.Gambit.PVector<int> NumActions
            {
                get;
            }

            /// <summary>The number of members in each information set</summary>
            public abstract global::gambit.Gambit.PVector<int> NumMembers
            {
                get;
            }

            /// <summary>The number of strategies for each player</summary>
            public abstract global::gambit.Gambit.Array<int> NumStrategies
            {
                get;
            }

            /// <summary>Returns the number of strategy contingencies in the game</summary>
            public abstract int NumStrategyContingencies
            {
                get;
            }

            /// <summary>Returns the total number of actions in the game</summary>
            public abstract int BehavProfileLength
            {
                get;
            }

            /// <summary>Returns the total number of strategies in the game</summary>
            public abstract int MixedProfileLength
            {
                get;
            }

            /// <summary>Returns the number of players in the game</summary>
            public abstract int NumPlayers
            {
                get;
            }

            /// <summary>Returns the set of players in the game</summary>
            public virtual global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>> Players
            {
                get
                {
                    var ___GetPlayersDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 30);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___GetPlayersDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>Returns the chance (nature) player</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> Chance
            {
                get;
            }

            /// <summary>Returns the set of information sets in the game</summary>
            public abstract global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>> Infosets
            {
                get;
            }

            /// <summary>Returns an array with the number of information sets per personal player</summary>
            public abstract global::gambit.Gambit.Array<int> NumInfosets
            {
                get;
            }

            /// <summary>Returns the number of outcomes defined in the game</summary>
            public abstract int NumOutcomes
            {
                get;
            }

            /// <summary>Returns the root node of the game</summary>
            public abstract global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> Root
            {
                get;
            }

            /// <summary>Returns the number of nodes in the game</summary>
            public abstract int NumNodes
            {
                get;
            }

            #region Virtual table interop

            // ~GameRep() override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // void BuildComputedValues()
            private static global::gambit.Delegates.Action___IntPtr _BuildComputedValuesDelegateInstance;

            private static void _BuildComputedValuesDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                __target.BuildComputedValues();
            }

            // Game Copy() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _CopyDelegateInstance;

            private static void _CopyDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.Copy;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // bool IsTree() const = 0
            private static global::gambit.Delegates.Func_bool___IntPtr _IsTreeDelegateInstance;

            private static bool _IsTreeDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.IsTree;
                return ___ret;
            }

            // bool IsAgg() const
            private static global::gambit.Delegates.Func_bool___IntPtr _IsAggDelegateInstance;

            private static bool _IsAggDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.IsAgg;
                return ___ret;
            }

            // std::string &GetTitle() const
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _GetTitleDelegateInstance;

            private static __IntPtr _GetTitleDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.Title;
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                return __basicString0.__Instance;
            }

            // void SetTitle(const std::string &p_title)
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetTitleDelegateInstance;

            private static void _SetTitleDelegateHook(__IntPtr __instance, __IntPtr p_title)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(p_title);
                __target.Title = global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            // std::string &GetComment() const
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _GetCommentDelegateInstance;

            private static __IntPtr _GetCommentDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.Comment;
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                return __basicString0.__Instance;
            }

            // void SetComment(const std::string &p_comment)
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetCommentDelegateInstance;

            private static void _SetCommentDelegateHook(__IntPtr __instance, __IntPtr p_comment)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(p_comment);
                __target.Comment = global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            // bool IsConstSum() const = 0
            private static global::gambit.Delegates.Func_bool___IntPtr _IsConstSumDelegateInstance;

            private static bool _IsConstSumDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.IsConstSum;
                return ___ret;
            }

            // Rational GetMinPayoff(int pl = 0) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetMinPayoffDelegateInstance;

            private static void _GetMinPayoffDelegateHook(__IntPtr __instance, __IntPtr @return, int pl)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.GetMinPayoff(pl);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Rational.__Internal*) @return = *(global::gambit.Gambit.Rational.__Internal*) ___ret.__Instance;
            }

            // Rational GetMaxPayoff(int pl = 0) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetMaxPayoffDelegateInstance;

            private static void _GetMaxPayoffDelegateHook(__IntPtr __instance, __IntPtr @return, int pl)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.GetMaxPayoff(pl);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Rational.__Internal*) @return = *(global::gambit.Gambit.Rational.__Internal*) ___ret.__Instance;
            }

            // bool IsPerfectRecall(GameInfoset &, GameInfoset &) const = 0
            private static global::gambit.Delegates.Func_bool___IntPtr___IntPtr___IntPtr _IsPerfectRecallDelegateInstance;

            private static bool _IsPerfectRecallDelegateHook(__IntPtr __instance, __IntPtr _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(_0, false);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(_1, false);
                var ___ret = __target.IsPerfectRecall(__result0, __result1);
                return ___ret;
            }

            // PVector<int> NumActions() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NumActionsDelegateInstance;

            private static void _NumActionsDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NumActions;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.PVector.__Internal*) @return = *(global::gambit.Gambit.PVector.__Internal*) ___ret.__Instance;
            }

            // PVector<int> NumMembers() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NumMembersDelegateInstance;

            private static void _NumMembersDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NumMembers;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.PVector.__Internal*) @return = *(global::gambit.Gambit.PVector.__Internal*) ___ret.__Instance;
            }

            // Array<int> NumStrategies() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NumStrategiesDelegateInstance;

            private static void _NumStrategiesDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NumStrategies;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // GameStrategy GetStrategy(int p_index) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetStrategyDelegateInstance;

            private static void _GetStrategyDelegateHook(__IntPtr __instance, __IntPtr @return, int p_index)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.GetStrategy(p_index);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // int NumStrategyContingencies() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _NumStrategyContingenciesDelegateInstance;

            private static int _NumStrategyContingenciesDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NumStrategyContingencies;
                return ___ret;
            }

            // int BehavProfileLength() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _BehavProfileLengthDelegateInstance;

            private static int _BehavProfileLengthDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.BehavProfileLength;
                return ___ret;
            }

            // int MixedProfileLength() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _MixedProfileLengthDelegateInstance;

            private static int _MixedProfileLengthDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.MixedProfileLength;
                return ___ret;
            }

            // PureStrategyProfile NewPureStrategyProfile() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NewPureStrategyProfileDelegateInstance;

            private static void _NewPureStrategyProfileDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NewPureStrategyProfile();
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.PureStrategyProfile.__Internal*) @return = *(global::gambit.Gambit.PureStrategyProfile.__Internal*) ___ret.__Instance;
            }

            // MixedStrategyProfile<Rational> NewMixedStrategyProfile(const Rational &, const StrategySupportProfile &) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr _NewMixedStrategyProfile_3DelegateInstance;

            private static void _NewMixedStrategyProfile_3DelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.Rational.__GetOrCreateInstance(_0, false);
                var __result2 = global::gambit.Gambit.StrategySupportProfile.__GetOrCreateInstance(_1, false);
                var ___ret = __target.NewMixedStrategyProfile(__result1, __result2);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) @return = *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) ___ret.__Instance;
            }

            // MixedStrategyProfile<double> NewMixedStrategyProfile(double, const StrategySupportProfile &) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_double___IntPtr _NewMixedStrategyProfile_2DelegateInstance;

            private static void _NewMixedStrategyProfile_2DelegateHook(__IntPtr __instance, __IntPtr @return, double _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var __result2 = global::gambit.Gambit.StrategySupportProfile.__GetOrCreateInstance(_1, false);
                var ___ret = __target.NewMixedStrategyProfile(_0, __result2);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) @return = *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) ___ret.__Instance;
            }

            // MixedStrategyProfile<Rational> NewMixedStrategyProfile(const Rational &) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr _NewMixedStrategyProfile_1DelegateInstance;

            private static void _NewMixedStrategyProfile_1DelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.Rational.__GetOrCreateInstance(_0, false);
                var ___ret = __target.NewMixedStrategyProfile(__result1);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) @return = *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) ___ret.__Instance;
            }

            // MixedStrategyProfile<double> NewMixedStrategyProfile(double) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_double _NewMixedStrategyProfileDelegateInstance;

            private static void _NewMixedStrategyProfileDelegateHook(__IntPtr __instance, __IntPtr @return, double _0)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NewMixedStrategyProfile(_0);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) @return = *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) ___ret.__Instance;
            }

            // int NumPlayers() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _NumPlayersDelegateInstance;

            private static int _NumPlayersDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NumPlayers;
                return ___ret;
            }

            // GamePlayer GetPlayer(int pl) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetPlayerDelegateInstance;

            private static void _GetPlayerDelegateHook(__IntPtr __instance, __IntPtr @return, int pl)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.GetPlayer(pl);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // Array<GamePlayer> GetPlayers() const
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetPlayersDelegateInstance;

            private static void _GetPlayersDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.Players;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // GamePlayer GetChance() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetChanceDelegateInstance;

            private static void _GetChanceDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.Chance;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GamePlayer NewPlayer() = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NewPlayerDelegateInstance;

            private static void _NewPlayerDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NewPlayer();
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameInfoset GetInfoset(int iset) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetInfosetDelegateInstance;

            private static void _GetInfosetDelegateHook(__IntPtr __instance, __IntPtr @return, int iset)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.GetInfoset(iset);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // Array<GameInfoset> GetInfosets() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetInfosetsDelegateInstance;

            private static void _GetInfosetsDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.Infosets;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // Array<int> NumInfosets() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NumInfosetsDelegateInstance;

            private static void _NumInfosetsDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NumInfosets;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // GameAction GetAction(int act) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetActionDelegateInstance;

            private static void _GetActionDelegateHook(__IntPtr __instance, __IntPtr @return, int act)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.GetAction(act);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // int NumOutcomes() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _NumOutcomesDelegateInstance;

            private static int _NumOutcomesDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NumOutcomes;
                return ___ret;
            }

            // GameOutcome GetOutcome(int index) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetOutcomeDelegateInstance;

            private static void _GetOutcomeDelegateHook(__IntPtr __instance, __IntPtr @return, int index)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.GetOutcome(index);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameOutcome NewOutcome() = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NewOutcomeDelegateInstance;

            private static void _NewOutcomeDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NewOutcome();
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // void DeleteOutcome(const GameOutcome &) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _DeleteOutcomeDelegateInstance;

            private static void _DeleteOutcomeDelegateHook(__IntPtr __instance, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.__GetOrCreateInstance(_0, false);
                __target.DeleteOutcome(__result0);
            }

            // GameNode GetRoot() const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetRootDelegateInstance;

            private static void _GetRootDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.Root;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // int NumNodes() const = 0
            private static global::gambit.Delegates.Func_int___IntPtr _NumNodesDelegateInstance;

            private static int _NumNodesDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var ___ret = __target.NumNodes;
                return ___ret;
            }

            // Game SetChanceProbs(const GameInfoset &, const Array<Number> &) = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr _SetChanceProbsDelegateInstance;

            private static void _SetChanceProbsDelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.GameRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(_0, false);
                var __result2 = global::gambit.Gambit.Array<global::gambit.Gambit.Number>.__GetOrCreateInstance(_1, false, skipVTables: true);
                var ___ret = __target.SetChanceProbs(__result1, __result2);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[41];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _BuildComputedValuesDelegateInstance += _BuildComputedValuesDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    _IsTreeDelegateInstance += _IsTreeDelegateHook;
                    _IsAggDelegateInstance += _IsAggDelegateHook;
                    _GetTitleDelegateInstance += _GetTitleDelegateHook;
                    _SetTitleDelegateInstance += _SetTitleDelegateHook;
                    _GetCommentDelegateInstance += _GetCommentDelegateHook;
                    _SetCommentDelegateInstance += _SetCommentDelegateHook;
                    _IsConstSumDelegateInstance += _IsConstSumDelegateHook;
                    _GetMinPayoffDelegateInstance += _GetMinPayoffDelegateHook;
                    _GetMaxPayoffDelegateInstance += _GetMaxPayoffDelegateHook;
                    _IsPerfectRecallDelegateInstance += _IsPerfectRecallDelegateHook;
                    _NumActionsDelegateInstance += _NumActionsDelegateHook;
                    _NumMembersDelegateInstance += _NumMembersDelegateHook;
                    _NumStrategiesDelegateInstance += _NumStrategiesDelegateHook;
                    _GetStrategyDelegateInstance += _GetStrategyDelegateHook;
                    _NumStrategyContingenciesDelegateInstance += _NumStrategyContingenciesDelegateHook;
                    _BehavProfileLengthDelegateInstance += _BehavProfileLengthDelegateHook;
                    _MixedProfileLengthDelegateInstance += _MixedProfileLengthDelegateHook;
                    _NewPureStrategyProfileDelegateInstance += _NewPureStrategyProfileDelegateHook;
                    _NewMixedStrategyProfile_3DelegateInstance += _NewMixedStrategyProfile_3DelegateHook;
                    _NewMixedStrategyProfile_2DelegateInstance += _NewMixedStrategyProfile_2DelegateHook;
                    _NewMixedStrategyProfile_1DelegateInstance += _NewMixedStrategyProfile_1DelegateHook;
                    _NewMixedStrategyProfileDelegateInstance += _NewMixedStrategyProfileDelegateHook;
                    _NumPlayersDelegateInstance += _NumPlayersDelegateHook;
                    _GetPlayerDelegateInstance += _GetPlayerDelegateHook;
                    _GetPlayersDelegateInstance += _GetPlayersDelegateHook;
                    _GetChanceDelegateInstance += _GetChanceDelegateHook;
                    _NewPlayerDelegateInstance += _NewPlayerDelegateHook;
                    _GetInfosetDelegateInstance += _GetInfosetDelegateHook;
                    _GetInfosetsDelegateInstance += _GetInfosetsDelegateHook;
                    _NumInfosetsDelegateInstance += _NumInfosetsDelegateHook;
                    _GetActionDelegateInstance += _GetActionDelegateHook;
                    _NumOutcomesDelegateInstance += _NumOutcomesDelegateHook;
                    _GetOutcomeDelegateInstance += _GetOutcomeDelegateHook;
                    _NewOutcomeDelegateInstance += _NewOutcomeDelegateHook;
                    _DeleteOutcomeDelegateInstance += _DeleteOutcomeDelegateHook;
                    _GetRootDelegateInstance += _GetRootDelegateHook;
                    _NumNodesDelegateInstance += _NumNodesDelegateHook;
                    _SetChanceProbsDelegateInstance += _SetChanceProbsDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_BuildComputedValuesDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_IsTreeDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_IsAggDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetTitleDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_SetTitleDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetCommentDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_SetCommentDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_IsConstSumDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_GetMinPayoffDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_GetMaxPayoffDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_IsPerfectRecallDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_NumActionsDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_NumMembersDelegateInstance);
                    Thunks[15] = Marshal.GetFunctionPointerForDelegate(_NumStrategiesDelegateInstance);
                    Thunks[16] = Marshal.GetFunctionPointerForDelegate(_GetStrategyDelegateInstance);
                    Thunks[17] = Marshal.GetFunctionPointerForDelegate(_NumStrategyContingenciesDelegateInstance);
                    Thunks[18] = Marshal.GetFunctionPointerForDelegate(_BehavProfileLengthDelegateInstance);
                    Thunks[19] = Marshal.GetFunctionPointerForDelegate(_MixedProfileLengthDelegateInstance);
                    Thunks[20] = Marshal.GetFunctionPointerForDelegate(_NewPureStrategyProfileDelegateInstance);
                    Thunks[21] = Marshal.GetFunctionPointerForDelegate(_NewMixedStrategyProfile_3DelegateInstance);
                    Thunks[22] = Marshal.GetFunctionPointerForDelegate(_NewMixedStrategyProfile_2DelegateInstance);
                    Thunks[23] = Marshal.GetFunctionPointerForDelegate(_NewMixedStrategyProfile_1DelegateInstance);
                    Thunks[24] = Marshal.GetFunctionPointerForDelegate(_NewMixedStrategyProfileDelegateInstance);
                    Thunks[25] = Marshal.GetFunctionPointerForDelegate(_NumPlayersDelegateInstance);
                    Thunks[26] = Marshal.GetFunctionPointerForDelegate(_GetPlayerDelegateInstance);
                    Thunks[27] = Marshal.GetFunctionPointerForDelegate(_GetPlayersDelegateInstance);
                    Thunks[28] = Marshal.GetFunctionPointerForDelegate(_GetChanceDelegateInstance);
                    Thunks[29] = Marshal.GetFunctionPointerForDelegate(_NewPlayerDelegateInstance);
                    Thunks[30] = Marshal.GetFunctionPointerForDelegate(_GetInfosetDelegateInstance);
                    Thunks[31] = Marshal.GetFunctionPointerForDelegate(_GetInfosetsDelegateInstance);
                    Thunks[32] = Marshal.GetFunctionPointerForDelegate(_NumInfosetsDelegateInstance);
                    Thunks[33] = Marshal.GetFunctionPointerForDelegate(_GetActionDelegateInstance);
                    Thunks[34] = Marshal.GetFunctionPointerForDelegate(_NumOutcomesDelegateInstance);
                    Thunks[35] = Marshal.GetFunctionPointerForDelegate(_GetOutcomeDelegateInstance);
                    Thunks[36] = Marshal.GetFunctionPointerForDelegate(_NewOutcomeDelegateInstance);
                    Thunks[37] = Marshal.GetFunctionPointerForDelegate(_DeleteOutcomeDelegateInstance);
                    Thunks[38] = Marshal.GetFunctionPointerForDelegate(_GetRootDelegateInstance);
                    Thunks[39] = Marshal.GetFunctionPointerForDelegate(_NumNodesDelegateInstance);
                    Thunks[40] = Marshal.GetFunctionPointerForDelegate(_SetChanceProbsDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 44, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 44, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                ManagedVTables[0][7] = Thunks[7];
                                ManagedVTables[0][8] = Thunks[8];
                                ManagedVTables[0][9] = Thunks[9];
                                ManagedVTables[0][10] = Thunks[10];
                                ManagedVTables[0][11] = Thunks[11];
                                ManagedVTables[0][12] = Thunks[12];
                                ManagedVTables[0][16] = Thunks[13];
                                ManagedVTables[0][17] = Thunks[14];
                                ManagedVTables[0][18] = Thunks[15];
                                ManagedVTables[0][19] = Thunks[16];
                                ManagedVTables[0][20] = Thunks[17];
                                ManagedVTables[0][21] = Thunks[18];
                                ManagedVTables[0][22] = Thunks[19];
                                ManagedVTables[0][23] = Thunks[20];
                                ManagedVTables[0][24] = Thunks[21];
                                ManagedVTables[0][25] = Thunks[22];
                                ManagedVTables[0][26] = Thunks[23];
                                ManagedVTables[0][27] = Thunks[24];
                                ManagedVTables[0][28] = Thunks[25];
                                ManagedVTables[0][29] = Thunks[26];
                                ManagedVTables[0][30] = Thunks[27];
                                ManagedVTables[0][31] = Thunks[28];
                                ManagedVTables[0][32] = Thunks[29];
                                ManagedVTables[0][33] = Thunks[30];
                                ManagedVTables[0][34] = Thunks[31];
                                ManagedVTables[0][35] = Thunks[32];
                                ManagedVTables[0][36] = Thunks[33];
                                ManagedVTables[0][37] = Thunks[34];
                                ManagedVTables[0][38] = Thunks[35];
                                ManagedVTables[0][39] = Thunks[36];
                                ManagedVTables[0][40] = Thunks[37];
                                ManagedVTables[0][41] = Thunks[38];
                                ManagedVTables[0][42] = Thunks[39];
                                ManagedVTables[0][43] = Thunks[40];
                                VTables.Methods[0] = new Delegate[44];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class GameActionRepInternal : global::gambit.Gambit.GameActionRep, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal GameActionRepInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal GameActionRepInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override bool Precedes(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> _0)
            {
                var ___PrecedesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr___IntPtr>(0, 5);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = ___PrecedesDelegate(__Instance, __arg0);
                return ___ret;
            }

            public override void DeleteAction()
            {
                var ___DeleteActionDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr>(0, 6);
                ___DeleteActionDelegate(__Instance);
            }

            public override int Number
            {
                get
                {
                    var ___GetNumberDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 1);
                    var ___ret = ___GetNumberDelegate(__Instance);
                    return ___ret;
                }
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> Infoset
            {
                get
                {
                    var ___GetInfosetDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 2);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetInfosetDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public override string Label
            {
                get
                {
                    var ___GetLabelDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr>(0, 3);
                    var ___ret = ___GetLabelDelegate(__Instance);
                    var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(___ret);
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }

                set
                {
                    var ___SetLabelDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 4);
                    var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, value);
                    var __arg0 = __basicString0.__Instance;
                    ___SetLabelDelegate(__Instance, __arg0);
                    __basicString0.Dispose();
                }
            }
        }

        public unsafe partial class GameInfosetRepInternal : global::gambit.Gambit.GameInfosetRep, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal GameInfosetRepInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal GameInfosetRepInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> InsertAction(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> p_where)
            {
                var ___InsertActionDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 8);
                if (ReferenceEquals(p_where, null))
                    throw new global::System.ArgumentNullException("p_where", "Cannot be null because it is passed by value.");
                var __arg0 = p_where.__Instance;
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___InsertActionDelegate(__Instance, new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the p_index'th action at the information set</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> GetAction(int p_index)
            {
                var ___GetActionDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 10);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetActionDelegate(__Instance, new IntPtr(&___ret), p_index);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> GetMember(int p_index)
            {
                var ___GetMemberDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 13);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetMemberDelegate(__Instance, new IntPtr(&___ret), p_index);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep(new __IntPtr(&___ret));
                return _____ret;
            }

            public override bool Precedes(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> _0)
            {
                var ___PrecedesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr___IntPtr>(0, 15);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is passed by value.");
                var __arg0 = _0.__Instance;
                var ___ret = ___PrecedesDelegate(__Instance, __arg0);
                return ___ret;
            }

            public override global::gambit.Gambit.Number GetActionProb(int i)
            {
                var ___GetActionProbDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr_int>(0, 17);
                var ___ret = ___GetActionProbDelegate(__Instance, i);
                var __result0 = global::gambit.Gambit.Number.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public override global::gambit.Gambit.Number GetActionProb(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> _0)
            {
                var ___GetActionProb_1Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr___IntPtr>(0, 16);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = ___GetActionProb_1Delegate(__Instance, __arg0);
                var __result0 = global::gambit.Gambit.Number.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public override void Reveal(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> _0)
            {
                var ___RevealDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 18);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is passed by value.");
                var __arg0 = _0.__Instance;
                ___RevealDelegate(__Instance, __arg0);
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> InsertAction()
            {
                throw new NotImplementedException();
                //return InsertAction(nullptr,);
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> Game
            {
                get
                {
                    var ___GetGameDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 1);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetGameDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public override int Number
            {
                get
                {
                    var ___GetNumberDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 2);
                    var ___ret = ___GetNumberDelegate(__Instance);
                    return ___ret;
                }
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> Player
            {
                get
                {
                    var ___GetPlayerDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 3);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetPlayerDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep(new __IntPtr(&___ret));
                    return _____ret;
                }

                set
                {
                    var ___SetPlayerDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 4);
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    var __arg0 = value.__Instance;
                    ___SetPlayerDelegate(__Instance, __arg0);
                }
            }

            public override bool IsChanceInfoset
            {
                get
                {
                    var ___IsChanceInfosetDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr>(0, 5);
                    var ___ret = ___IsChanceInfosetDelegate(__Instance);
                    return ___ret;
                }
            }

            public override string Label
            {
                get
                {
                    var ___GetLabelDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr>(0, 7);
                    var ___ret = ___GetLabelDelegate(__Instance);
                    var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(___ret);
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }

                set
                {
                    var ___SetLabelDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 6);
                    var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, value);
                    var __arg0 = __basicString0.__Instance;
                    ___SetLabelDelegate(__Instance, __arg0);
                    __basicString0.Dispose();
                }
            }

            /// <summary>Returns the number of actions available at the information set</summary>
            public override int NumActions
            {
                get
                {
                    var ___NumActionsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 9);
                    var ___ret = ___NumActionsDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the actions available at the information set</summary>
            public override global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>> Actions
            {
                get
                {
                    var ___GetActionsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 11);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___GetActionsDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            public override int NumMembers
            {
                get
                {
                    var ___NumMembersDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 12);
                    var ___ret = ___NumMembersDelegate(__Instance);
                    return ___ret;
                }
            }

            public override global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>> Members
            {
                get
                {
                    var ___GetMembersDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 14);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___GetMembersDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }
        }

        public unsafe partial class GameNodeRepInternal : global::gambit.Gambit.GameNodeRep, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal GameNodeRepInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal GameNodeRepInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> GetChild(int i)
            {
                var ___GetChildDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 8);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetChildDelegate(__Instance, new IntPtr(&___ret), i);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> GetChild(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> _0)
            {
                var ___GetChild_1Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 7);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetChild_1Delegate(__Instance, new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep(new __IntPtr(&___ret));
                return _____ret;
            }

            public override bool IsSuccessorOf(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> from)
            {
                var ___IsSuccessorOfDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr___IntPtr>(0, 21);
                if (ReferenceEquals(from, null))
                    throw new global::System.ArgumentNullException("from", "Cannot be null because it is passed by value.");
                var __arg0 = from.__Instance;
                var ___ret = ___IsSuccessorOfDelegate(__Instance, __arg0);
                return ___ret;
            }

            public override void DeleteParent()
            {
                var ___DeleteParentDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr>(0, 23);
                ___DeleteParentDelegate(__Instance);
            }

            public override void DeleteTree()
            {
                var ___DeleteTreeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr>(0, 24);
                ___DeleteTreeDelegate(__Instance);
            }

            public override void CopyTree(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> src)
            {
                var ___CopyTreeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 25);
                if (ReferenceEquals(src, null))
                    throw new global::System.ArgumentNullException("src", "Cannot be null because it is passed by value.");
                var __arg0 = src.__Instance;
                ___CopyTreeDelegate(__Instance, __arg0);
            }

            public override void MoveTree(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> src)
            {
                var ___MoveTreeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 26);
                if (ReferenceEquals(src, null))
                    throw new global::System.ArgumentNullException("src", "Cannot be null because it is passed by value.");
                var __arg0 = src.__Instance;
                ___MoveTreeDelegate(__Instance, __arg0);
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> AppendMove(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> p_player, int p_actions)
            {
                var ___AppendMoveDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr_int>(0, 29);
                if (ReferenceEquals(p_player, null))
                    throw new global::System.ArgumentNullException("p_player", "Cannot be null because it is passed by value.");
                var __arg0 = p_player.__Instance;
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___AppendMoveDelegate(__Instance, new IntPtr(&___ret), __arg0, p_actions);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> AppendMove(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> p_infoset)
            {
                var ___AppendMove_1Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 28);
                if (ReferenceEquals(p_infoset, null))
                    throw new global::System.ArgumentNullException("p_infoset", "Cannot be null because it is passed by value.");
                var __arg0 = p_infoset.__Instance;
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___AppendMove_1Delegate(__Instance, new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> InsertMove(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> p_player, int p_actions)
            {
                var ___InsertMoveDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr_int>(0, 31);
                if (ReferenceEquals(p_player, null))
                    throw new global::System.ArgumentNullException("p_player", "Cannot be null because it is passed by value.");
                var __arg0 = p_player.__Instance;
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___InsertMoveDelegate(__Instance, new IntPtr(&___ret), __arg0, p_actions);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> InsertMove(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> p_infoset)
            {
                var ___InsertMove_1Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 30);
                if (ReferenceEquals(p_infoset, null))
                    throw new global::System.ArgumentNullException("p_infoset", "Cannot be null because it is passed by value.");
                var __arg0 = p_infoset.__Instance;
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___InsertMove_1Delegate(__Instance, new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> Game
            {
                get
                {
                    var ___GetGameDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 1);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetGameDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public override string Label
            {
                get
                {
                    var ___GetLabelDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr>(0, 2);
                    var ___ret = ___GetLabelDelegate(__Instance);
                    var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(___ret);
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }

                set
                {
                    var ___SetLabelDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 3);
                    var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, value);
                    var __arg0 = __basicString0.__Instance;
                    ___SetLabelDelegate(__Instance, __arg0);
                    __basicString0.Dispose();
                }
            }

            public override int Number
            {
                get
                {
                    var ___GetNumberDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 4);
                    var ___ret = ___GetNumberDelegate(__Instance);
                    return ___ret;
                }
            }

            public override int NumberInInfoset
            {
                get
                {
                    var ___NumberInInfosetDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 5);
                    var ___ret = ___NumberInInfosetDelegate(__Instance);
                    return ___ret;
                }
            }

            public override int NumChildren
            {
                get
                {
                    var ___NumChildrenDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 6);
                    var ___ret = ___NumChildrenDelegate(__Instance);
                    return ___ret;
                }
            }

            public override global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>> Children
            {
                get
                {
                    var ___GetChildrenDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 9);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___GetChildrenDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> Infoset
            {
                get
                {
                    var ___GetInfosetDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 10);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetInfosetDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep(new __IntPtr(&___ret));
                    return _____ret;
                }

                set
                {
                    var ___SetInfosetDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 11);
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    var __arg0 = value.__Instance;
                    ___SetInfosetDelegate(__Instance, __arg0);
                }
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> LeaveInfoset
            {
                get
                {
                    var ___LeaveInfosetDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 12);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___LeaveInfosetDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public override bool IsTerminal
            {
                get
                {
                    var ___IsTerminalDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr>(0, 13);
                    var ___ret = ___IsTerminalDelegate(__Instance);
                    return ___ret;
                }
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> Player
            {
                get
                {
                    var ___GetPlayerDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 14);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetPlayerDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> PriorAction
            {
                get
                {
                    var ___GetPriorActionDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 15);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetPriorActionDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> Parent
            {
                get
                {
                    var ___GetParentDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 16);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetParentDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> NextSibling
            {
                get
                {
                    var ___GetNextSiblingDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 17);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetNextSiblingDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> PriorSibling
            {
                get
                {
                    var ___GetPriorSiblingDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 18);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetPriorSiblingDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> Outcome
            {
                get
                {
                    var ___GetOutcomeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 19);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetOutcomeDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameOutcomeRep(new __IntPtr(&___ret));
                    return _____ret;
                }

                set
                {
                    var ___SetOutcomeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 20);
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    ___SetOutcomeDelegate(__Instance, __arg0);
                }
            }

            public override bool IsSubgameRoot
            {
                get
                {
                    var ___IsSubgameRootDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr>(0, 22);
                    var ___ret = ___IsSubgameRootDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Create a separate Game object containing the subgame rooted at the node</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> CopySubgame
            {
                get
                {
                    var ___CopySubgameDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 27);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___CopySubgameDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }
        }

        public unsafe partial class GameRepInternal : global::gambit.Gambit.GameRep, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal GameRepInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal GameRepInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Returns the smallest payoff in any outcome of the game</summary>
            public override global::gambit.Gambit.Rational GetMinPayoff(int pl = 0)
            {
                var ___GetMinPayoffDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 10);
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                ___GetMinPayoffDelegate(__Instance, new IntPtr(&___ret), pl);
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the largest payoff in any outcome of the game</summary>
            public override global::gambit.Gambit.Rational GetMaxPayoff(int pl = 0)
            {
                var ___GetMaxPayoffDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 11);
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                ___GetMaxPayoffDelegate(__Instance, new IntPtr(&___ret), pl);
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>
            /// <para>Returns true if the game is perfect recall.  If not,</para>
            /// <para>a pair of violating information sets is returned in the parameters.</para>
            /// </summary>
            public override bool IsPerfectRecall(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> _0, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> _1)
            {
                var ___IsPerfectRecallDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr___IntPtr___IntPtr>(0, 12);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = ___IsPerfectRecallDelegate(__Instance, __arg0, __arg1);
                return ___ret;
            }

            /// <summary>Gets the i'th strategy in the game, numbered globally</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> GetStrategy(int p_index)
            {
                var ___GetStrategyDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 19);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetStrategyDelegate(__Instance, new IntPtr(&___ret), p_index);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.PureStrategyProfile NewPureStrategyProfile()
            {
                var ___NewPureStrategyProfileDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 23);
                var ___ret = new global::gambit.Gambit.PureStrategyProfile.__Internal();
                ___NewPureStrategyProfileDelegate(__Instance, new IntPtr(&___ret));
                var _____ret = global::gambit.Gambit.PureStrategyProfile.__CreateInstance(___ret);
                global::gambit.Gambit.PureStrategyProfile.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.MixedStrategyProfile<double> NewMixedStrategyProfile(double _0)
            {
                var ___NewMixedStrategyProfileDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_double>(0, 27);
                var ___ret = new global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d();
                ___NewMixedStrategyProfileDelegate(__Instance, new IntPtr(&___ret), _0);
                var _____ret = global::gambit.Gambit.MixedStrategyProfile<double>.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            public override global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational> NewMixedStrategyProfile(global::gambit.Gambit.Rational _0)
            {
                var ___NewMixedStrategyProfile_1Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 26);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = new global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational();
                ___NewMixedStrategyProfile_1Delegate(__Instance, new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            public override global::gambit.Gambit.MixedStrategyProfile<double> NewMixedStrategyProfile(double _0, global::gambit.Gambit.StrategySupportProfile _1)
            {
                var ___NewMixedStrategyProfile_2Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_double___IntPtr>(0, 25);
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = new global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d();
                ___NewMixedStrategyProfile_2Delegate(__Instance, new IntPtr(&___ret), _0, __arg1);
                var _____ret = global::gambit.Gambit.MixedStrategyProfile<double>.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            public override global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational> NewMixedStrategyProfile(global::gambit.Gambit.Rational _0, global::gambit.Gambit.StrategySupportProfile _1)
            {
                var ___NewMixedStrategyProfile_3Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr>(0, 24);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = new global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational();
                ___NewMixedStrategyProfile_3Delegate(__Instance, new IntPtr(&___ret), __arg0, __arg1);
                var _____ret = global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            /// <summary>Returns the pl'th player in the game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> GetPlayer(int pl)
            {
                var ___GetPlayerDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 29);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetPlayerDelegate(__Instance, new IntPtr(&___ret), pl);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Creates a new player in the game, with no moves</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> NewPlayer()
            {
                var ___NewPlayerDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 32);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___NewPlayerDelegate(__Instance, new IntPtr(&___ret));
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the iset'th information set in the game (numbered globally)</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> GetInfoset(int iset)
            {
                var ___GetInfosetDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 33);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetInfosetDelegate(__Instance, new IntPtr(&___ret), iset);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the act'th action in the game (numbered globally)</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> GetAction(int act)
            {
                var ___GetActionDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 36);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetActionDelegate(__Instance, new IntPtr(&___ret), act);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the index'th outcome defined in the game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> GetOutcome(int index)
            {
                var ___GetOutcomeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 38);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetOutcomeDelegate(__Instance, new IntPtr(&___ret), index);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameOutcomeRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Creates a new outcome in the game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> NewOutcome()
            {
                var ___NewOutcomeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 39);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___NewOutcomeDelegate(__Instance, new IntPtr(&___ret));
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameOutcomeRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Deletes the specified outcome from the game</summary>
            public override void DeleteOutcome(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> _0)
            {
                var ___DeleteOutcomeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 40);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                ___DeleteOutcomeDelegate(__Instance, __arg0);
            }

            /// <summary>Set the probability distribution of actions at a chance node</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> SetChanceProbs(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> _0, global::gambit.Gambit.Array<global::gambit.Gambit.Number> _1)
            {
                var ___SetChanceProbsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr>(0, 43);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___SetChanceProbsDelegate(__Instance, new IntPtr(&___ret), __arg0, __arg1);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Create a copy of the game, as a new game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 2);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___CopyDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Returns true if the game has a game tree representation</summary>
            public override bool IsTree
            {
                get
                {
                    var ___IsTreeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr>(0, 3);
                    var ___ret = ___IsTreeDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns true if the game is constant-sum</summary>
            public override bool IsConstSum
            {
                get
                {
                    var ___IsConstSumDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr>(0, 9);
                    var ___ret = ___IsConstSumDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>The number of actions in each information set</summary>
            public override global::gambit.Gambit.PVector<int> NumActions
            {
                get
                {
                    var ___NumActionsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 16);
                    var ___ret = new global::gambit.Gambit.PVector.__Internal();
                    ___NumActionsDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.PVector<int>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>The number of members in each information set</summary>
            public override global::gambit.Gambit.PVector<int> NumMembers
            {
                get
                {
                    var ___NumMembersDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 17);
                    var ___ret = new global::gambit.Gambit.PVector.__Internal();
                    ___NumMembersDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.PVector<int>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>The number of strategies for each player</summary>
            public override global::gambit.Gambit.Array<int> NumStrategies
            {
                get
                {
                    var ___NumStrategiesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 18);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___NumStrategiesDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<int>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>Returns the number of strategy contingencies in the game</summary>
            public override int NumStrategyContingencies
            {
                get
                {
                    var ___NumStrategyContingenciesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 20);
                    var ___ret = ___NumStrategyContingenciesDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the total number of actions in the game</summary>
            public override int BehavProfileLength
            {
                get
                {
                    var ___BehavProfileLengthDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 21);
                    var ___ret = ___BehavProfileLengthDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the total number of strategies in the game</summary>
            public override int MixedProfileLength
            {
                get
                {
                    var ___MixedProfileLengthDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 22);
                    var ___ret = ___MixedProfileLengthDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the number of players in the game</summary>
            public override int NumPlayers
            {
                get
                {
                    var ___NumPlayersDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 28);
                    var ___ret = ___NumPlayersDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the chance (nature) player</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> Chance
            {
                get
                {
                    var ___GetChanceDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 31);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetChanceDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Returns the set of information sets in the game</summary>
            public override global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>> Infosets
            {
                get
                {
                    var ___GetInfosetsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 34);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___GetInfosetsDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>Returns an array with the number of information sets per personal player</summary>
            public override global::gambit.Gambit.Array<int> NumInfosets
            {
                get
                {
                    var ___NumInfosetsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 35);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___NumInfosetsDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<int>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>Returns the number of outcomes defined in the game</summary>
            public override int NumOutcomes
            {
                get
                {
                    var ___NumOutcomesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 37);
                    var ___ret = ___NumOutcomesDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the root node of the game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> Root
            {
                get
                {
                    var ___GetRootDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 41);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetRootDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Returns the number of nodes in the game</summary>
            public override int NumNodes
            {
                get
                {
                    var ___NumNodesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 42);
                    var ___ret = ___NumNodesDelegate(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class game
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?NewTree@Gambit@@YA?AV?$GameObjectPtr@VGameRep@Gambit@@@1@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void NewTree(__IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?NewTable@Gambit@@YA?AV?$GameObjectPtr@VGameRep@Gambit@@@1@AEBV?$Array@H@1@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void NewTable(__IntPtr @return, __IntPtr p_dim, bool p_sparseOutcomes);
            }

            /// <summary>Factory function to create new game tree</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> NewTree()
            {
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                __Internal.NewTree(new IntPtr(&___ret));
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Factory function to create new game table</summary>
            public static global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> NewTable(global::gambit.Gambit.Array<int> p_dim, bool p_sparseOutcomes = false)
            {
                if (ReferenceEquals(p_dim, null))
                    throw new global::System.ArgumentNullException("p_dim", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = p_dim.__Instance;
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                __Internal.NewTable(new IntPtr(&___ret), __arg0, p_sparseOutcomes);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(new __IntPtr(&___ret));
                return _____ret;
            }
        }
    }
}
