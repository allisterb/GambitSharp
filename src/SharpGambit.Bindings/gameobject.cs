// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace gambit
{
    namespace Gambit
    {
        namespace GameObjectPtr
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public unsafe partial struct __Internal
            {
                internal __IntPtr rep;

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "c__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep_F__GameObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "c__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep_F__GameObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "c__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep_F__GameObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "c__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep_F__GameObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "??1?$GameObjectPtr@VGameActionRep@Gambit@@@Gambit@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "c__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep_F__GameObjectPtr", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "??1?$GameObjectPtr@VGameOutcomeRep@Gambit@@@Gambit@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameOutcomeRep(__IntPtr __instance);
            }
        }

        public unsafe partial class GameObjectPtr<T> : IDisposable
        {
            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.GameObjectPtr<T>> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.GameObjectPtr<T>>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.GameObjectPtr<T> managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.GameObjectPtr<T> managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static GameObjectPtr<T> __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameObjectPtr<T>(native.ToPointer(), skipVTables);
            }

            internal static GameObjectPtr<T> __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameObjectPtr<T>)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static GameObjectPtr<T> __CreateInstance(global::gambit.Gambit.GameObjectPtr.__Internal native, bool skipVTables = false)
            {
                return new GameObjectPtr<T>(native, skipVTables);
            }

            private static void* __CopyValue(global::gambit.Gambit.GameObjectPtr.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.GameObjectPtr.__Internal));
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GameObjectPtr(global::gambit.Gambit.GameObjectPtr.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GameObjectPtr(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public GameObjectPtr(global::gambit.Gambit.GameObjectPtr<T> r)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameRep)))
                {
                    throw new MissingMethodException("Method GameObjectPtr_T_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameInfosetRep)))
                {
                    throw new MissingMethodException("Method GameObjectPtr_T_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GamePlayerRep)))
                {
                    throw new MissingMethodException("Method GameObjectPtr_T_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameStrategyRep)))
                {
                    throw new MissingMethodException("Method GameObjectPtr_T_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameActionRep)))
                {
                    throw new MissingMethodException("Method GameObjectPtr_T_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameNodeRep)))
                {
                    throw new MissingMethodException("Method GameObjectPtr_T_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameOutcomeRep)))
                {
                    throw new MissingMethodException("Method GameObjectPtr_T_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.GameObjectPtr<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameRep>, <global::gambit.Gambit.GameInfosetRep>, <global::gambit.Gambit.GamePlayerRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameActionRep>, <global::gambit.Gambit.GameNodeRep>, <global::gambit.Gambit.GameOutcomeRep>.");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static bool operator ==(global::gambit.Gambit.GameObjectPtr<T> __op, global::gambit.Gambit.GameObjectPtr<T> r)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameInfosetRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GamePlayerRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameStrategyRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameActionRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameNodeRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameOutcomeRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.GameObjectPtr<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameRep>, <global::gambit.Gambit.GameInfosetRep>, <global::gambit.Gambit.GamePlayerRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameActionRep>, <global::gambit.Gambit.GameNodeRep>, <global::gambit.Gambit.GameOutcomeRep>.");
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::gambit.Gambit.GameObjectPtr<T>;
            }

            public override int GetHashCode()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameRep)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.GameObjectPtr.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameInfosetRep)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.GameObjectPtr.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GamePlayerRep)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.GameObjectPtr.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameStrategyRep)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.GameObjectPtr.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameActionRep)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.GameObjectPtr.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameNodeRep)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.GameObjectPtr.__Internal*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameOutcomeRep)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.GameObjectPtr.__Internal*) __Instance).GetHashCode();
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.GameObjectPtr<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameRep>, <global::gambit.Gambit.GameInfosetRep>, <global::gambit.Gambit.GamePlayerRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameActionRep>, <global::gambit.Gambit.GameNodeRep>, <global::gambit.Gambit.GameOutcomeRep>.");
            }

            public static bool operator !=(global::gambit.Gambit.GameObjectPtr<T> __op, global::gambit.Gambit.GameObjectPtr<T> r)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameInfosetRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GamePlayerRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameStrategyRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameActionRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameNodeRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameOutcomeRep)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.GameObjectPtr<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameRep>, <global::gambit.Gambit.GameInfosetRep>, <global::gambit.Gambit.GamePlayerRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameActionRep>, <global::gambit.Gambit.GameNodeRep>, <global::gambit.Gambit.GameOutcomeRep>.");
            }

            public static bool operator !(global::gambit.Gambit.GameObjectPtr<T> __op)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameRep)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameInfosetRep)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GamePlayerRep)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameStrategyRep)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameActionRep)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameNodeRep)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.");
                }
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameOutcomeRep)))
                {
                    throw new MissingMethodException("Method operator_ ignored in specialization global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.GameObjectPtr<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameRep>, <global::gambit.Gambit.GameInfosetRep>, <global::gambit.Gambit.GamePlayerRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameActionRep>, <global::gambit.Gambit.GameNodeRep>, <global::gambit.Gambit.GameOutcomeRep>.");
            }

            public T Rep
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameRep)))
                    {
                        var __result0 = global::gambit.Gambit.GameRep.__GetOrCreateInstance(((global::gambit.Gambit.GameObjectPtr.__Internal*)__Instance)->rep, true);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameInfosetRep)))
                    {
                        var __result0 = global::gambit.Gambit.GameInfosetRep.__GetOrCreateInstance(((global::gambit.Gambit.GameObjectPtr.__Internal*)__Instance)->rep, true);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GamePlayerRep)))
                    {
                        var __result0 = global::gambit.Gambit.GamePlayerRep.__GetOrCreateInstance(((global::gambit.Gambit.GameObjectPtr.__Internal*)__Instance)->rep, true);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameStrategyRep)))
                    {
                        var __result0 = global::gambit.Gambit.GameStrategyRep.__GetOrCreateInstance(((global::gambit.Gambit.GameObjectPtr.__Internal*)__Instance)->rep, true);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameActionRep)))
                    {
                        var __result0 = global::gambit.Gambit.GameActionRep.__GetOrCreateInstance(((global::gambit.Gambit.GameObjectPtr.__Internal*)__Instance)->rep, true);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameNodeRep)))
                    {
                        var __result0 = global::gambit.Gambit.GameNodeRep.__GetOrCreateInstance(((global::gambit.Gambit.GameObjectPtr.__Internal*)__Instance)->rep, true);
                        return (T) (object) (T) (object) __result0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameOutcomeRep)))
                    {
                        var __result0 = global::gambit.Gambit.GameOutcomeRep.__GetOrCreateInstance(((global::gambit.Gambit.GameObjectPtr.__Internal*)__Instance)->rep, true);
                        return (T) (object) (T) (object) __result0;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.GameObjectPtr<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameRep>, <global::gambit.Gambit.GameInfosetRep>, <global::gambit.Gambit.GamePlayerRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameActionRep>, <global::gambit.Gambit.GameNodeRep>, <global::gambit.Gambit.GameOutcomeRep>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameRep)))
                    {
                        ((global::gambit.Gambit.GameObjectPtr.__Internal*)__Instance)->rep = ((global::gambit.Gambit.GameRep) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.GameRep) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameInfosetRep)))
                    {
                        ((global::gambit.Gambit.GameObjectPtr.__Internal*)__Instance)->rep = ((global::gambit.Gambit.GameInfosetRep) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.GameInfosetRep) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GamePlayerRep)))
                    {
                        ((global::gambit.Gambit.GameObjectPtr.__Internal*)__Instance)->rep = ((global::gambit.Gambit.GamePlayerRep) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.GamePlayerRep) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameStrategyRep)))
                    {
                        ((global::gambit.Gambit.GameObjectPtr.__Internal*)__Instance)->rep = ((global::gambit.Gambit.GameStrategyRep) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.GameStrategyRep) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameActionRep)))
                    {
                        ((global::gambit.Gambit.GameObjectPtr.__Internal*)__Instance)->rep = ((global::gambit.Gambit.GameActionRep) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.GameActionRep) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameNodeRep)))
                    {
                        ((global::gambit.Gambit.GameObjectPtr.__Internal*)__Instance)->rep = ((global::gambit.Gambit.GameNodeRep) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.GameNodeRep) (object) value).__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.GameOutcomeRep)))
                    {
                        ((global::gambit.Gambit.GameObjectPtr.__Internal*)__Instance)->rep = ((global::gambit.Gambit.GameOutcomeRep) (object) value) is null ? __IntPtr.Zero : ((global::gambit.Gambit.GameOutcomeRep) (object) value).__Instance;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.GameObjectPtr<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.GameRep>, <global::gambit.Gambit.GameInfosetRep>, <global::gambit.Gambit.GamePlayerRep>, <global::gambit.Gambit.GameStrategyRep>, <global::gambit.Gambit.GameActionRep>, <global::gambit.Gambit.GameNodeRep>, <global::gambit.Gambit.GameOutcomeRep>.");
                }
            }
        }

        /// <summary>
        /// <para>This is a base class for all game-related objects.  Primary among</para>
        /// <para>its responsibility is maintaining a reference count.  Calling code</para>
        /// <para>which maintains pointers to objects representing parts of a game</para>
        /// <para>(e.g., nodes) which may be deleted should increment the reference</para>
        /// <para>count for that object.  The library guarantees that any object</para>
        /// <para>with a positive reference count will not have its memory deleted,</para>
        /// <para>but will instead be marked as deleted.  Calling code should always</para>
        /// <para>be careful to check the deleted status of the object before any</para>
        /// <para>operations on it.</para>
        /// </summary>
        public unsafe partial class GameObject : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_GameObject;
                internal int m_refCount;
                internal byte m_valid;
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.GameObject> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.GameObject>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.GameObject managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.GameObject managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static GameObject __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameObject(native.ToPointer(), skipVTables);
            }

            internal static GameObject __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameObject)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static GameObject __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GameObject)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GameObject __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameObject(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GameObject(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GameObject(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            protected int MRefCount
            {
                get
                {
                    return ((__Internal*)__Instance)->m_refCount;
                }

                set
                {
                    ((__Internal*)__Instance)->m_refCount = value;
                }
            }

            protected bool MValid
            {
                get
                {
                    return ((__Internal*)__Instance)->m_valid != 0;
                }

                set
                {
                    ((__Internal*)__Instance)->m_valid = (byte) (value ? 1 : 0);
                }
            }

            #region Virtual table interop

            // virtual ~GameObject() = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.GameObject.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class BaseGameRep : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_BaseGameRep;
                internal int m_refCount;
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.BaseGameRep> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.BaseGameRep>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.BaseGameRep managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.BaseGameRep managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static BaseGameRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new BaseGameRep(native.ToPointer(), skipVTables);
            }

            internal static BaseGameRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (BaseGameRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static BaseGameRep __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (BaseGameRep)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static BaseGameRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new BaseGameRep(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private BaseGameRep(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected BaseGameRep(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            protected int MRefCount
            {
                get
                {
                    return ((__Internal*)__Instance)->m_refCount;
                }

                set
                {
                    ((__Internal*)__Instance)->m_refCount = value;
                }
            }

            #region Virtual table interop

            // virtual ~BaseGameRep() = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.BaseGameRep.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>An exception thrown when attempting to dereference an invalidated object</summary>
        public unsafe partial class InvalidObjectException : global::gambit.Gambit.Exception, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;
            }

            internal static new InvalidObjectException __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new InvalidObjectException(native.ToPointer(), skipVTables);
            }

            internal static new InvalidObjectException __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (InvalidObjectException)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new InvalidObjectException __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (InvalidObjectException)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static InvalidObjectException __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new InvalidObjectException(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private InvalidObjectException(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected InvalidObjectException(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public virtual string What()
            {
                var ___WhatDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func___IntPtr___IntPtr>(0, 1);
                var ___ret = ___WhatDelegate(__Instance);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            #region Virtual table interop

            // ~InvalidObjectException() noexcept override = default
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.InvalidObjectException.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // char *what() const noexcept override
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _WhatDelegateInstance;

            private static __IntPtr _WhatDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.InvalidObjectException.__GetInstance(__instance);
                var ___ret = __target.What();
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(___ret);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                return __bytePtr0;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[2];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _WhatDelegateInstance += _WhatDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_WhatDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 2, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                VTables.Methods[0] = new Delegate[2];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe static partial class GameObjectPtrExtensions
        {
            public partial struct __Internal
            {
            }
        }
    }
}
