// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace gambit
{
    namespace Gambit
    {
        namespace Agg
        {
            public enum TypeEnum
            {
                P_SUM = 0,
                P_EXIST = 1,
                P_HIGH = 2,
                P_LOW = 3,
                P_SUM2 = 10,
                P_EXIST2 = 11,
                P_HIGH2 = 12,
                P_LOW2 = 13
            }

            public unsafe abstract partial class ProjFunc : IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public partial struct __Internal
                {
                    internal __IntPtr vfptr_proj_func;
                    internal global::gambit.Gambit.Agg.TypeEnum Type;
                    internal int Default;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I weights;
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Agg.ProjFunc> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Agg.ProjFunc>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.Agg.ProjFunc managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.Agg.ProjFunc managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static ProjFunc __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new ProjFuncInternal(native.ToPointer(), skipVTables);
                }

                internal static ProjFunc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (ProjFunc)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static ProjFunc __GetInstance(__IntPtr native)
                {
                    if (!__TryGetNativeToManagedMapping(native, out var managed))
                        throw new global::System.Exception("No managed instance was found");
                    var result = (ProjFunc)managed;
                    if (result.__ownsNativeInstance)
                        result.SetupVTables();
                    return result;
                }

                internal static ProjFunc __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new ProjFuncInternal(native, skipVTables);
                }

                protected ProjFunc(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                    if (!skipVTables)
                        SetupVTables(true);
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::gambit.Gambit.Agg.TypeEnum Type
                {
                    get
                    {
                        return ((__Internal*)__Instance)->Type;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->Type = value;
                    }
                }

                public int Default
                {
                    get
                    {
                        return ((__Internal*)__Instance)->Default;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->Default = value;
                    }
                }

                #region Virtual table interop

                // virtual ~proj_func() = default
                private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

                private static void _dtorDelegateHook(__IntPtr __instance, int delete)
                {
                    var __target = global::gambit.Gambit.Agg.ProjFunc.__GetInstance(__instance);
                    __target.Dispose(disposing: true, callNativeDtor: true);
                }

                internal static class VTableLoader
                {
                    private static volatile bool initialized;
                    private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                    private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                    private static readonly IntPtr[] Thunks = new IntPtr[1];
                    private static CppSharp.Runtime.VTables VTables;
                    private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                        SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                    static VTableLoader()
                    {
                        _dtorDelegateInstance += _dtorDelegateHook;
                        Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    }

                    public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                    {
                        if (!initialized)
                        {
                            lock (ManagedVTables)
                            {
                                if (!initialized)
                                {
                                    initialized = true;
                                    VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                    VTables.Methods = new Delegate[1][];
                                    ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                    ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTables[0][0] = Thunks[0];
                                    VTables.Methods[0] = new Delegate[4];
                                }
                            }
                        }

                        if (destructorOnly)
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        }
                        else
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        }
                        return VTables;
                    }
                }

                protected CppSharp.Runtime.VTables __vtables;
                internal virtual CppSharp.Runtime.VTables __VTables
                {
                    get {
                        if (__vtables.IsEmpty)
                            __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                        return __vtables;
                    }

                    set {
                        __vtables = value;
                    }
                }
                internal virtual void SetupVTables(bool destructorOnly = false)
                {
                    if (__VTables.IsTransient)
                        __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
                }
                #endregion
            }

            public unsafe partial class ProjFuncSUM : global::gambit.Gambit.Agg.ProjFunc, IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public new partial struct __Internal
                {
                    internal __IntPtr vfptr_proj_func;
                    internal global::gambit.Gambit.Agg.TypeEnum Type;
                    internal int Default;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I weights;
                }

                internal static new ProjFuncSUM __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new ProjFuncSUM(native.ToPointer(), skipVTables);
                }

                internal static new ProjFuncSUM __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (ProjFuncSUM)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static new ProjFuncSUM __GetInstance(__IntPtr native)
                {
                    if (!__TryGetNativeToManagedMapping(native, out var managed))
                        throw new global::System.Exception("No managed instance was found");
                    var result = (ProjFuncSUM)managed;
                    if (result.__ownsNativeInstance)
                        result.SetupVTables();
                    return result;
                }

                internal static ProjFuncSUM __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new ProjFuncSUM(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ProjFuncSUM(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected ProjFuncSUM(void* native, bool skipVTables = false)
                    : base((void*) native)
                {
                    if (native == null)
                        return;
                    if (!skipVTables)
                        SetupVTables(true);
                }

                partial void DisposePartial(bool disposing);

                internal protected override void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                #region Virtual table interop

                // proj_func_SUM
                private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

                private static void _dtorDelegateHook(__IntPtr __instance, int delete)
                {
                    var __target = global::gambit.Gambit.Agg.ProjFuncSUM.__GetInstance(__instance);
                    __target.Dispose(disposing: true, callNativeDtor: true);
                }

                internal static new class VTableLoader
                {
                    private static volatile bool initialized;
                    private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                    private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                    private static readonly IntPtr[] Thunks = new IntPtr[1];
                    private static CppSharp.Runtime.VTables VTables;
                    private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                        SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                    static VTableLoader()
                    {
                        _dtorDelegateInstance += _dtorDelegateHook;
                        Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    }

                    public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                    {
                        if (!initialized)
                        {
                            lock (ManagedVTables)
                            {
                                if (!initialized)
                                {
                                    initialized = true;
                                    VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                    VTables.Methods = new Delegate[1][];
                                    ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                    ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTables[0][0] = Thunks[0];
                                    VTables.Methods[0] = new Delegate[4];
                                }
                            }
                        }

                        if (destructorOnly)
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        }
                        else
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        }
                        return VTables;
                    }
                }

                internal override CppSharp.Runtime.VTables __VTables
                {
                    get {
                        if (__vtables.IsEmpty)
                            __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                        return __vtables;
                    }

                    set {
                        __vtables = value;
                    }
                }
                internal override void SetupVTables(bool destructorOnly = false)
                {
                    if (__VTables.IsTransient)
                        __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
                }
                #endregion
            }

            public unsafe partial class ProjFuncSUM2 : global::gambit.Gambit.Agg.ProjFunc, IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public new partial struct __Internal
                {
                    internal __IntPtr vfptr_proj_func;
                    internal global::gambit.Gambit.Agg.TypeEnum Type;
                    internal int Default;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I weights;
                }

                internal static new ProjFuncSUM2 __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new ProjFuncSUM2(native.ToPointer(), skipVTables);
                }

                internal static new ProjFuncSUM2 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (ProjFuncSUM2)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static new ProjFuncSUM2 __GetInstance(__IntPtr native)
                {
                    if (!__TryGetNativeToManagedMapping(native, out var managed))
                        throw new global::System.Exception("No managed instance was found");
                    var result = (ProjFuncSUM2)managed;
                    if (result.__ownsNativeInstance)
                        result.SetupVTables();
                    return result;
                }

                internal static ProjFuncSUM2 __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new ProjFuncSUM2(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ProjFuncSUM2(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected ProjFuncSUM2(void* native, bool skipVTables = false)
                    : base((void*) native)
                {
                    if (native == null)
                        return;
                    if (!skipVTables)
                        SetupVTables(true);
                }

                partial void DisposePartial(bool disposing);

                internal protected override void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                #region Virtual table interop

                // proj_func_SUM2
                private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

                private static void _dtorDelegateHook(__IntPtr __instance, int delete)
                {
                    var __target = global::gambit.Gambit.Agg.ProjFuncSUM2.__GetInstance(__instance);
                    __target.Dispose(disposing: true, callNativeDtor: true);
                }

                internal static new class VTableLoader
                {
                    private static volatile bool initialized;
                    private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                    private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                    private static readonly IntPtr[] Thunks = new IntPtr[1];
                    private static CppSharp.Runtime.VTables VTables;
                    private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                        SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                    static VTableLoader()
                    {
                        _dtorDelegateInstance += _dtorDelegateHook;
                        Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    }

                    public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                    {
                        if (!initialized)
                        {
                            lock (ManagedVTables)
                            {
                                if (!initialized)
                                {
                                    initialized = true;
                                    VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                    VTables.Methods = new Delegate[1][];
                                    ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                    ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTables[0][0] = Thunks[0];
                                    VTables.Methods[0] = new Delegate[4];
                                }
                            }
                        }

                        if (destructorOnly)
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        }
                        else
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        }
                        return VTables;
                    }
                }

                internal override CppSharp.Runtime.VTables __VTables
                {
                    get {
                        if (__vtables.IsEmpty)
                            __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                        return __vtables;
                    }

                    set {
                        __vtables = value;
                    }
                }
                internal override void SetupVTables(bool destructorOnly = false)
                {
                    if (__VTables.IsTransient)
                        __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
                }
                #endregion
            }

            public unsafe partial class ProjFuncEXIST : global::gambit.Gambit.Agg.ProjFunc, IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public new partial struct __Internal
                {
                    internal __IntPtr vfptr_proj_func;
                    internal global::gambit.Gambit.Agg.TypeEnum Type;
                    internal int Default;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I weights;
                }

                internal static new ProjFuncEXIST __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new ProjFuncEXIST(native.ToPointer(), skipVTables);
                }

                internal static new ProjFuncEXIST __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (ProjFuncEXIST)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static new ProjFuncEXIST __GetInstance(__IntPtr native)
                {
                    if (!__TryGetNativeToManagedMapping(native, out var managed))
                        throw new global::System.Exception("No managed instance was found");
                    var result = (ProjFuncEXIST)managed;
                    if (result.__ownsNativeInstance)
                        result.SetupVTables();
                    return result;
                }

                internal static ProjFuncEXIST __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new ProjFuncEXIST(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ProjFuncEXIST(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected ProjFuncEXIST(void* native, bool skipVTables = false)
                    : base((void*) native)
                {
                    if (native == null)
                        return;
                    if (!skipVTables)
                        SetupVTables(true);
                }

                partial void DisposePartial(bool disposing);

                internal protected override void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                #region Virtual table interop

                // proj_func_EXIST
                private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

                private static void _dtorDelegateHook(__IntPtr __instance, int delete)
                {
                    var __target = global::gambit.Gambit.Agg.ProjFuncEXIST.__GetInstance(__instance);
                    __target.Dispose(disposing: true, callNativeDtor: true);
                }

                internal static new class VTableLoader
                {
                    private static volatile bool initialized;
                    private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                    private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                    private static readonly IntPtr[] Thunks = new IntPtr[1];
                    private static CppSharp.Runtime.VTables VTables;
                    private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                        SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                    static VTableLoader()
                    {
                        _dtorDelegateInstance += _dtorDelegateHook;
                        Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    }

                    public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                    {
                        if (!initialized)
                        {
                            lock (ManagedVTables)
                            {
                                if (!initialized)
                                {
                                    initialized = true;
                                    VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                    VTables.Methods = new Delegate[1][];
                                    ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                    ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTables[0][0] = Thunks[0];
                                    VTables.Methods[0] = new Delegate[4];
                                }
                            }
                        }

                        if (destructorOnly)
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        }
                        else
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        }
                        return VTables;
                    }
                }

                internal override CppSharp.Runtime.VTables __VTables
                {
                    get {
                        if (__vtables.IsEmpty)
                            __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                        return __vtables;
                    }

                    set {
                        __vtables = value;
                    }
                }
                internal override void SetupVTables(bool destructorOnly = false)
                {
                    if (__VTables.IsTransient)
                        __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
                }
                #endregion
            }

            public unsafe partial class ProjFuncEXIST2 : global::gambit.Gambit.Agg.ProjFunc, IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public new partial struct __Internal
                {
                    internal __IntPtr vfptr_proj_func;
                    internal global::gambit.Gambit.Agg.TypeEnum Type;
                    internal int Default;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I weights;
                }

                internal static new ProjFuncEXIST2 __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new ProjFuncEXIST2(native.ToPointer(), skipVTables);
                }

                internal static new ProjFuncEXIST2 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (ProjFuncEXIST2)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static new ProjFuncEXIST2 __GetInstance(__IntPtr native)
                {
                    if (!__TryGetNativeToManagedMapping(native, out var managed))
                        throw new global::System.Exception("No managed instance was found");
                    var result = (ProjFuncEXIST2)managed;
                    if (result.__ownsNativeInstance)
                        result.SetupVTables();
                    return result;
                }

                internal static ProjFuncEXIST2 __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new ProjFuncEXIST2(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ProjFuncEXIST2(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected ProjFuncEXIST2(void* native, bool skipVTables = false)
                    : base((void*) native)
                {
                    if (native == null)
                        return;
                    if (!skipVTables)
                        SetupVTables(true);
                }

                partial void DisposePartial(bool disposing);

                internal protected override void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                #region Virtual table interop

                // proj_func_EXIST2
                private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

                private static void _dtorDelegateHook(__IntPtr __instance, int delete)
                {
                    var __target = global::gambit.Gambit.Agg.ProjFuncEXIST2.__GetInstance(__instance);
                    __target.Dispose(disposing: true, callNativeDtor: true);
                }

                internal static new class VTableLoader
                {
                    private static volatile bool initialized;
                    private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                    private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                    private static readonly IntPtr[] Thunks = new IntPtr[1];
                    private static CppSharp.Runtime.VTables VTables;
                    private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                        SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                    static VTableLoader()
                    {
                        _dtorDelegateInstance += _dtorDelegateHook;
                        Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    }

                    public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                    {
                        if (!initialized)
                        {
                            lock (ManagedVTables)
                            {
                                if (!initialized)
                                {
                                    initialized = true;
                                    VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                    VTables.Methods = new Delegate[1][];
                                    ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                    ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTables[0][0] = Thunks[0];
                                    VTables.Methods[0] = new Delegate[4];
                                }
                            }
                        }

                        if (destructorOnly)
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        }
                        else
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        }
                        return VTables;
                    }
                }

                internal override CppSharp.Runtime.VTables __VTables
                {
                    get {
                        if (__vtables.IsEmpty)
                            __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                        return __vtables;
                    }

                    set {
                        __vtables = value;
                    }
                }
                internal override void SetupVTables(bool destructorOnly = false)
                {
                    if (__VTables.IsTransient)
                        __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
                }
                #endregion
            }

            public unsafe partial class ProjFuncHIGH : global::gambit.Gambit.Agg.ProjFunc, IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public new partial struct __Internal
                {
                    internal __IntPtr vfptr_proj_func;
                    internal global::gambit.Gambit.Agg.TypeEnum Type;
                    internal int Default;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I weights;
                }

                internal static new ProjFuncHIGH __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new ProjFuncHIGH(native.ToPointer(), skipVTables);
                }

                internal static new ProjFuncHIGH __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (ProjFuncHIGH)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static new ProjFuncHIGH __GetInstance(__IntPtr native)
                {
                    if (!__TryGetNativeToManagedMapping(native, out var managed))
                        throw new global::System.Exception("No managed instance was found");
                    var result = (ProjFuncHIGH)managed;
                    if (result.__ownsNativeInstance)
                        result.SetupVTables();
                    return result;
                }

                internal static ProjFuncHIGH __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new ProjFuncHIGH(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ProjFuncHIGH(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected ProjFuncHIGH(void* native, bool skipVTables = false)
                    : base((void*) native)
                {
                    if (native == null)
                        return;
                    if (!skipVTables)
                        SetupVTables(true);
                }

                partial void DisposePartial(bool disposing);

                internal protected override void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                #region Virtual table interop

                // proj_func_HIGH
                private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

                private static void _dtorDelegateHook(__IntPtr __instance, int delete)
                {
                    var __target = global::gambit.Gambit.Agg.ProjFuncHIGH.__GetInstance(__instance);
                    __target.Dispose(disposing: true, callNativeDtor: true);
                }

                internal static new class VTableLoader
                {
                    private static volatile bool initialized;
                    private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                    private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                    private static readonly IntPtr[] Thunks = new IntPtr[1];
                    private static CppSharp.Runtime.VTables VTables;
                    private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                        SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                    static VTableLoader()
                    {
                        _dtorDelegateInstance += _dtorDelegateHook;
                        Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    }

                    public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                    {
                        if (!initialized)
                        {
                            lock (ManagedVTables)
                            {
                                if (!initialized)
                                {
                                    initialized = true;
                                    VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                    VTables.Methods = new Delegate[1][];
                                    ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                    ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTables[0][0] = Thunks[0];
                                    VTables.Methods[0] = new Delegate[4];
                                }
                            }
                        }

                        if (destructorOnly)
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        }
                        else
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        }
                        return VTables;
                    }
                }

                internal override CppSharp.Runtime.VTables __VTables
                {
                    get {
                        if (__vtables.IsEmpty)
                            __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                        return __vtables;
                    }

                    set {
                        __vtables = value;
                    }
                }
                internal override void SetupVTables(bool destructorOnly = false)
                {
                    if (__VTables.IsTransient)
                        __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
                }
                #endregion
            }

            public unsafe partial class ProjFuncHIGH2 : global::gambit.Gambit.Agg.ProjFunc, IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public new partial struct __Internal
                {
                    internal __IntPtr vfptr_proj_func;
                    internal global::gambit.Gambit.Agg.TypeEnum Type;
                    internal int Default;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I weights;
                }

                internal static new ProjFuncHIGH2 __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new ProjFuncHIGH2(native.ToPointer(), skipVTables);
                }

                internal static new ProjFuncHIGH2 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (ProjFuncHIGH2)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static new ProjFuncHIGH2 __GetInstance(__IntPtr native)
                {
                    if (!__TryGetNativeToManagedMapping(native, out var managed))
                        throw new global::System.Exception("No managed instance was found");
                    var result = (ProjFuncHIGH2)managed;
                    if (result.__ownsNativeInstance)
                        result.SetupVTables();
                    return result;
                }

                internal static ProjFuncHIGH2 __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new ProjFuncHIGH2(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ProjFuncHIGH2(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected ProjFuncHIGH2(void* native, bool skipVTables = false)
                    : base((void*) native)
                {
                    if (native == null)
                        return;
                    if (!skipVTables)
                        SetupVTables(true);
                }

                partial void DisposePartial(bool disposing);

                internal protected override void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                #region Virtual table interop

                // proj_func_HIGH2
                private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

                private static void _dtorDelegateHook(__IntPtr __instance, int delete)
                {
                    var __target = global::gambit.Gambit.Agg.ProjFuncHIGH2.__GetInstance(__instance);
                    __target.Dispose(disposing: true, callNativeDtor: true);
                }

                internal static new class VTableLoader
                {
                    private static volatile bool initialized;
                    private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                    private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                    private static readonly IntPtr[] Thunks = new IntPtr[1];
                    private static CppSharp.Runtime.VTables VTables;
                    private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                        SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                    static VTableLoader()
                    {
                        _dtorDelegateInstance += _dtorDelegateHook;
                        Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    }

                    public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                    {
                        if (!initialized)
                        {
                            lock (ManagedVTables)
                            {
                                if (!initialized)
                                {
                                    initialized = true;
                                    VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                    VTables.Methods = new Delegate[1][];
                                    ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                    ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTables[0][0] = Thunks[0];
                                    VTables.Methods[0] = new Delegate[4];
                                }
                            }
                        }

                        if (destructorOnly)
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        }
                        else
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        }
                        return VTables;
                    }
                }

                internal override CppSharp.Runtime.VTables __VTables
                {
                    get {
                        if (__vtables.IsEmpty)
                            __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                        return __vtables;
                    }

                    set {
                        __vtables = value;
                    }
                }
                internal override void SetupVTables(bool destructorOnly = false)
                {
                    if (__VTables.IsTransient)
                        __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
                }
                #endregion
            }

            public unsafe partial class ProjFuncLOW : global::gambit.Gambit.Agg.ProjFunc, IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public new partial struct __Internal
                {
                    internal __IntPtr vfptr_proj_func;
                    internal global::gambit.Gambit.Agg.TypeEnum Type;
                    internal int Default;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I weights;
                }

                internal static new ProjFuncLOW __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new ProjFuncLOW(native.ToPointer(), skipVTables);
                }

                internal static new ProjFuncLOW __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (ProjFuncLOW)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static new ProjFuncLOW __GetInstance(__IntPtr native)
                {
                    if (!__TryGetNativeToManagedMapping(native, out var managed))
                        throw new global::System.Exception("No managed instance was found");
                    var result = (ProjFuncLOW)managed;
                    if (result.__ownsNativeInstance)
                        result.SetupVTables();
                    return result;
                }

                internal static ProjFuncLOW __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new ProjFuncLOW(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ProjFuncLOW(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected ProjFuncLOW(void* native, bool skipVTables = false)
                    : base((void*) native)
                {
                    if (native == null)
                        return;
                    if (!skipVTables)
                        SetupVTables(true);
                }

                partial void DisposePartial(bool disposing);

                internal protected override void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                #region Virtual table interop

                // proj_func_LOW
                private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

                private static void _dtorDelegateHook(__IntPtr __instance, int delete)
                {
                    var __target = global::gambit.Gambit.Agg.ProjFuncLOW.__GetInstance(__instance);
                    __target.Dispose(disposing: true, callNativeDtor: true);
                }

                internal static new class VTableLoader
                {
                    private static volatile bool initialized;
                    private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                    private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                    private static readonly IntPtr[] Thunks = new IntPtr[1];
                    private static CppSharp.Runtime.VTables VTables;
                    private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                        SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                    static VTableLoader()
                    {
                        _dtorDelegateInstance += _dtorDelegateHook;
                        Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    }

                    public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                    {
                        if (!initialized)
                        {
                            lock (ManagedVTables)
                            {
                                if (!initialized)
                                {
                                    initialized = true;
                                    VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                    VTables.Methods = new Delegate[1][];
                                    ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                    ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTables[0][0] = Thunks[0];
                                    VTables.Methods[0] = new Delegate[4];
                                }
                            }
                        }

                        if (destructorOnly)
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        }
                        else
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        }
                        return VTables;
                    }
                }

                internal override CppSharp.Runtime.VTables __VTables
                {
                    get {
                        if (__vtables.IsEmpty)
                            __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                        return __vtables;
                    }

                    set {
                        __vtables = value;
                    }
                }
                internal override void SetupVTables(bool destructorOnly = false)
                {
                    if (__VTables.IsTransient)
                        __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
                }
                #endregion
            }

            public unsafe partial class ProjFuncLOW2 : global::gambit.Gambit.Agg.ProjFunc, IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 40)]
                public new partial struct __Internal
                {
                    internal __IntPtr vfptr_proj_func;
                    internal global::gambit.Gambit.Agg.TypeEnum Type;
                    internal int Default;
                    internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I weights;
                }

                internal static new ProjFuncLOW2 __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new ProjFuncLOW2(native.ToPointer(), skipVTables);
                }

                internal static new ProjFuncLOW2 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (ProjFuncLOW2)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static new ProjFuncLOW2 __GetInstance(__IntPtr native)
                {
                    if (!__TryGetNativeToManagedMapping(native, out var managed))
                        throw new global::System.Exception("No managed instance was found");
                    var result = (ProjFuncLOW2)managed;
                    if (result.__ownsNativeInstance)
                        result.SetupVTables();
                    return result;
                }

                internal static ProjFuncLOW2 __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new ProjFuncLOW2(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ProjFuncLOW2(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected ProjFuncLOW2(void* native, bool skipVTables = false)
                    : base((void*) native)
                {
                    if (native == null)
                        return;
                    if (!skipVTables)
                        SetupVTables(true);
                }

                partial void DisposePartial(bool disposing);

                internal protected override void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                #region Virtual table interop

                // proj_func_LOW2
                private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

                private static void _dtorDelegateHook(__IntPtr __instance, int delete)
                {
                    var __target = global::gambit.Gambit.Agg.ProjFuncLOW2.__GetInstance(__instance);
                    __target.Dispose(disposing: true, callNativeDtor: true);
                }

                internal static new class VTableLoader
                {
                    private static volatile bool initialized;
                    private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                    private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                    private static readonly IntPtr[] Thunks = new IntPtr[1];
                    private static CppSharp.Runtime.VTables VTables;
                    private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                        SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                    static VTableLoader()
                    {
                        _dtorDelegateInstance += _dtorDelegateHook;
                        Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    }

                    public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                    {
                        if (!initialized)
                        {
                            lock (ManagedVTables)
                            {
                                if (!initialized)
                                {
                                    initialized = true;
                                    VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                    VTables.Methods = new Delegate[1][];
                                    ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                    ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 0);
                                    ManagedVTables[0][0] = Thunks[0];
                                    VTables.Methods[0] = new Delegate[4];
                                }
                            }
                        }

                        if (destructorOnly)
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                        }
                        else
                        {
                            *(IntPtr**)(instance + 0) = ManagedVTables[0];
                        }
                        return VTables;
                    }
                }

                internal override CppSharp.Runtime.VTables __VTables
                {
                    get {
                        if (__vtables.IsEmpty)
                            __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                        return __vtables;
                    }

                    set {
                        __vtables = value;
                    }
                }
                internal override void SetupVTables(bool destructorOnly = false)
                {
                    if (__VTables.IsTransient)
                        __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
                }
                #endregion
            }

            public unsafe partial class ProjFuncInternal : global::gambit.Gambit.Agg.ProjFunc, IDisposable
            {
                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                internal ProjFuncInternal(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                internal ProjFuncInternal(void* native, bool skipVTables = false)
                    : base((void*) native)
                {
                }
            }
        }
    }
}
