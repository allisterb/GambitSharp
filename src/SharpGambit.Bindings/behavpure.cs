// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace gambit
{
    namespace Gambit
    {
        /// <summary>
        /// <para>This class represents a behavior profile on an extensive game.</para>
        /// <para>It specifies exactly one strategy for each information set in the</para>
        /// <para>game.</para>
        /// </summary>
        public unsafe partial class PureBehaviorProfile : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public partial struct __Internal
            {
                internal global::gambit.Gambit.GameObjectPtr.__Internal m_efg;
                internal global::gambit.Gambit.Array.__Internal m_profile;

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "c__N_Gambit_S_PureBehaviorProfile__PureBehaviorProfile", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.PureBehaviorProfile> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.PureBehaviorProfile>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.PureBehaviorProfile managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.PureBehaviorProfile managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static PureBehaviorProfile __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new PureBehaviorProfile(native.ToPointer(), skipVTables);
            }

            internal static PureBehaviorProfile __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (PureBehaviorProfile)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static PureBehaviorProfile __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PureBehaviorProfile(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private PureBehaviorProfile(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected PureBehaviorProfile(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        public unsafe partial class BehaviorProfileIterator : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 216)]
            public partial struct __Internal
            {
                internal byte m_atEnd;
                internal global::gambit.Gambit.BehaviorSupportProfile.__Internal m_support;
                internal global::gambit.Gambit.PVector.__Internal m_currentBehav;
                internal global::gambit.Gambit.PureBehaviorProfile.__Internal m_profile;
                internal int m_frozenPlayer;
                internal int m_frozenInfoset;
                internal global::gambit.Gambit.Array.__Internal m_isActive;
                internal global::gambit.Gambit.Array.__Internal m_numActiveInfosets;

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "c__N_Gambit_S_BehaviorProfileIterator__BehaviorProfileIterator", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.BehaviorProfileIterator> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.BehaviorProfileIterator>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.BehaviorProfileIterator managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.BehaviorProfileIterator managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static BehaviorProfileIterator __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new BehaviorProfileIterator(native.ToPointer(), skipVTables);
            }

            internal static BehaviorProfileIterator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (BehaviorProfileIterator)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static BehaviorProfileIterator __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new BehaviorProfileIterator(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private BehaviorProfileIterator(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected BehaviorProfileIterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }
    }
}
