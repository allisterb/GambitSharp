// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace gambit
{
    namespace Gambit
    {
        namespace MixedBehaviorProfile
        {
            [StructLayout(LayoutKind.Sequential, Size = 280)]
            public unsafe partial struct __Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational
            {
                internal global::gambit.Gambit.DVector.__Internal m_probs;
                internal global::gambit.Gambit.BehaviorSupportProfile.__Internal m_support;
                internal uint m_gameversion;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_Gambit_S_Rational___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_ map_realizProbs;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_Gambit_S_Rational___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_ map_beliefs;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep___N_Gambit_S_Rational___N_std_S_less__S3____N_std_S_allocator____N_std_S_pair__1S3__S5____N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_ map_nodeValues;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep___N_Gambit_S_Rational___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_ map_infosetValues;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep___N_Gambit_S_Rational___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_ map_actionValues;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep___N_Gambit_S_Rational___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_ map_regret;

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "c__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational_F__MixedBehaviorProfile", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtorc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational(__IntPtr __instance);
            }

            [StructLayout(LayoutKind.Sequential, Size = 280)]
            public unsafe partial struct __Internalc__N_Gambit_S_MixedBehaviorProfile__d
            {
                internal global::gambit.Gambit.DVector.__Internal m_probs;
                internal global::gambit.Gambit.BehaviorSupportProfile.__Internal m_support;
                internal uint m_gameversion;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep_d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__d map_realizProbs;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep_d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__d map_beliefs;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep___N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep_d___N_std_S_less__S3____N_std_S_allocator____N_std_S_pair__1S3__d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_ map_nodeValues;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep_d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__d map_infosetValues;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep_d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__d map_actionValues;
                internal global::Std.Map.__Internalc__N_std_S_map____N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep_d___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__d map_regret;

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "c__N_Gambit_S_MixedBehaviorProfile__d_F__MixedBehaviorProfile", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtorc__N_Gambit_S_MixedBehaviorProfile__d(__IntPtr __instance);
            }
        }

        /// <summary>
        /// <para>MixedBehaviorProfileimplements a randomized behavior profile on</para>
        /// <para>an extensive game.</para>
        /// </summary>
        public unsafe partial class MixedBehaviorProfile<T> : IDisposable
        {
            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.MixedBehaviorProfile<T>> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.MixedBehaviorProfile<T>>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.MixedBehaviorProfile<T> managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.MixedBehaviorProfile<T> managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static MixedBehaviorProfile<T> __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new MixedBehaviorProfile<T>(native.ToPointer(), skipVTables);
            }

            internal static MixedBehaviorProfile<T> __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (MixedBehaviorProfile<T>)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static MixedBehaviorProfile<T> __CreateInstance(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational native, bool skipVTables = false)
            {
                return new MixedBehaviorProfile<T>(native, skipVTables);
            }

            private static void* __CopyValue(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational));
                *(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational*) ret = native;
                return ret.ToPointer();
            }

            private MixedBehaviorProfile(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal static MixedBehaviorProfile<T> __CreateInstance(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d native, bool skipVTables = false)
            {
                return new MixedBehaviorProfile<T>(native, skipVTables);
            }

            private static void* __CopyValue(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d));
                *(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d*) ret = native;
                return ret.ToPointer();
            }

            private MixedBehaviorProfile(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected MixedBehaviorProfile(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public MixedBehaviorProfile(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method MixedBehaviorProfile_T_ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method MixedBehaviorProfile_T_ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public MixedBehaviorProfile(global::gambit.Gambit.BehaviorSupportProfile _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method MixedBehaviorProfile_T_ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method MixedBehaviorProfile_T_ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public MixedBehaviorProfile(global::gambit.Gambit.MixedBehaviorProfile<T> _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method MixedBehaviorProfile_T_ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method MixedBehaviorProfile_T_ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public MixedBehaviorProfile(global::gambit.Gambit.MixedStrategyProfile<T> _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method MixedBehaviorProfile_T_ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method MixedBehaviorProfile_T_ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            protected void ComputePass1_realizProbs(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> node)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method ComputePass1_realizProbs ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method ComputePass1_realizProbs ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            protected void ComputePass2_beliefs_nodeValues_actionValues(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> node)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method ComputePass2_beliefs_nodeValues_actionValues ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method ComputePass2_beliefs_nodeValues_actionValues ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            protected void ComputePass3_infosetValues_regret()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method ComputePass3_infosetValues_regret ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method ComputePass3_infosetValues_regret ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            protected void ComputeSolutionData()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method ComputeSolutionData ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method ComputeSolutionData ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Check underlying game has not changed; raise exception if it has</summary>
            protected void CheckVersion()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method CheckVersion ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method CheckVersion ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public static bool operator ==(global::gambit.Gambit.MixedBehaviorProfile<T> __op, global::gambit.Gambit.MixedBehaviorProfile<T> _0)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::gambit.Gambit.MixedBehaviorProfile<T>;
            }

            public override int GetHashCode()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational*) __Instance).GetHashCode();
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    if (__Instance == __IntPtr.Zero)
                        return __IntPtr.Zero.GetHashCode();
                    return (*(global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d*) __Instance).GetHashCode();
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public static bool operator !=(global::gambit.Gambit.MixedBehaviorProfile<T> __op, global::gambit.Gambit.MixedBehaviorProfile<T> x)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public static bool operator ==(global::gambit.Gambit.MixedBehaviorProfile<T> __op, global::gambit.Gambit.DVector<T> x)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public static bool operator !=(global::gambit.Gambit.MixedBehaviorProfile<T> __op, global::gambit.Gambit.DVector<T> x)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator__ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public static implicit operator global::gambit.Gambit.Vector<T>(global::gambit.Gambit.MixedBehaviorProfile<T> __op)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method operator_const_Vector_type_parameter_0_0___ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method operator_const_Vector_type_parameter_0_0___ ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>
            /// <para>Force recomputation of stored quantities</para>
            /// <para>The validity of all caches is determined by the existence of the root node in the</para>
            /// <para>primary cache (first to be computed) map_realizProbs</para>
            /// <para>We also clear</para>
            /// <para>map_nodeValues, map_actionValues</para>
            /// <para>as otherwise we would need to reset them to 0 while populating them</para>
            /// </summary>
            public void InvalidateCache()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method InvalidateCache ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method InvalidateCache ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Set the profile to the centroid</summary>
            public void SetCentroid()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method SetCentroid ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method SetCentroid ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Set the behavior at any undefined information set to the centroid</summary>
            public void UndefinedToCentroid()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method UndefinedToCentroid ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method UndefinedToCentroid ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>
            /// <para>Create a new behaviour strategy profile where strategies are played</para>
            /// <para>in the same proportions, but with probabilities for each player</para>
            /// <para>summing to one.</para>
            /// </summary>
            public global::gambit.Gambit.MixedBehaviorProfile<T> Normalize()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method Normalize ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method Normalize ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public bool IsDefinedAt(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> p_infoset)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method IsDefinedAt ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method IsDefinedAt ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T GetPayoff(int p_player)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T GetPayoff(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> p_player)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T GetInfosetProb(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> iset)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetInfosetProb ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetInfosetProb ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public global::gambit.Gambit.Vector<T> GetPayoff(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> node)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetPayoff ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T GetActionProb(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> act)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetActionProb ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetActionProb ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            /// <summary>Computes the regret at information set</summary>
            /// <param name="p_infoset">The information set to compute the regret at.</param>
            /// <remarks>
            /// <para>Computes the regret at the information set to the player of playing</para>
            /// <para>their mixed action as specified in the profile.  The regret is defined</para>
            /// <para>as the difference between the payoff of the best response action and</para>
            /// <para>the payoff to playing their specified mixed action.</para>
            /// <para>GetRegret(const GameAction&amp;) const;</para>
            /// <para>GetMaxRegret() const</para>
            /// </remarks>
            public T GetRegret(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> p_infoset)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method GetRegret ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method GetRegret ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T DiffActionValue(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> action, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> oppAction)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method DiffActionValue ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method DiffActionValue ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T DiffRealizProb(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> node, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> oppAction)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method DiffRealizProb ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method DiffRealizProb ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public T DiffNodeValue(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> node, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> player, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> oppAction)
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method DiffNodeValue ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method DiffNodeValue ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public global::gambit.Gambit.MixedStrategyProfile<T> ToMixedProfile()
            {
                var __T = typeof(T);
                if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                {
                    throw new MissingMethodException("Method ToMixedProfile ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                }
                if (__T.IsAssignableFrom(typeof(double)))
                {
                    throw new MissingMethodException("Method ToMixedProfile ignored in specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                }
                throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
            }

            public static explicit operator global::gambit.Gambit.MixedBehaviorProfile<T>(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> _0)
            {
                return new global::gambit.Gambit.MixedBehaviorProfile<T>(_0);
            }

            public static explicit operator global::gambit.Gambit.MixedBehaviorProfile<T>(global::gambit.Gambit.BehaviorSupportProfile _0)
            {
                return new global::gambit.Gambit.MixedBehaviorProfile<T>(_0);
            }

            public static explicit operator global::gambit.Gambit.MixedBehaviorProfile<T>(global::gambit.Gambit.MixedStrategyProfile<T> _0)
            {
                return new global::gambit.Gambit.MixedBehaviorProfile<T>(_0);
            }

            public T this[global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> p_action]
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public T this[int a]
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Item missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            protected global::gambit.Gambit.DVector<T> MProbs
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        return (global::gambit.Gambit.DVector<T>) (object) global::gambit.Gambit.DVector<global::gambit.Gambit.Rational>.__CreateInstance(new __IntPtr(&((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational*)__Instance)->m_probs));
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        return (global::gambit.Gambit.DVector<T>) (object) global::gambit.Gambit.DVector<double>.__CreateInstance(new __IntPtr(&((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d*)__Instance)->m_probs));
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational*)__Instance)->m_probs = *(global::gambit.Gambit.DVector.__Internal*) value.__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d*)__Instance)->m_probs = *(global::gambit.Gambit.DVector.__Internal*) value.__Instance;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            protected global::gambit.Gambit.BehaviorSupportProfile MSupport
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        return global::gambit.Gambit.BehaviorSupportProfile.__CreateInstance(new __IntPtr(&((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational*)__Instance)->m_support));
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        return global::gambit.Gambit.BehaviorSupportProfile.__CreateInstance(new __IntPtr(&((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d*)__Instance)->m_support));
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational*)__Instance)->m_support = *(global::gambit.Gambit.BehaviorSupportProfile.__Internal*) value.__Instance;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d*)__Instance)->m_support = *(global::gambit.Gambit.BehaviorSupportProfile.__Internal*) value.__Instance;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            protected uint MGameversion
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        return ((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational*)__Instance)->m_gameversion;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        return ((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d*)__Instance)->m_gameversion;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }

                set
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        ((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile____N_Gambit_S_Rational*)__Instance)->m_gameversion = value;
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        ((global::gambit.Gambit.MixedBehaviorProfile.__Internalc__N_Gambit_S_MixedBehaviorProfile__d*)__Instance)->m_gameversion = value;
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public ulong BehaviorProfileLength
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method BehaviorProfileLength missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method BehaviorProfileLength missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> Game
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Game missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Game missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public global::gambit.Gambit.BehaviorSupportProfile Support
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method Support missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Support missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            /// <summary>Returns whether the profile has been invalidated by a subsequent revision to the game</summary>
            public bool IsInvalidated
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method IsInvalidated missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method IsInvalidated missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            public T LiapValue
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method LiapValue missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method LiapValue missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }

            /// <summary>Computes the maximum regret at any information set in the profile</summary>
            /// <remarks>
            /// <para>Computes the maximum of the regrets of the information sets in the profile.</para>
            /// <para>GetRegret(const GameInfoset&amp;) const;</para>
            /// <para>GetRegret(const GameAction&amp;) const</para>
            /// </remarks>
            public T MaxRegret
            {
                get
                {
                    var __T = typeof(T);
                    if (__T.IsAssignableFrom(typeof(global::gambit.Gambit.Rational)))
                    {
                        throw new MissingMethodException("Method MaxRegret missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<global::gambit.Gambit.Rational>.");
                    }
                    if (__T.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method MaxRegret missing from explicit specialization global::gambit.Gambit.MixedBehaviorProfile<double>.");
                    }
                    throw new ArgumentOutOfRangeException("T", string.Join(", ", new[] { typeof(T).FullName }), "global::gambit.Gambit.MixedBehaviorProfile<T> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::gambit.Gambit.Rational>, <double>.");
                }
            }
        }

        public unsafe static partial class MixedBehaviorProfileExtensions
        {
            public partial struct __Internal
            {
            }
        }
    }
}
