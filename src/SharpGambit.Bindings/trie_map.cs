// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace gambit
{
    namespace Gambit
    {
        namespace Agg
        {
            namespace TrieMap
            {
                [StructLayout(LayoutKind.Sequential, Size = 56)]
                public unsafe partial struct __Internalc__N_Gambit_N_agg_S_trie_map__d
                {
                    internal global::Std.List.__Internalc__N_std_S_list____N_std_S_pair____N_std_S_vector__I___N_std_S_allocator__I_d___N_std_S_allocator__S0_ data;
                    internal uint initBranches;
                    internal __IntPtr root;
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_Gambit_N_agg_S_TrieNode__d___N_std_S_allocator__S0_ leaves;

                    [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "??1?$trie_map@N@agg@Gambit@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern void dtorc__N_Gambit_N_agg_S_trie_map__d(__IntPtr __instance);
                }
            }

            public unsafe partial class TrieMap<V> : IDisposable
            {
                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Agg.TrieMap<V>> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Agg.TrieMap<V>>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.Agg.TrieMap<V> managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.Agg.TrieMap<V> managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static TrieMap<V> __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new TrieMap<V>(native.ToPointer(), skipVTables);
                }

                internal static TrieMap<V> __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (TrieMap<V>)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static TrieMap<V> __CreateInstance(global::gambit.Gambit.Agg.TrieMap.__Internalc__N_Gambit_N_agg_S_trie_map__d native, bool skipVTables = false)
                {
                    return new TrieMap<V>(native, skipVTables);
                }

                private static void* __CopyValue(global::gambit.Gambit.Agg.TrieMap.__Internalc__N_Gambit_N_agg_S_trie_map__d native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::gambit.Gambit.Agg.TrieMap.__Internalc__N_Gambit_N_agg_S_trie_map__d));
                    *(global::gambit.Gambit.Agg.TrieMap.__Internalc__N_Gambit_N_agg_S_trie_map__d*) ret = native;
                    return ret.ToPointer();
                }

                private TrieMap(global::gambit.Gambit.Agg.TrieMap.__Internalc__N_Gambit_N_agg_S_trie_map__d native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected TrieMap(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public TrieMap()
                {
                    var __V = typeof(V);
                    if (__V.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method trie_map_V_ ignored in specialization global::gambit.Gambit.Agg.TrieMap<double>.");
                    }
                    throw new ArgumentOutOfRangeException("V", string.Join(", ", new[] { typeof(V).FullName }), "global::gambit.Gambit.Agg.TrieMap<V> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <double>.");
                }

                public TrieMap(int branches)
                {
                    var __V = typeof(V);
                    if (__V.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method trie_map_V_ ignored in specialization global::gambit.Gambit.Agg.TrieMap<double>.");
                    }
                    throw new ArgumentOutOfRangeException("V", string.Join(", ", new[] { typeof(V).FullName }), "global::gambit.Gambit.Agg.TrieMap<V> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <double>.");
                }

                public TrieMap(global::gambit.Gambit.Agg.TrieMap<V> other)
                {
                    var __V = typeof(V);
                    if (__V.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method trie_map_V_ ignored in specialization global::gambit.Gambit.Agg.TrieMap<double>.");
                    }
                    throw new ArgumentOutOfRangeException("V", string.Join(", ", new[] { typeof(V).FullName }), "global::gambit.Gambit.Agg.TrieMap<V> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <double>.");
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public void Swap(global::gambit.Gambit.Agg.TrieMap<V> other)
                {
                    var __V = typeof(V);
                    if (__V.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Swap ignored in specialization global::gambit.Gambit.Agg.TrieMap<double>.");
                    }
                    throw new ArgumentOutOfRangeException("V", string.Join(", ", new[] { typeof(V).FullName }), "global::gambit.Gambit.Agg.TrieMap<V> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <double>.");
                }

                public void Clear()
                {
                    var __V = typeof(V);
                    if (__V.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Clear ignored in specialization global::gambit.Gambit.Agg.TrieMap<double>.");
                    }
                    throw new ArgumentOutOfRangeException("V", string.Join(", ", new[] { typeof(V).FullName }), "global::gambit.Gambit.Agg.TrieMap<V> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <double>.");
                }

                public void Reset()
                {
                    var __V = typeof(V);
                    if (__V.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method Reset ignored in specialization global::gambit.Gambit.Agg.TrieMap<double>.");
                    }
                    throw new ArgumentOutOfRangeException("V", string.Join(", ", new[] { typeof(V).FullName }), "global::gambit.Gambit.Agg.TrieMap<V> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <double>.");
                }

                public V InnerProd(global::gambit.Gambit.Agg.TrieMap<V> other, V init)
                {
                    var __V = typeof(V);
                    if (__V.IsAssignableFrom(typeof(double)))
                    {
                        throw new MissingMethodException("Method InnerProd ignored in specialization global::gambit.Gambit.Agg.TrieMap<double>.");
                    }
                    throw new ArgumentOutOfRangeException("V", string.Join(", ", new[] { typeof(V).FullName }), "global::gambit.Gambit.Agg.TrieMap<V> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <double>.");
                }

                public static explicit operator global::gambit.Gambit.Agg.TrieMap<V>(int branches)
                {
                    return new global::gambit.Gambit.Agg.TrieMap<V>(branches);
                }

                public uint Size
                {
                    get
                    {
                        var __V = typeof(V);
                        if (__V.IsAssignableFrom(typeof(double)))
                        {
                            throw new MissingMethodException("Method Size missing from explicit specialization global::gambit.Gambit.Agg.TrieMap<double>.");
                        }
                        throw new ArgumentOutOfRangeException("V", string.Join(", ", new[] { typeof(V).FullName }), "global::gambit.Gambit.Agg.TrieMap<V> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <double>.");
                    }
                }

                public bool Empty
                {
                    get
                    {
                        var __V = typeof(V);
                        if (__V.IsAssignableFrom(typeof(double)))
                        {
                            throw new MissingMethodException("Method Empty missing from explicit specialization global::gambit.Gambit.Agg.TrieMap<double>.");
                        }
                        throw new ArgumentOutOfRangeException("V", string.Join(", ", new[] { typeof(V).FullName }), "global::gambit.Gambit.Agg.TrieMap<V> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <double>.");
                    }
                }
            }

            namespace TrieNode
            {
                [StructLayout(LayoutKind.Sequential, Size = 32)]
                public unsafe partial struct __Internalc__N_Gambit_N_agg_S_TrieNode__d
                {
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_Gambit_N_agg_S_TrieNode__d___N_std_S_allocator__S0_ children;
                    internal global::Std.ListIterator.__Internal val;
                }
            }
        }
    }
}
