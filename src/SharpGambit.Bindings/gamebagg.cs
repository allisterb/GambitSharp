// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace gambit
{
    namespace Gambit
    {
        public unsafe partial class GameBAGGRep : global::gambit.Gambit.GameRep, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 152)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_BaseGameRep;
                internal int m_refCount;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_title;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_comment;
                internal uint m_version;
                internal global::Std.SharedPtr.__Internal baggPtr;
                internal global::gambit.Gambit.Array.__Internal agent2baggPlayer;
                internal global::gambit.Gambit.Array.__Internal m_players;
            }

            internal static new GameBAGGRep __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameBAGGRep(native.ToPointer(), skipVTables);
            }

            internal static new GameBAGGRep __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameBAGGRep)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new GameBAGGRep __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GameBAGGRep)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GameBAGGRep __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameBAGGRep(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private GameBAGGRep(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected GameBAGGRep(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Gets the i'th strategy in the game, numbered globally</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep> GetStrategy(int p_index)
            {
                var ___GetStrategyDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 19);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetStrategyDelegate(__Instance, new IntPtr(&___ret), p_index);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameStrategyRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameStrategyRep(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.PureStrategyProfile NewPureStrategyProfile()
            {
                var ___NewPureStrategyProfileDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 23);
                var ___ret = new global::gambit.Gambit.PureStrategyProfile.__Internal();
                ___NewPureStrategyProfileDelegate(__Instance, new IntPtr(&___ret));
                var _____ret = global::gambit.Gambit.PureStrategyProfile.__CreateInstance(___ret);
                global::gambit.Gambit.PureStrategyProfile.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.MixedStrategyProfile<double> NewMixedStrategyProfile(double _0)
            {
                var ___NewMixedStrategyProfileDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_double>(0, 27);
                var ___ret = new global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d();
                ___NewMixedStrategyProfileDelegate(__Instance, new IntPtr(&___ret), _0);
                var _____ret = global::gambit.Gambit.MixedStrategyProfile<double>.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            public override global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational> NewMixedStrategyProfile(global::gambit.Gambit.Rational _0)
            {
                var ___NewMixedStrategyProfile_1Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 26);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = new global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational();
                ___NewMixedStrategyProfile_1Delegate(__Instance, new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            public override global::gambit.Gambit.MixedStrategyProfile<double> NewMixedStrategyProfile(double _0, global::gambit.Gambit.StrategySupportProfile _1)
            {
                var ___NewMixedStrategyProfile_2Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_double___IntPtr>(0, 25);
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = new global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d();
                ___NewMixedStrategyProfile_2Delegate(__Instance, new IntPtr(&___ret), _0, __arg1);
                var _____ret = global::gambit.Gambit.MixedStrategyProfile<double>.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            public override global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational> NewMixedStrategyProfile(global::gambit.Gambit.Rational _0, global::gambit.Gambit.StrategySupportProfile _1)
            {
                var ___NewMixedStrategyProfile_3Delegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr>(0, 24);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = new global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational();
                ___NewMixedStrategyProfile_3Delegate(__Instance, new IntPtr(&___ret), __arg0, __arg1);
                var _____ret = global::gambit.Gambit.MixedStrategyProfile<global::gambit.Gambit.Rational>.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            /// <summary>Returns the pl'th player in the game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> GetPlayer(int pl)
            {
                var ___GetPlayerDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 29);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetPlayerDelegate(__Instance, new IntPtr(&___ret), pl);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Creates a new player in the game, with no moves</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> NewPlayer()
            {
                var ___NewPlayerDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 32);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___NewPlayerDelegate(__Instance, new IntPtr(&___ret));
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the iset'th information set in the game (numbered globally)</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> GetInfoset(int iset)
            {
                var ___GetInfosetDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 33);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetInfosetDelegate(__Instance, new IntPtr(&___ret), iset);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameInfosetRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the act'th action in the game (numbered globally)</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep> GetAction(int act)
            {
                var ___GetActionDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 36);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetActionDelegate(__Instance, new IntPtr(&___ret), act);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameActionRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameActionRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the index'th outcome defined in the game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> GetOutcome(int index)
            {
                var ___GetOutcomeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 38);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___GetOutcomeDelegate(__Instance, new IntPtr(&___ret), index);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameOutcomeRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Creates a new outcome in the game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> NewOutcome()
            {
                var ___NewOutcomeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 39);
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___NewOutcomeDelegate(__Instance, new IntPtr(&___ret));
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameOutcomeRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Deletes the specified outcome from the game</summary>
            public override void DeleteOutcome(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep> _0)
            {
                var ___DeleteOutcomeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 40);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                ___DeleteOutcomeDelegate(__Instance, __arg0);
            }

            public override bool IsPerfectRecall(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> _0, global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> _1)
            {
                var ___IsPerfectRecallDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr___IntPtr___IntPtr>(0, 12);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = ___IsPerfectRecallDelegate(__Instance, __arg0, __arg1);
                return ___ret;
            }

            /// <summary>Returns the smallest payoff in any outcome of the game</summary>
            public override global::gambit.Gambit.Rational GetMinPayoff(int _0 = 0)
            {
                var ___GetMinPayoffDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 10);
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                ___GetMinPayoffDelegate(__Instance, new IntPtr(&___ret), _0);
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Returns the largest payoff in any outcome of the game</summary>
            public override global::gambit.Gambit.Rational GetMaxPayoff(int _0 = 0)
            {
                var ___GetMaxPayoffDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr_int>(0, 11);
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                ___GetMaxPayoffDelegate(__Instance, new IntPtr(&___ret), _0);
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> SetChanceProbs(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep> _0, global::gambit.Gambit.Array<global::gambit.Gambit.Number> _1)
            {
                var ___SetChanceProbsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr>(0, 43);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                if (ReferenceEquals(_1, null))
                    throw new global::System.ArgumentNullException("_1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _1.__Instance;
                var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                ___SetChanceProbsDelegate(__Instance, new IntPtr(&___ret), __arg0, __arg1);
                var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(___ret);
                global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Create a copy of the game, as a new game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> Copy
            {
                get
                {
                    var ___CopyDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 2);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___CopyDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>The number of actions in each information set</summary>
            public override global::gambit.Gambit.PVector<int> NumActions
            {
                get
                {
                    var ___NumActionsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 16);
                    var ___ret = new global::gambit.Gambit.PVector.__Internal();
                    ___NumActionsDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.PVector<int>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>The number of members in each information set</summary>
            public override global::gambit.Gambit.PVector<int> NumMembers
            {
                get
                {
                    var ___NumMembersDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 17);
                    var ___ret = new global::gambit.Gambit.PVector.__Internal();
                    ___NumMembersDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.PVector<int>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>The number of strategies for each player</summary>
            public override global::gambit.Gambit.Array<int> NumStrategies
            {
                get
                {
                    var ___NumStrategiesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 18);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___NumStrategiesDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<int>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>Returns the number of strategy contingencies in the game</summary>
            public override int NumStrategyContingencies
            {
                get
                {
                    var ___NumStrategyContingenciesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 20);
                    var ___ret = ___NumStrategyContingenciesDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the total number of actions in the game</summary>
            public override int BehavProfileLength
            {
                get
                {
                    var ___BehavProfileLengthDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 21);
                    var ___ret = ___BehavProfileLengthDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the total number of strategies in the game</summary>
            public override int MixedProfileLength
            {
                get
                {
                    var ___MixedProfileLengthDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 22);
                    var ___ret = ___MixedProfileLengthDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the number of players in the game</summary>
            public override int NumPlayers
            {
                get
                {
                    var ___NumPlayersDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 28);
                    var ___ret = ___NumPlayersDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the chance (nature) player</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep> Chance
            {
                get
                {
                    var ___GetChanceDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 31);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetChanceDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GamePlayerRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GamePlayerRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Returns the set of information sets in the game</summary>
            public override global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>> Infosets
            {
                get
                {
                    var ___GetInfosetsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 34);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___GetInfosetsDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>Returns an array with the number of information sets per personal player</summary>
            public override global::gambit.Gambit.Array<int> NumInfosets
            {
                get
                {
                    var ___NumInfosetsDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 35);
                    var ___ret = new global::gambit.Gambit.Array.__Internal();
                    ___NumInfosetsDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.Array<int>.__CreateInstance(___ret);
                    var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                    var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                    Marshal.GetDelegateForFunctionPointer<global::gambit.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                    return _____ret;
                }
            }

            /// <summary>Returns the number of outcomes defined in the game</summary>
            public override int NumOutcomes
            {
                get
                {
                    var ___NumOutcomesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 37);
                    var ___ret = ___NumOutcomesDelegate(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Returns the root node of the game</summary>
            public override global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep> Root
            {
                get
                {
                    var ___GetRootDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr>(0, 41);
                    var ___ret = new global::gambit.Gambit.GameObjectPtr.__Internal();
                    ___GetRootDelegate(__Instance, new IntPtr(&___ret));
                    var _____ret = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameNodeRep>.__CreateInstance(___ret);
                    global::gambit.Gambit.GameObjectPtr.__Internal.dtorc__N_Gambit_S_GameObjectPtr____N_Gambit_S_GameNodeRep(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Returns the number of nodes in the game</summary>
            public override int NumNodes
            {
                get
                {
                    var ___NumNodesDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_int___IntPtr>(0, 42);
                    var ___ret = ___NumNodesDelegate(__Instance);
                    return ___ret;
                }
            }

            public override bool IsTree
            {
                get
                {
                    var ___IsTreeDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr>(0, 3);
                    var ___ret = ___IsTreeDelegate(__Instance);
                    return ___ret;
                }
            }

            public virtual bool IsBagg
            {
                get
                {
                    var ___IsBaggDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr>(0, 44);
                    var ___ret = ___IsBaggDelegate(__Instance);
                    return ___ret;
                }
            }

            public override bool IsConstSum
            {
                get
                {
                    var ___IsConstSumDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Func_bool___IntPtr>(0, 9);
                    var ___ret = ___IsConstSumDelegate(__Instance);
                    return ___ret;
                }
            }

            #region Virtual table interop

            // ~GameBAGGRep() override
            private static global::gambit.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // void BuildComputedValues()
            private static global::gambit.Delegates.Action___IntPtr _BuildComputedValuesDelegateInstance;

            private static void _BuildComputedValuesDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                __target.BuildComputedValues();
            }

            // Game Copy() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _CopyDelegateInstance;

            private static void _CopyDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.Copy;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // bool IsTree() const override
            private static global::gambit.Delegates.Func_bool___IntPtr _IsTreeDelegateInstance;

            private static bool _IsTreeDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.IsTree;
                return ___ret;
            }

            // bool IsAgg() const
            private static global::gambit.Delegates.Func_bool___IntPtr _IsAggDelegateInstance;

            private static bool _IsAggDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.IsAgg;
                return ___ret;
            }

            // std::string &GetTitle() const
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _GetTitleDelegateInstance;

            private static __IntPtr _GetTitleDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.Title;
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                return __basicString0.__Instance;
            }

            // void SetTitle(const std::string &p_title)
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetTitleDelegateInstance;

            private static void _SetTitleDelegateHook(__IntPtr __instance, __IntPtr p_title)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(p_title);
                __target.Title = global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            // std::string &GetComment() const
            private static global::gambit.Delegates.Func___IntPtr___IntPtr _GetCommentDelegateInstance;

            private static __IntPtr _GetCommentDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.Comment;
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                return __basicString0.__Instance;
            }

            // void SetComment(const std::string &p_comment)
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _SetCommentDelegateInstance;

            private static void _SetCommentDelegateHook(__IntPtr __instance, __IntPtr p_comment)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(p_comment);
                __target.Comment = global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            // bool IsConstSum() const override
            private static global::gambit.Delegates.Func_bool___IntPtr _IsConstSumDelegateInstance;

            private static bool _IsConstSumDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.IsConstSum;
                return ___ret;
            }

            // Rational GetMinPayoff(int) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetMinPayoffDelegateInstance;

            private static void _GetMinPayoffDelegateHook(__IntPtr __instance, __IntPtr @return, int _0)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.GetMinPayoff(_0);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Rational.__Internal*) @return = *(global::gambit.Gambit.Rational.__Internal*) ___ret.__Instance;
            }

            // Rational GetMaxPayoff(int) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetMaxPayoffDelegateInstance;

            private static void _GetMaxPayoffDelegateHook(__IntPtr __instance, __IntPtr @return, int _0)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.GetMaxPayoff(_0);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Rational.__Internal*) @return = *(global::gambit.Gambit.Rational.__Internal*) ___ret.__Instance;
            }

            // bool IsPerfectRecall(GameInfoset &, GameInfoset &) const override
            private static global::gambit.Delegates.Func_bool___IntPtr___IntPtr___IntPtr _IsPerfectRecallDelegateInstance;

            private static bool _IsPerfectRecallDelegateHook(__IntPtr __instance, __IntPtr _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(_0, false);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(_1, false);
                var ___ret = __target.IsPerfectRecall(__result0, __result1);
                return ___ret;
            }

            // PVector<int> NumActions() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NumActionsDelegateInstance;

            private static void _NumActionsDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumActions;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.PVector.__Internal*) @return = *(global::gambit.Gambit.PVector.__Internal*) ___ret.__Instance;
            }

            // PVector<int> NumMembers() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NumMembersDelegateInstance;

            private static void _NumMembersDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumMembers;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.PVector.__Internal*) @return = *(global::gambit.Gambit.PVector.__Internal*) ___ret.__Instance;
            }

            // Array<int> NumStrategies() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NumStrategiesDelegateInstance;

            private static void _NumStrategiesDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumStrategies;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // GameStrategy GetStrategy(int p_index) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetStrategyDelegateInstance;

            private static void _GetStrategyDelegateHook(__IntPtr __instance, __IntPtr @return, int p_index)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.GetStrategy(p_index);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // int NumStrategyContingencies() const override
            private static global::gambit.Delegates.Func_int___IntPtr _NumStrategyContingenciesDelegateInstance;

            private static int _NumStrategyContingenciesDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumStrategyContingencies;
                return ___ret;
            }

            // int BehavProfileLength() const override
            private static global::gambit.Delegates.Func_int___IntPtr _BehavProfileLengthDelegateInstance;

            private static int _BehavProfileLengthDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.BehavProfileLength;
                return ___ret;
            }

            // int MixedProfileLength() const override
            private static global::gambit.Delegates.Func_int___IntPtr _MixedProfileLengthDelegateInstance;

            private static int _MixedProfileLengthDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.MixedProfileLength;
                return ___ret;
            }

            // PureStrategyProfile NewPureStrategyProfile() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NewPureStrategyProfileDelegateInstance;

            private static void _NewPureStrategyProfileDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NewPureStrategyProfile();
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.PureStrategyProfile.__Internal*) @return = *(global::gambit.Gambit.PureStrategyProfile.__Internal*) ___ret.__Instance;
            }

            // MixedStrategyProfile<Rational> NewMixedStrategyProfile(const Rational &, const StrategySupportProfile &) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr _NewMixedStrategyProfile_3DelegateInstance;

            private static void _NewMixedStrategyProfile_3DelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.Rational.__GetOrCreateInstance(_0, false);
                var __result2 = global::gambit.Gambit.StrategySupportProfile.__GetOrCreateInstance(_1, false);
                var ___ret = __target.NewMixedStrategyProfile(__result1, __result2);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) @return = *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) ___ret.__Instance;
            }

            // MixedStrategyProfile<double> NewMixedStrategyProfile(double, const StrategySupportProfile &) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_double___IntPtr _NewMixedStrategyProfile_2DelegateInstance;

            private static void _NewMixedStrategyProfile_2DelegateHook(__IntPtr __instance, __IntPtr @return, double _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var __result2 = global::gambit.Gambit.StrategySupportProfile.__GetOrCreateInstance(_1, false);
                var ___ret = __target.NewMixedStrategyProfile(_0, __result2);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) @return = *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) ___ret.__Instance;
            }

            // MixedStrategyProfile<Rational> NewMixedStrategyProfile(const Rational &) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr _NewMixedStrategyProfile_1DelegateInstance;

            private static void _NewMixedStrategyProfile_1DelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.Rational.__GetOrCreateInstance(_0, false);
                var ___ret = __target.NewMixedStrategyProfile(__result1);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) @return = *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile____N_Gambit_S_Rational*) ___ret.__Instance;
            }

            // MixedStrategyProfile<double> NewMixedStrategyProfile(double) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_double _NewMixedStrategyProfileDelegateInstance;

            private static void _NewMixedStrategyProfileDelegateHook(__IntPtr __instance, __IntPtr @return, double _0)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NewMixedStrategyProfile(_0);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) @return = *(global::gambit.Gambit.MixedStrategyProfile.__Internalc__N_Gambit_S_MixedStrategyProfile__d*) ___ret.__Instance;
            }

            // int NumPlayers() const override
            private static global::gambit.Delegates.Func_int___IntPtr _NumPlayersDelegateInstance;

            private static int _NumPlayersDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumPlayers;
                return ___ret;
            }

            // GamePlayer GetPlayer(int pl) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetPlayerDelegateInstance;

            private static void _GetPlayerDelegateHook(__IntPtr __instance, __IntPtr @return, int pl)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.GetPlayer(pl);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // Array<GamePlayer> GetPlayers() const
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetPlayersDelegateInstance;

            private static void _GetPlayersDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.Players;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // GamePlayer GetChance() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetChanceDelegateInstance;

            private static void _GetChanceDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.Chance;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GamePlayer NewPlayer() override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NewPlayerDelegateInstance;

            private static void _NewPlayerDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NewPlayer();
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameInfoset GetInfoset(int iset) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetInfosetDelegateInstance;

            private static void _GetInfosetDelegateHook(__IntPtr __instance, __IntPtr @return, int iset)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.GetInfoset(iset);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // Array<GameInfoset> GetInfosets() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetInfosetsDelegateInstance;

            private static void _GetInfosetsDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.Infosets;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // Array<int> NumInfosets() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NumInfosetsDelegateInstance;

            private static void _NumInfosetsDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumInfosets;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.Array.__Internal*) @return = *(global::gambit.Gambit.Array.__Internal*) ___ret.__Instance;
            }

            // GameAction GetAction(int act) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetActionDelegateInstance;

            private static void _GetActionDelegateHook(__IntPtr __instance, __IntPtr @return, int act)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.GetAction(act);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // int NumOutcomes() const override
            private static global::gambit.Delegates.Func_int___IntPtr _NumOutcomesDelegateInstance;

            private static int _NumOutcomesDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumOutcomes;
                return ___ret;
            }

            // GameOutcome GetOutcome(int index) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr_int _GetOutcomeDelegateInstance;

            private static void _GetOutcomeDelegateHook(__IntPtr __instance, __IntPtr @return, int index)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.GetOutcome(index);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // GameOutcome NewOutcome() override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _NewOutcomeDelegateInstance;

            private static void _NewOutcomeDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NewOutcome();
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // void DeleteOutcome(const GameOutcome &) override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _DeleteOutcomeDelegateInstance;

            private static void _DeleteOutcomeDelegateHook(__IntPtr __instance, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var __result0 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameOutcomeRep>.__GetOrCreateInstance(_0, false);
                __target.DeleteOutcome(__result0);
            }

            // GameNode GetRoot() const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr _GetRootDelegateInstance;

            private static void _GetRootDelegateHook(__IntPtr __instance, __IntPtr @return)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.Root;
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // int NumNodes() const override
            private static global::gambit.Delegates.Func_int___IntPtr _NumNodesDelegateInstance;

            private static int _NumNodesDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.NumNodes;
                return ___ret;
            }

            // Game SetChanceProbs(const GameInfoset &, const Array<Number> &) override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr___IntPtr _SetChanceProbsDelegateInstance;

            private static void _SetChanceProbsDelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr _0, __IntPtr _1)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameInfosetRep>.__GetOrCreateInstance(_0, false);
                var __result2 = global::gambit.Gambit.Array<global::gambit.Gambit.Number>.__GetOrCreateInstance(_1, false, skipVTables: true);
                var ___ret = __target.SetChanceProbs(__result1, __result2);
                if (ReferenceEquals(___ret, null))
                    throw new global::System.ArgumentNullException("___ret", "Cannot be null because it is passed by value.");
                *(global::gambit.Gambit.GameObjectPtr.__Internal*) @return = *(global::gambit.Gambit.GameObjectPtr.__Internal*) ___ret.__Instance;
            }

            // bool IsBagg() const
            private static global::gambit.Delegates.Func_bool___IntPtr _IsBaggDelegateInstance;

            private static bool _IsBaggDelegateHook(__IntPtr __instance)
            {
                var __target = global::gambit.Gambit.GameBAGGRep.__GetInstance(__instance);
                var ___ret = __target.IsBagg;
                return ___ret;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[42];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _BuildComputedValuesDelegateInstance += _BuildComputedValuesDelegateHook;
                    _CopyDelegateInstance += _CopyDelegateHook;
                    _IsTreeDelegateInstance += _IsTreeDelegateHook;
                    _IsAggDelegateInstance += _IsAggDelegateHook;
                    _GetTitleDelegateInstance += _GetTitleDelegateHook;
                    _SetTitleDelegateInstance += _SetTitleDelegateHook;
                    _GetCommentDelegateInstance += _GetCommentDelegateHook;
                    _SetCommentDelegateInstance += _SetCommentDelegateHook;
                    _IsConstSumDelegateInstance += _IsConstSumDelegateHook;
                    _GetMinPayoffDelegateInstance += _GetMinPayoffDelegateHook;
                    _GetMaxPayoffDelegateInstance += _GetMaxPayoffDelegateHook;
                    _IsPerfectRecallDelegateInstance += _IsPerfectRecallDelegateHook;
                    _NumActionsDelegateInstance += _NumActionsDelegateHook;
                    _NumMembersDelegateInstance += _NumMembersDelegateHook;
                    _NumStrategiesDelegateInstance += _NumStrategiesDelegateHook;
                    _GetStrategyDelegateInstance += _GetStrategyDelegateHook;
                    _NumStrategyContingenciesDelegateInstance += _NumStrategyContingenciesDelegateHook;
                    _BehavProfileLengthDelegateInstance += _BehavProfileLengthDelegateHook;
                    _MixedProfileLengthDelegateInstance += _MixedProfileLengthDelegateHook;
                    _NewPureStrategyProfileDelegateInstance += _NewPureStrategyProfileDelegateHook;
                    _NewMixedStrategyProfile_3DelegateInstance += _NewMixedStrategyProfile_3DelegateHook;
                    _NewMixedStrategyProfile_2DelegateInstance += _NewMixedStrategyProfile_2DelegateHook;
                    _NewMixedStrategyProfile_1DelegateInstance += _NewMixedStrategyProfile_1DelegateHook;
                    _NewMixedStrategyProfileDelegateInstance += _NewMixedStrategyProfileDelegateHook;
                    _NumPlayersDelegateInstance += _NumPlayersDelegateHook;
                    _GetPlayerDelegateInstance += _GetPlayerDelegateHook;
                    _GetPlayersDelegateInstance += _GetPlayersDelegateHook;
                    _GetChanceDelegateInstance += _GetChanceDelegateHook;
                    _NewPlayerDelegateInstance += _NewPlayerDelegateHook;
                    _GetInfosetDelegateInstance += _GetInfosetDelegateHook;
                    _GetInfosetsDelegateInstance += _GetInfosetsDelegateHook;
                    _NumInfosetsDelegateInstance += _NumInfosetsDelegateHook;
                    _GetActionDelegateInstance += _GetActionDelegateHook;
                    _NumOutcomesDelegateInstance += _NumOutcomesDelegateHook;
                    _GetOutcomeDelegateInstance += _GetOutcomeDelegateHook;
                    _NewOutcomeDelegateInstance += _NewOutcomeDelegateHook;
                    _DeleteOutcomeDelegateInstance += _DeleteOutcomeDelegateHook;
                    _GetRootDelegateInstance += _GetRootDelegateHook;
                    _NumNodesDelegateInstance += _NumNodesDelegateHook;
                    _SetChanceProbsDelegateInstance += _SetChanceProbsDelegateHook;
                    _IsBaggDelegateInstance += _IsBaggDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_BuildComputedValuesDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CopyDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_IsTreeDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_IsAggDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetTitleDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_SetTitleDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetCommentDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_SetCommentDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_IsConstSumDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_GetMinPayoffDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_GetMaxPayoffDelegateInstance);
                    Thunks[12] = Marshal.GetFunctionPointerForDelegate(_IsPerfectRecallDelegateInstance);
                    Thunks[13] = Marshal.GetFunctionPointerForDelegate(_NumActionsDelegateInstance);
                    Thunks[14] = Marshal.GetFunctionPointerForDelegate(_NumMembersDelegateInstance);
                    Thunks[15] = Marshal.GetFunctionPointerForDelegate(_NumStrategiesDelegateInstance);
                    Thunks[16] = Marshal.GetFunctionPointerForDelegate(_GetStrategyDelegateInstance);
                    Thunks[17] = Marshal.GetFunctionPointerForDelegate(_NumStrategyContingenciesDelegateInstance);
                    Thunks[18] = Marshal.GetFunctionPointerForDelegate(_BehavProfileLengthDelegateInstance);
                    Thunks[19] = Marshal.GetFunctionPointerForDelegate(_MixedProfileLengthDelegateInstance);
                    Thunks[20] = Marshal.GetFunctionPointerForDelegate(_NewPureStrategyProfileDelegateInstance);
                    Thunks[21] = Marshal.GetFunctionPointerForDelegate(_NewMixedStrategyProfile_3DelegateInstance);
                    Thunks[22] = Marshal.GetFunctionPointerForDelegate(_NewMixedStrategyProfile_2DelegateInstance);
                    Thunks[23] = Marshal.GetFunctionPointerForDelegate(_NewMixedStrategyProfile_1DelegateInstance);
                    Thunks[24] = Marshal.GetFunctionPointerForDelegate(_NewMixedStrategyProfileDelegateInstance);
                    Thunks[25] = Marshal.GetFunctionPointerForDelegate(_NumPlayersDelegateInstance);
                    Thunks[26] = Marshal.GetFunctionPointerForDelegate(_GetPlayerDelegateInstance);
                    Thunks[27] = Marshal.GetFunctionPointerForDelegate(_GetPlayersDelegateInstance);
                    Thunks[28] = Marshal.GetFunctionPointerForDelegate(_GetChanceDelegateInstance);
                    Thunks[29] = Marshal.GetFunctionPointerForDelegate(_NewPlayerDelegateInstance);
                    Thunks[30] = Marshal.GetFunctionPointerForDelegate(_GetInfosetDelegateInstance);
                    Thunks[31] = Marshal.GetFunctionPointerForDelegate(_GetInfosetsDelegateInstance);
                    Thunks[32] = Marshal.GetFunctionPointerForDelegate(_NumInfosetsDelegateInstance);
                    Thunks[33] = Marshal.GetFunctionPointerForDelegate(_GetActionDelegateInstance);
                    Thunks[34] = Marshal.GetFunctionPointerForDelegate(_NumOutcomesDelegateInstance);
                    Thunks[35] = Marshal.GetFunctionPointerForDelegate(_GetOutcomeDelegateInstance);
                    Thunks[36] = Marshal.GetFunctionPointerForDelegate(_NewOutcomeDelegateInstance);
                    Thunks[37] = Marshal.GetFunctionPointerForDelegate(_DeleteOutcomeDelegateInstance);
                    Thunks[38] = Marshal.GetFunctionPointerForDelegate(_GetRootDelegateInstance);
                    Thunks[39] = Marshal.GetFunctionPointerForDelegate(_NumNodesDelegateInstance);
                    Thunks[40] = Marshal.GetFunctionPointerForDelegate(_SetChanceProbsDelegateInstance);
                    Thunks[41] = Marshal.GetFunctionPointerForDelegate(_IsBaggDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 46, 0);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 46, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                ManagedVTables[0][1] = Thunks[1];
                                ManagedVTables[0][2] = Thunks[2];
                                ManagedVTables[0][3] = Thunks[3];
                                ManagedVTables[0][4] = Thunks[4];
                                ManagedVTables[0][5] = Thunks[5];
                                ManagedVTables[0][6] = Thunks[6];
                                ManagedVTables[0][7] = Thunks[7];
                                ManagedVTables[0][8] = Thunks[8];
                                ManagedVTables[0][9] = Thunks[9];
                                ManagedVTables[0][10] = Thunks[10];
                                ManagedVTables[0][11] = Thunks[11];
                                ManagedVTables[0][12] = Thunks[12];
                                ManagedVTables[0][16] = Thunks[13];
                                ManagedVTables[0][17] = Thunks[14];
                                ManagedVTables[0][18] = Thunks[15];
                                ManagedVTables[0][19] = Thunks[16];
                                ManagedVTables[0][20] = Thunks[17];
                                ManagedVTables[0][21] = Thunks[18];
                                ManagedVTables[0][22] = Thunks[19];
                                ManagedVTables[0][23] = Thunks[20];
                                ManagedVTables[0][24] = Thunks[21];
                                ManagedVTables[0][25] = Thunks[22];
                                ManagedVTables[0][26] = Thunks[23];
                                ManagedVTables[0][27] = Thunks[24];
                                ManagedVTables[0][28] = Thunks[25];
                                ManagedVTables[0][29] = Thunks[26];
                                ManagedVTables[0][30] = Thunks[27];
                                ManagedVTables[0][31] = Thunks[28];
                                ManagedVTables[0][32] = Thunks[29];
                                ManagedVTables[0][33] = Thunks[30];
                                ManagedVTables[0][34] = Thunks[31];
                                ManagedVTables[0][35] = Thunks[32];
                                ManagedVTables[0][36] = Thunks[33];
                                ManagedVTables[0][37] = Thunks[34];
                                ManagedVTables[0][38] = Thunks[35];
                                ManagedVTables[0][39] = Thunks[36];
                                ManagedVTables[0][40] = Thunks[37];
                                ManagedVTables[0][41] = Thunks[38];
                                ManagedVTables[0][42] = Thunks[39];
                                ManagedVTables[0][43] = Thunks[40];
                                ManagedVTables[0][44] = Thunks[41];
                                VTables.Methods[0] = new Delegate[46];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_int(__IntPtr __instance, int arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr_int(__IntPtr __instance, __IntPtr arg1, int arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool___IntPtr___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate int Func_int___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr_double(__IntPtr __instance, __IntPtr arg1, double arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr_double___IntPtr(__IntPtr __instance, __IntPtr arg1, double arg2, __IntPtr arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2, __IntPtr arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr_int(__IntPtr __instance, int arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate __IntPtr Func___IntPtr___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr___IntPtr_int(__IntPtr __instance, __IntPtr arg1, __IntPtr arg2, int arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr_int___IntPtr(__IntPtr __instance, __IntPtr arg1, int arg2, __IntPtr arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr_int___IntPtr___IntPtr(__IntPtr __instance, __IntPtr arg1, int arg2, __IntPtr arg3, __IntPtr arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate double Func_double___IntPtr_int(__IntPtr __instance, int arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate double Func_double___IntPtr_int___IntPtr(__IntPtr __instance, int arg1, __IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate double Func_double___IntPtr_int___IntPtr___IntPtr(__IntPtr __instance, int arg1, __IntPtr arg2, __IntPtr arg3);
    }
}
