// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace gambit
{
    namespace Gambit
    {
        /// <summary>Abstract base class for objects that write games to various formats</summary>
        public unsafe abstract partial class GameWriter : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_GameWriter;
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.GameWriter> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.GameWriter>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.GameWriter managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.GameWriter managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static GameWriter __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new GameWriterInternal(native.ToPointer(), skipVTables);
            }

            internal static GameWriter __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (GameWriter)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static GameWriter __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (GameWriter)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static GameWriter __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new GameWriterInternal(native, skipVTables);
            }

            protected GameWriter(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Convert the game to a string-based representation</summary>
            public abstract string Write(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> _0);

            #region Virtual table interop

            // std::string Write(const Game &) const = 0
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr _WriteDelegateInstance;

            private static void _WriteDelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr _0)
            {
                var __target = global::gambit.Gambit.GameWriter.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__GetOrCreateInstance(_0, false);
                var ___ret = __target.Write(__result1);
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _WriteDelegateInstance += _WriteDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                                if (destructorOnly)
                                    return VTables;
                            }
                        }
                    }

                    *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Format the strategic representation of a game to HTML tables.</summary>
        public unsafe partial class HTMLGameWriter : global::gambit.Gambit.GameWriter, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_GameWriter;
            }

            internal static new HTMLGameWriter __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new HTMLGameWriter(native.ToPointer(), skipVTables);
            }

            internal static new HTMLGameWriter __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (HTMLGameWriter)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new HTMLGameWriter __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (HTMLGameWriter)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static HTMLGameWriter __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new HTMLGameWriter(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private HTMLGameWriter(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected HTMLGameWriter(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
            }

            /// <summary>
            /// <para>Convert the game to HTML, with player 1 on the rows and player 2</para>
            /// <para>on the columns.</para>
            /// </summary>
            public override string Write(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> p_game)
            {
                var ___WriteDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 0);
                if (ReferenceEquals(p_game, null))
                    throw new global::System.ArgumentNullException("p_game", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = p_game.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___WriteDelegate(__Instance, new IntPtr(&___ret), __arg0);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            #region Virtual table interop

            // std::string Write(const Game &p_game) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr _WriteDelegateInstance;

            private static void _WriteDelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr p_game)
            {
                var __target = global::gambit.Gambit.HTMLGameWriter.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__GetOrCreateInstance(p_game, false);
                var ___ret = __target.Write(__result1);
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _WriteDelegateInstance += _WriteDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                                if (destructorOnly)
                                    return VTables;
                            }
                        }
                    }

                    *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Format the strategic representation of a game to LaTeX sgame style</summary>
        public unsafe partial class LaTeXGameWriter : global::gambit.Gambit.GameWriter, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_GameWriter;
            }

            internal static new LaTeXGameWriter __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new LaTeXGameWriter(native.ToPointer(), skipVTables);
            }

            internal static new LaTeXGameWriter __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (LaTeXGameWriter)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new LaTeXGameWriter __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (LaTeXGameWriter)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static LaTeXGameWriter __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new LaTeXGameWriter(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private LaTeXGameWriter(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected LaTeXGameWriter(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
            }

            /// <summary>
            /// <para>Convert the game to LaTeX, with player 1 on the rows and player 2</para>
            /// <para>on the columns.</para>
            /// </summary>
            public override string Write(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> p_game)
            {
                var ___WriteDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 0);
                if (ReferenceEquals(p_game, null))
                    throw new global::System.ArgumentNullException("p_game", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = p_game.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___WriteDelegate(__Instance, new IntPtr(&___ret), __arg0);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            #region Virtual table interop

            // std::string Write(const Game &p_game) const override
            private static global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr _WriteDelegateInstance;

            private static void _WriteDelegateHook(__IntPtr __instance, __IntPtr @return, __IntPtr p_game)
            {
                var __target = global::gambit.Gambit.LaTeXGameWriter.__GetInstance(__instance);
                var __result1 = global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep>.__GetOrCreateInstance(p_game, false);
                var ___ret = __target.Write(__result1);
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, ___ret);
                *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _WriteDelegateInstance += _WriteDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 1, 0);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[1];
                                if (destructorOnly)
                                    return VTables;
                            }
                        }
                    }

                    *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class GameWriterInternal : global::gambit.Gambit.GameWriter, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal GameWriterInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            internal GameWriterInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Convert the game to a string-based representation</summary>
            public override string Write(global::gambit.Gambit.GameObjectPtr<global::gambit.Gambit.GameRep> _0)
            {
                var ___WriteDelegate = __VTables.GetMethodDelegate<global::gambit.Delegates.Action___IntPtr___IntPtr___IntPtr>(0, 0);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___WriteDelegate(__Instance, new IntPtr(&___ret), __arg0);
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }
        }
    }
}
