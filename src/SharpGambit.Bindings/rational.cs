// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace gambit
{
    namespace Gambit
    {
        /// <summary>A representation of an arbitrary-precision rational number</summary>
        public unsafe partial class Rational : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal global::gambit.Gambit.Integer.__Internal num;
                internal global::gambit.Gambit.Integer.__Internal den;

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "??1Rational@Gambit@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Rational> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::gambit.Gambit.Rational>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::gambit.Gambit.Rational managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::gambit.Gambit.Rational managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Rational __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Rational(native.ToPointer(), skipVTables);
            }

            internal static Rational __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Rational)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Rational __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Rational(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Rational(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Rational(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            protected global::gambit.Gambit.Integer Num
            {
                get
                {
                    return global::gambit.Gambit.Integer.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->num));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->num = *(global::gambit.Gambit.Integer.__Internal*) value.__Instance;
                }
            }

            protected global::gambit.Gambit.Integer Den
            {
                get
                {
                    return global::gambit.Gambit.Integer.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->den));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->den = *(global::gambit.Gambit.Integer.__Internal*) value.__Instance;
                }
            }
        }

        public unsafe partial class rational
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?sign@Gambit@@YAHAEBVRational@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Sign(__IntPtr x);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?abs@Gambit@@YA?AVRational@1@AEBV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Abs(__IntPtr @return, __IntPtr x);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?sqr@Gambit@@YA?AVRational@1@AEBV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Sqr(__IntPtr @return, __IntPtr x);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?pow@Gambit@@YA?AVRational@1@AEBV21@J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Pow(__IntPtr @return, __IntPtr x, int y);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?pow@Gambit@@YA?AVRational@1@AEBV21@AEBVInteger@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Pow(__IntPtr @return, __IntPtr x, __IntPtr y);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?floor@Gambit@@YA?AVInteger@1@AEBVRational@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Floor(__IntPtr @return, __IntPtr x);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?ceil@Gambit@@YA?AVInteger@1@AEBVRational@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Ceil(__IntPtr @return, __IntPtr x);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?trunc@Gambit@@YA?AVInteger@1@AEBVRational@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Trunc(__IntPtr @return, __IntPtr x);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?round@Gambit@@YA?AVInteger@1@AEBVRational@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Round(__IntPtr @return, __IntPtr x);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?compare@Gambit@@YAHAEBVRational@1@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int Compare(__IntPtr x, __IntPtr y);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?add@Gambit@@YAXAEBVRational@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Add(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?sub@Gambit@@YAXAEBVRational@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Sub(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?mul@Gambit@@YAXAEBVRational@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Mul(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "?div@Gambit@@YAXAEBVRational@1@0AEAV21@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Div(__IntPtr x, __IntPtr y, __IntPtr dest);

                [SuppressUnmanagedCodeSecurity, DllImport("sharpgambit", EntryPoint = "??$lexical_cast@VRational@Gambit@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Gambit@@YA?AVRational@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void LexicalCast(__IntPtr @return, __IntPtr _0);
            }

            public static int Sign(global::gambit.Gambit.Rational x)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = __Internal.Sign(__arg0);
                return ___ret;
            }

            public static global::gambit.Gambit.Rational Abs(global::gambit.Gambit.Rational x)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                __Internal.Abs(new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Rational Sqr(global::gambit.Gambit.Rational x)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                __Internal.Sqr(new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Rational Pow(global::gambit.Gambit.Rational x, int y)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                __Internal.Pow(new IntPtr(&___ret), __arg0, y);
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Rational Pow(global::gambit.Gambit.Rational x, global::gambit.Gambit.Integer y)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                __Internal.Pow(new IntPtr(&___ret), __arg0, __arg1);
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Floor(global::gambit.Gambit.Rational x)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Floor(new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Ceil(global::gambit.Gambit.Rational x)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Ceil(new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Trunc(global::gambit.Gambit.Rational x)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Trunc(new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static global::gambit.Gambit.Integer Round(global::gambit.Gambit.Rational x)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                var ___ret = new global::gambit.Gambit.Integer.__Internal();
                __Internal.Round(new IntPtr(&___ret), __arg0);
                var _____ret = global::gambit.Gambit.Integer.__CreateInstance(___ret);
                global::gambit.Gambit.Integer.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static int Compare(global::gambit.Gambit.Rational x, global::gambit.Gambit.Rational y)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                var ___ret = __Internal.Compare(__arg0, __arg1);
                return ___ret;
            }

            public static void Add(global::gambit.Gambit.Rational x, global::gambit.Gambit.Rational y, global::gambit.Gambit.Rational dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Add(__arg0, __arg1, __arg2);
            }

            public static void Sub(global::gambit.Gambit.Rational x, global::gambit.Gambit.Rational y, global::gambit.Gambit.Rational dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Sub(__arg0, __arg1, __arg2);
            }

            public static void Mul(global::gambit.Gambit.Rational x, global::gambit.Gambit.Rational y, global::gambit.Gambit.Rational dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Mul(__arg0, __arg1, __arg2);
            }

            public static void Div(global::gambit.Gambit.Rational x, global::gambit.Gambit.Rational y, global::gambit.Gambit.Rational dest)
            {
                if (ReferenceEquals(x, null))
                    throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = x.__Instance;
                if (ReferenceEquals(y, null))
                    throw new global::System.ArgumentNullException("y", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = y.__Instance;
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = dest.__Instance;
                __Internal.Div(__arg0, __arg1, __arg2);
            }

            public static global::gambit.Gambit.Rational LexicalCast(string _0)
            {
                var __basicString0 = new global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, _0);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::gambit.Gambit.Rational.__Internal();
                __Internal.LexicalCast(new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var _____ret = global::gambit.Gambit.Rational.__CreateInstance(___ret);
                global::gambit.Gambit.Rational.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }
        }
    }
}
